<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Splitting Comets Game – With Comet Trails and Transparent Comets</title>
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      background: black;
      overflow: hidden;
    }

    canvas {
      display: block;
      background: black;
      visibility: hidden; /* Initially hidden until loading completes */
    }
    
    /* Auth UI overlay styles */
    .auth-overlay {
      position: absolute;
      top: 10px;
      right: 10px;
      display: flex;
      align-items: center;
      z-index: 1000;
      background: rgba(0, 20, 40, 0.6);
      padding: 5px 10px;
      border-radius: 5px;
      box-shadow: 0 0 10px rgba(0, 150, 255, 0.3);
    }
    
    #user-status {
      margin-right: 15px;
      font-size: 14px;
      color: #aaa;
      font-family: sans-serif;
    }
    
    #auth-button {
      background: rgba(0, 150, 255, 0.6);
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 3px;
      cursor: pointer;
      font-size: 14px;
      transition: background 0.3s;
    }
    
    #auth-button:hover {
      background: rgba(0, 180, 255, 0.8);
    }
    
    /* Loading screen styles */
    #loading-screen {
      position: fixed;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      background: black;
      z-index: 2000;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    .loading-container {
      text-align: center;
    }
    
    .loading-text {
      color: #0af;
      font-family: 'Arial', sans-serif;
      font-size: 24px;
      margin-bottom: 20px;
      text-shadow: 0 0 10px rgba(0, 150, 255, 0.8);
    }
    
    .loading-bar-container {
      width: 300px;
      height: 20px;
      background: rgba(0, 20, 40, 0.6);
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 0 10px rgba(0, 150, 255, 0.3);
    }
    
    #loading-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(to right, #0055aa, #00aaff);
      border-radius: 10px;
      transition: width 0.3s ease;
    }
  </style>
  <!-- Firebase App (the core Firebase SDK) -->
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
  <!-- Add Firebase Firestore -->
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>
  <!-- Add Firebase Authentication -->
  <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
  <!-- Include the auth.js file with Firebase Authentication code -->
  <script src="js/auth.js"></script>
  <!-- Include the scores.js file with Firebase code -->
  <script src="scores.js"></script>
  <script src="scoreboard.js"></script>

</head>

<body>
  <!-- Authentication UI overlay -->
  <div class="auth-overlay">
    <span id="user-status">Playing as Guest</span>
    <button id="auth-button">Login</button>
  </div>
  
  <!-- Loading screen overlay (initially hidden) -->
  <div id="loading-screen" style="display: none;">
    <div class="loading-container">
      <div class="loading-text">Loading...</div>
      <div class="loading-bar-container">
        <div id="loading-bar"></div>
      </div>
    </div>
  </div>
  
  <canvas id="gameCanvas" tabindex="1"></canvas>
  <script>
    (function () {
      /*
        ---- SOUND EFFECTS ----
        bulletSound: 0.2s wood tap
        hitSound: 0.2s flick (each hit plays fully at lower volume)
        explosionSound: using local file "small-explosion-94980.mp3"
      */
      // Use your local file for explosion sounds.
      const explosionSoundURL = "expl-sfx.mp3";
      const bulletSoundSrc = "";
      const hitSoundSrc = "";
      const powerUpSound = new Audio("mixkit-video-game-health-recharge-2837.wav");
      const victorySound = new Audio("mixkit-cheering-crowd-loud-whistle.wav");
      const defeatSound = new Audio("mixkit-arcade-retro-game-over.wav");
      victorySound.volume = 0.4;
      defeatSound.volume = 0.3;

      // Initialize sound system
      let currentMusicTrack = "";
      const bgMusic = new Audio();
      bgMusic.loop = true;
      bgMusic.volume = 0.1;
      let musicEnabled = true; // Track music state
      let soundEnabled = true; // Track sound effects state
      
      // Make sure gameState is accessible to auth.js as a string
      function updateGameState(newState) {
        gameState = newState;
        window.gameState = newState;
      }

      // Function to toggle music on/off
      function toggleMusic() {
        musicEnabled = !musicEnabled;
        
        if (musicEnabled) {
          // Resume music based on current game state
          if (gameState === GAME_STATE.MAIN_MENU || gameState === GAME_STATE.SETTINGS || 
              gameState === GAME_STATE.DIFFICULTY_SELECT || gameState === GAME_STATE.HOW_TO_PLAY || 
              gameState === GAME_STATE.HIGH_SCORES) {
            startMenuMusic();
          } else if (gameState === GAME_STATE.PLAYING) {
            startGameplayMusic();
          }
        } else {
          // Pause music
          bgMusic.pause();
        }
      }
      
      // Function to toggle all sounds (music and effects)
      function toggleAllSounds() {
        soundEnabled = !soundEnabled;
        
        if (!soundEnabled) {
          // Mute all sound effects
          powerUpSound.muted = true;
          victorySound.muted = true;
          defeatSound.muted = true;
          
          // Mute sound pools
          for (let sound of bulletSoundPool) {
            sound.muted = true;
          }
          for (let sound of hitSoundPool) {
            sound.muted = true;
          }
        } else {
          // Unmute all sound effects
          powerUpSound.muted = false;
          victorySound.muted = false;
          defeatSound.muted = false;
          
          // Unmute sound pools
          for (let sound of bulletSoundPool) {
            sound.muted = false;
          }
          for (let sound of hitSoundPool) {
            sound.muted = false;
          }
        }
      }

      // Function to start menu music
      function startMenuMusic() {
        if (currentMusicTrack !== "menu") {
          bgMusic.pause();
          bgMusic.src = "menu_music.mp3"; 
          bgMusic.load();
          if (musicEnabled) {
            bgMusic.play().catch(err => console.error("Error playing menu music:", err));
          }
          currentMusicTrack = "menu";
        } else if (musicEnabled && bgMusic.paused) {
          bgMusic.play().catch(err => console.error("Error resuming menu music:", err));
        }
      }

      // Add a game loading state
      let isLoading = false;
      let originalSoundState = true;
      
      // Add a function to reset the game state completely
      function resetGameState() {
        // Reset all game objects and timers
        comets = [];
        bigComets = [];
        bullets = [];
        sparks = [];
        smallExplosionParticles = [];
        powerUps = [];
        
        // Reset game time and spawn timers
        gameTime = 0;
        lastSpawnTime = 0;
        lastBigSpawnTime = 0;
        lastPowerUpTime = 0;
        
        // Reset score
        score = 0;
        
        // Reset infinity mode variables
        infinityModeTime = 0;
        infinityModeSpawnMultiplier = 1.0;
        
        // Initialize the spaceship in the center
        initializeShip(selectedShipType);
      }
      
      // Save original sound functions to restore later
      const originalPlayMethod = Audio.prototype.play;
      
      // Function to completely disable all sounds
      function disableSounds() {
        // Store original sound state
        originalSoundState = soundEnabled;
        
        // Disable all sound playing globally by overriding the play method
        Audio.prototype.play = function() {
          return Promise.resolve();
        };
        
        // Pause all currently playing sounds
        powerUpSound.pause();
        victorySound.pause();
        defeatSound.pause();
        bgMusic.pause();
        
        // Pause all sound pools
        for (let sound of bulletSoundPool) {
          sound.pause();
        }
        for (let sound of hitSoundPool) {
          sound.pause();
        }
        
        // Set global sound state to disabled
        window.soundEnabled = false;
      }
      
      // Function to restore sounds to original state
      function restoreSounds() {
        // Restore the original play method
        Audio.prototype.play = originalPlayMethod;
        
        // Restore the original sound enabled state
        window.soundEnabled = originalSoundState;
        
        // If music should be playing, restart it
        if (musicEnabled && currentMusicTrack === "gameplay") {
          bgMusic.play().catch(err => console.error("Error playing music:", err));
        }
      }
      
      // Function to start gameplay music with delay
      function startGameplayMusic() {
        // Set loading flag to pause game updates
        isLoading = true;
        
        // Disable all sounds during loading
        disableSounds();
        
        // Show loading screen
        document.getElementById('loading-screen').style.display = 'flex';
        document.getElementById('loading-bar').style.width = '0%';
        
        // Preload resources
        const ingameMusic = new Audio("ingame_music.mp3");
        
        // Loading animation - slower to give 5 seconds total
        let loadProgress = 0;
        const loadInterval = setInterval(() => {
          // Slower progress to make it last 5 seconds
          loadProgress += 2;
          document.getElementById('loading-bar').style.width = loadProgress + '%';
          
          if (loadProgress >= 100) {
            clearInterval(loadInterval);
            
            // Hide loading screen and start the game
            setTimeout(() => {
              // First reset all game objects
              resetGameState();
              
              // Then hide loading screen
              document.getElementById('loading-screen').style.display = 'none';
              
              // Start the gameplay music
              if (currentMusicTrack !== "gameplay") {
                bgMusic.pause();
                bgMusic.src = "ingame_music.mp3";
                bgMusic.load();
                if (musicEnabled) {
                  bgMusic.play().catch(err => console.error("Error playing gameplay music:", err));
                }
                currentMusicTrack = "gameplay";
              } else if (musicEnabled && bgMusic.paused) {
                bgMusic.play().catch(err => console.error("Error resuming gameplay music:", err));
              }
              
              // Restore sounds to original state
              restoreSounds();
              
              // Release the loading flag to allow game updates
              isLoading = false;
            }, 500);
          }
        }, 100); // 50 steps × 100ms = 5000ms (5 seconds)
      }

      // Add error handling for music loading
      bgMusic.onerror = function() {
        console.error("Error loading music file:", bgMusic.src);
      };

      // Game states
      const GAME_STATE = {
        MAIN_MENU: "mainMenu",
        DIFFICULTY_SELECT: "difficultySelect",
        SHIP_SELECT: "shipSelect",
        SETTINGS: "settings",
        HOW_TO_PLAY: "howToPlay",
        HIGH_SCORES: "highScores",
        PLAYING: "playing",
        PAUSE_MENU: "pauseMenu",
        GAME_OVER: "gameOver",
        WIN: "win"
      };
      
      let gameState = GAME_STATE.MAIN_MENU;
      
      // Variable to track selected item in pause menu
      let pauseMenuSelectedItem = 0;
      
      // Make gameState accessible to auth.js
      window.gameState = gameState;
      
      // Variables to track high scores
      let highScores = {
        easy: 0,
        medium: 0,
        hard: 0,
        infinity: 0,
        usernames: {
          easy: "None",
          medium: "None",
          hard: "None",
          infinity: "None"
        }
      };
      
      // Spaceship types
      const SHIP_TYPE = {
        DEFAULT: "default",
        LASER: "laser",
        MISSILE: "missile"
      };
      
      // Selected ship type (default to first ship)
      let selectedShipType = SHIP_TYPE.DEFAULT;
      
      // Ship selection menu
      let selectedShipMenuItem = 0;
      
      // Load high scores from Firebase when the game starts
      function loadHighScores() {
        // Load high score for each difficulty
        getHighScore("easy").then(result => {
          highScores.easy = result.score;
          highScores.usernames.easy = result.username || "None";
          console.log("Loaded easy high score:", highScores.easy, "by", highScores.usernames.easy);
        });
        
        getHighScore("medium").then(result => {
          highScores.medium = result.score;
          highScores.usernames.medium = result.username || "None";
          console.log("Loaded medium high score:", highScores.medium, "by", highScores.usernames.medium);
        });
        
        getHighScore("hard").then(result => {
          highScores.hard = result.score;
          highScores.usernames.hard = result.username || "None";
          console.log("Loaded hard high score:", highScores.hard, "by", highScores.usernames.hard);
        });
        
        getHighScore("infinity").then(result => {
          highScores.infinity = result.score;
          highScores.usernames.infinity = result.username || "None";
          console.log("Loaded infinity high score:", highScores.infinity, "by", highScores.usernames.infinity);
        });
      }
      
      // Load high scores at startup
      loadHighScores();
      
      // Resource loading and game initialization system
      let totalResources = 0;
      let loadedResources = 0;
      let resourcesPreloaded = false;
      
      // Function to update loading progress
      function updateLoadingProgress(increment = 1) {
        loadedResources += increment;
        const percentage = Math.min(100, Math.floor((loadedResources / totalResources) * 100));
        document.getElementById('loading-bar').style.width = percentage + '%';
        
        // If all resources are loaded, hide loading screen and start game
        if (loadedResources >= totalResources && !resourcesPreloaded) {
          resourcesPreloaded = true;
          
          // Start the actual game when loading is complete
          setTimeout(() => {
            document.getElementById('loading-screen').style.opacity = '0';
            setTimeout(() => {
              document.getElementById('loading-screen').style.display = 'none';
              
              // Make sure the canvas is visible
              canvas.style.visibility = 'visible';
              
              // Set game state to playing to actually start the game
              // Use direct assignment to avoid our interceptor
              window.gameState = GAME_STATE.PLAYING;
              
              console.log("Loading complete - starting game");
            }, 500);
          }, 200);
        }
      }
      
      // Function to preload audio files
      function preloadAudio(audioArray) {
        audioArray.forEach(audio => {
          if (audio.src) {
            audio.addEventListener('canplaythrough', () => {
              updateLoadingProgress();
            }, { once: true });
            
            // Handle errors during loading
            audio.addEventListener('error', () => {
              console.warn('Failed to load audio:', audio.src);
              updateLoadingProgress();
            }, { once: true });
          } else {
            // If audio has no source, count it as already loaded
            updateLoadingProgress();
          }
        });
      }
      
      // Function to preload images
      function preloadImages(imageSources) {
        const images = [];
        
        imageSources.forEach(src => {
          const img = new Image();
          
          img.onload = () => {
            updateLoadingProgress();
          };
          
          img.onerror = () => {
            console.warn('Failed to load image:', src);
            updateLoadingProgress();
          };
          
          img.src = src;
          images.push(img);
        });
        
        return images;
      }
      
      // Function to wrap the normal game start process with loading screen
      function startGameWithLoading(shipType) {
        // Store the selected ship type
        selectedShipType = shipType;
        
        // Set game to temporary loading state
        const previousGameState = gameState;
        gameState = "loading";  // Custom state to prevent drawing during loading
        
        // Reset loading progress
        loadedResources = 0;
        resourcesPreloaded = false;
        document.getElementById('loading-bar').style.width = '0%';
        
        // Show the loading screen
        document.getElementById('loading-screen').style.display = 'flex';
        document.getElementById('loading-screen').style.opacity = '1';
        
        // Hide the canvas during loading
        canvas.style.visibility = 'hidden';
        
        // Resources to preload
        const audioElements = [
          // Main audio tracks
          new Audio('menu_music.mp3'),
          new Audio('ingame_music.mp3'),
          // Sound effects
          powerUpSound, victorySound, defeatSound,
          new Audio('mixkit-achievement-bell-600.wav'),
          new Audio(explosionSoundURL),
          new Audio('retro-explode.mp3'),
          new Audio('small-explosion.mp3')
        ];
        
        // Preload any images
        const imageSources = [
          'favicon.ico'
        ];
        
        // Initialize resource counter
        totalResources = audioElements.length + imageSources.length + 5; // Audio + Images + Initialization steps
        
        // Start preloading resources
        preloadAudio(audioElements);
        preloadImages(imageSources);
        
        // Initialize ship based on selected type
        initializeShip(selectedShipType);
        
        // Reset game variables
        score = 0;
        gameTime = 0;
        winTriggered = false;
        
        // Reset infinity mode time and multiplier
        infinityModeTime = 0;
        infinityModeSpawnMultiplier = 1.0;
        
        // Initialization steps with slight delays
        setTimeout(() => { updateLoadingProgress(); }, 100);
        setTimeout(() => { updateLoadingProgress(); }, 200);
        setTimeout(() => { updateLoadingProgress(); }, 300);
        setTimeout(() => { updateLoadingProgress(); }, 400);
        setTimeout(() => { startGameplayMusic(); updateLoadingProgress(); }, 500);
      }
      
      // Add a wrapper function to intercept gameState changes
      const originalSetState = Object.getOwnPropertyDescriptor(window, 'gameState') || 
                             { get: function() { return gameState; }, 
                               set: function(newValue) { gameState = newValue; } };
      
      // Define a property to intercept gameState changes
      Object.defineProperty(window, 'gameState', {
        get: function() { 
          return gameState; 
        },
        set: function(newValue) {
          // If transitioning from SHIP_SELECT to PLAYING, show loading screen
          if (gameState === GAME_STATE.SHIP_SELECT && newValue === GAME_STATE.PLAYING) {
            console.log("Intercepted game state change: SHIP_SELECT -> PLAYING");
            
            // Call startGameWithLoading with the current selected ship type
            let shipTypeToUse;
            switch(selectedShipMenuItem) {
              case 0: shipTypeToUse = SHIP_TYPE.DEFAULT; break;
              case 1: shipTypeToUse = SHIP_TYPE.LASER; break;
              case 2: shipTypeToUse = SHIP_TYPE.MISSILE; break;
              default: shipTypeToUse = SHIP_TYPE.DEFAULT;
            }
            
            // Use our loading function instead of direct state change
            startGameWithLoading(shipTypeToUse);
            
            // Set to a temporary state during loading
            gameState = "loading";
            return;
          }
          
          // For all other state changes, just set the state
          gameState = newValue;
        }
      });
      
      // Monkey patch the update function to respect loading state
      const originalUpdate = window.update || function(){};
      window.update = function(dt) {
        // Skip all updates while loading is in progress
        if (isLoading || gameState === "loading") {
          return;
        }
        
        // Call the original update function
        if (typeof originalUpdate === 'function') {
          originalUpdate(dt);
        }
      };
      
      // Pause menu and navigation will be handled in the main keydown listener
      
      // Initialize basic elements when the page loads
      document.addEventListener('DOMContentLoaded', function() {
        // Set loading screen transition
        document.getElementById('loading-screen').style.transition = 'opacity 0.5s ease';
        
        // Initialize sound pools before trying to use them
        createSoundPools();
        
        // Start menu music
        startMenuMusic();
        
        // Initialize background elements for menu
        initStarfield();
        initMenuBackground();
        
        // Make canvas visible for menu navigation
        canvas.style.visibility = 'visible';
      });
      
      // Create sound pools
      function createSoundPools() {
        // This function is called early to ensure pools exist before they're used in toggleAllSounds
        if (!bulletSoundPool) bulletSoundPool = [];
        if (!hitSoundPool) hitSoundPool = [];
      }

      // Create a pool for bullet sounds (pool size 3)
      const BULLET_SOUND_POOL_SIZE = 3;
      const bulletSoundPool = [];
      for (let i = 0; i < BULLET_SOUND_POOL_SIZE; i++) {
        let a = new Audio(bulletSoundSrc);
        a.volume = 0.25;
        bulletSoundPool.push(a);
      }
      let nextBulletSoundIndex = 0;

      // Create a much smaller pool for hit sounds at lower volume
      const HIT_SOUND_POOL_SIZE = 3;
      const hitSoundPool = [];
      for (let i = 0; i < HIT_SOUND_POOL_SIZE; i++) {
        let a = new Audio(hitSoundSrc);
        a.volume = 0.1; // Reduced volume
        hitSoundPool.push(a);
      }
      let nextHitSoundIndex = 0;
      
      // Add throttling for hit sounds
      let lastHitSoundTime = 0;
      const HIT_SOUND_THROTTLE = 150; // Minimum milliseconds between hit sounds

      // ----- BACKGROUND MUSIC -----
      // Background music is now started automatically on page load

      // ----- Setup Canvas -----
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      resizeCanvas();
      window.addEventListener("resize", () => {
        resizeCanvas();
        initStarfield();
      });
      canvas.focus();
      
      // ----- Menu Background System -----
      let menuBgLoaded = false;
      let menuBgOffset = {x: 0, y: 0}; // For slow panning motion
      let menuBgCanvas, menuBgCtx;
      
      // Create a separate canvas for the menu background
      function initMenuBackground() {
        menuBgCanvas = document.createElement('canvas');
        menuBgCanvas.width = canvas.width;
        menuBgCanvas.height = canvas.height;
        menuBgCtx = menuBgCanvas.getContext('2d');
        
        // Draw the static menu background
        drawMenuBackground();
        menuBgLoaded = true;
      }
      
      // Draw the menu background components
      function drawMenuBackground() {
        // Reset the canvas
        menuBgCtx.clearRect(0, 0, menuBgCanvas.width, menuBgCanvas.height);
        
        // 1. Deep Space Background gradient
        const bgGradient = menuBgCtx.createRadialGradient(
          menuBgCanvas.width/2, menuBgCanvas.height/2, 10,
          menuBgCanvas.width/2, menuBgCanvas.height/2, menuBgCanvas.height
        );
        bgGradient.addColorStop(0, '#1a1a40'); // Deep blue/purple
        bgGradient.addColorStop(0.6, '#0c0c20'); // Darker blue
        bgGradient.addColorStop(1, '#000000'); // Black at edges
        
        menuBgCtx.fillStyle = bgGradient;
        menuBgCtx.fillRect(0, 0, menuBgCanvas.width, menuBgCanvas.height);
        
        // 2. Nebula-like wispy clouds
        drawNebulaWisps(menuBgCtx);
        
        // 3. Stars with varying sizes and colors
        drawStarField(menuBgCtx);
        
        // 4. Small distant planet with rings
        drawDistantPlanet(menuBgCtx);
        
        // 5. Comet field diagonally across screen
        drawCometField(menuBgCtx);
        
        // 6. Subtle spaceship silhouette
        drawShipSilhouette(menuBgCtx);
      }
      
      // Draw nebula-like wisps
      function drawNebulaWisps(ctx) {
        ctx.save();
        
        // Create several nebula patches
        for (let i = 0; i < 5; i++) {
          // Random positions, mostly around edges
          let x, y;
          const edgePos = Math.random() < 0.7;
          
          if (edgePos) {
            // Position near edges
            if (Math.random() < 0.5) {
              // Left or right edge
              x = Math.random() < 0.5 ? canvas.width * 0.1 : canvas.width * 0.9;
              y = canvas.height * Math.random();
            } else {
              // Top or bottom edge
              x = canvas.width * Math.random();
              y = Math.random() < 0.5 ? canvas.height * 0.1 : canvas.height * 0.9;
            }
          } else {
            // Random position anywhere
            x = canvas.width * Math.random();
            y = canvas.height * Math.random();
          }
          
          // Create nebula gradient
          const size = Math.random() * 300 + 200;
          const grad = ctx.createRadialGradient(
            x, y, 0,
            x, y, size
          );
          
          // Purple/blue nebula colors with low opacity
          const hue = 240 + Math.random() * 60; // Blue to purple
          grad.addColorStop(0, `hsla(${hue}, 70%, 30%, 0.08)`);
          grad.addColorStop(0.5, `hsla(${hue}, 60%, 20%, 0.05)`);
          grad.addColorStop(1, 'rgba(0,0,0,0)');
          
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fill();
        }
        
        ctx.restore();
      }
      
      // Draw starfield
      function drawStarField(ctx) {
        ctx.save();
        
        // Draw around 500 stars of varying sizes and colors
        for (let i = 0; i < 500; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const size = Math.random() * 2 + 0.5;
          
          // Occasionally use colored stars
          let color;
          if (Math.random() < 0.1) {
            // Create some colored stars
            const hue = Math.random() < 0.5 ? 
              Math.floor(Math.random() * 60) : // Yellowish
              Math.floor(Math.random() * 30) + 200; // Blueish
            color = `hsla(${hue}, 80%, 80%, 0.8)`;
          } else {
            // White stars
            color = 'rgba(255, 255, 255, 0.8)';
          }
          
          // Draw the star
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fillStyle = color;
          ctx.fill();
          
          // Add glow to brighter stars
          if (size > 1.5) {
            ctx.beginPath();
            ctx.arc(x, y, size * 2, 0, Math.PI * 2);
            const grad = ctx.createRadialGradient(
              x, y, size/2,
              x, y, size * 2
            );
            grad.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
            grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = grad;
            ctx.fill();
          }
        }
        
        ctx.restore();
      }
      
      // Draw a distant planet with rings
      function drawDistantPlanet(ctx) {
        ctx.save();
        
        // Planet position in upper corner
        const x = canvas.width * 0.15;
        const y = canvas.height * 0.2;
        const radius = canvas.height * 0.08; // Small planet
        
        // Planet gradient
        const planetGrad = ctx.createRadialGradient(
          x - radius * 0.2, y - radius * 0.2, radius * 0.1,
          x, y, radius
        );
        planetGrad.addColorStop(0, '#4a6fa3'); // Lighter bluish
        planetGrad.addColorStop(0.6, '#2c5289'); // Medium blue
        planetGrad.addColorStop(1, '#1c3b6f'); // Darker blue
        
        // Draw planet
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fillStyle = planetGrad;
        ctx.fill();
        
        // Planet rings
        ctx.beginPath();
        ctx.ellipse(x, y, radius * 2, radius * 0.5, Math.PI/6, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(180, 190, 220, 0.3)';
        ctx.lineWidth = radius * 0.1;
        ctx.stroke();
        
        // Ring shadow
        ctx.beginPath();
        ctx.ellipse(x, y, radius * 1.8, radius * 0.45, Math.PI/6, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(100, 120, 180, 0.15)';
        ctx.lineWidth = radius * 0.3;
        ctx.stroke();
        
        ctx.restore();
      }
      
      // Draw comet field diagonally
      function drawCometField(ctx) {
        ctx.save();
        
        // Create diagonal path for comets (lower left to upper right)
        const startX = -canvas.width * 0.2;
        const startY = canvas.height * 1.2;
        const endX = canvas.width * 1.2;
        const endY = -canvas.height * 0.2;
        
        // Comets along the path
        const numComets = 18; // Number of comets in the field
        
        for (let i = 0; i < numComets; i++) {
          // Position along the diagonal path
          const t = i / (numComets - 1);
          const x = startX + (endX - startX) * t;
          const y = startY + (endY - startY) * t;
          
          // Randomize position slightly
          const offsetX = (Math.random() - 0.5) * canvas.width * 0.3;
          const offsetY = (Math.random() - 0.5) * canvas.height * 0.3;
          
          const cometX = x + offsetX;
          const cometY = y + offsetY;
          
          // Random comet size, larger in the center, smaller at ends
          const centerOffset = Math.abs(t - 0.5);
          const sizeMultiplier = 1 - centerOffset;
          const radius = (10 + Math.random() * 25) * sizeMultiplier;
          
          // Create comet shape
          ctx.beginPath();
          
          // Comet body
          ctx.arc(cometX, cometY, radius, 0, Math.PI * 2);
          
          // Tail length based on size
          const tailLength = radius * (3 + Math.random() * 2);
          
          // Tail direction (mostly upper left to lower right)
          const angle = Math.PI * 0.75 + (Math.random() - 0.5) * 0.5;
          
          // Draw the tail
          ctx.moveTo(cometX, cometY);
          ctx.lineTo(
            cometX + Math.cos(angle) * tailLength,
            cometY + Math.sin(angle) * tailLength
          );
          
          // Set comet color with blue cyan outlines
          ctx.fillStyle = 'rgba(30, 30, 50, 0.7)';
          ctx.fill();
          
          // Add blue/cyan outline
          ctx.strokeStyle = 'rgba(100, 200, 255, 0.3)';
          ctx.lineWidth = 2;
          ctx.stroke();
          
          // Add glow effect for bigger comets
          if (radius > 20) {
            ctx.beginPath();
            ctx.arc(cometX, cometY, radius * 1.5, 0, Math.PI * 2);
            
            const glowGrad = ctx.createRadialGradient(
              cometX, cometY, radius * 0.8,
              cometX, cometY, radius * 1.5
            );
            glowGrad.addColorStop(0, 'rgba(100, 200, 255, 0.1)');
            glowGrad.addColorStop(1, 'rgba(100, 200, 255, 0)');
            
            ctx.fillStyle = glowGrad;
            ctx.fill();
          }
        }
        
        ctx.restore();
      }
      
      // Draw subtle spaceship silhouette
      function drawShipSilhouette(ctx) {
        ctx.save();
        
        // Ship position at bottom center
        const x = canvas.width / 2;
        const y = canvas.height * 0.85;
        const size = canvas.height * 0.05; // Very small
        
        // Very subtle, almost invisible
        ctx.globalAlpha = 0.15;
        
        // Simple ship silhouette
        ctx.beginPath();
        ctx.moveTo(x, y - size); // Top
        ctx.lineTo(x + size * 0.7, y + size * 0.5); // Bottom right
        ctx.lineTo(x - size * 0.7, y + size * 0.5); // Bottom left
        ctx.closePath();
        
        // Very subtle gradient
        const shipGrad = ctx.createLinearGradient(
          x, y - size,
          x, y + size
        );
        shipGrad.addColorStop(0, 'rgba(200, 220, 255, 0.3)');
        shipGrad.addColorStop(1, 'rgba(100, 150, 200, 0.1)');
        
        ctx.fillStyle = shipGrad;
        ctx.fill();
        
        // Add very faint engine glow
        ctx.beginPath();
        ctx.arc(x, y + size * 0.5, size * 0.3, 0, Math.PI * 2);
        
        const glowGrad = ctx.createRadialGradient(
          x, y + size * 0.5, 0,
          x, y + size * 0.5, size * 0.6
        );
        glowGrad.addColorStop(0, 'rgba(100, 180, 255, 0.4)');
        glowGrad.addColorStop(1, 'rgba(100, 180, 255, 0)');
        
        ctx.fillStyle = glowGrad;
        ctx.fill();
        
        ctx.restore();
      }
      
      // Update the menu background (subtle panning)
      function updateMenuBackground(dt) {
        if (!menuBgLoaded) return;
        
        // Very slow panning motion (5-10 pixels per minute)
        const panSpeed = 0.15; // pixels per second
        menuBgOffset.x += panSpeed * dt;
        menuBgOffset.y += panSpeed * 0.7 * dt; // Move slightly slower vertically
        
        // Reset when moved too far
        if (menuBgOffset.x > 100 || menuBgOffset.y > 100) {
          menuBgOffset.x = 0;
          menuBgOffset.y = 0;
        }
      }
      
      // Draw the menu background on the main canvas
      function renderMenuBackground() {
        if (!menuBgLoaded) return;
        
        // Draw with slight offset for slow panning
        ctx.save();
        // Apply 60% opacity
        ctx.globalAlpha = 0.7;
        ctx.drawImage(
          menuBgCanvas, 
          -menuBgOffset.x, -menuBgOffset.y, 
          canvas.width + menuBgOffset.x, canvas.height + menuBgOffset.y
        );
        ctx.restore();
      }
      
      // Initialize the menu background on window load or resize
      window.addEventListener('load', initMenuBackground);
      window.addEventListener('resize', initMenuBackground);

      // ----- Global Constants -----
      const SHIP_ROT_SPEED = 6;       // radians/sec
      const SHIP_REVERSE = 400;     // pixels/sec² (braking)
      const BULLET_SPEED = 600;     // pixels/sec
      const BULLET_RADIUS = 4;
      const BULLET_INTERVAL = 30;      // ms between shots
      const FRICTION = 0.99;

      const SHIP_SIZE = 30;      // spaceship size (pixels)
      const SHIP_ACCEL = 800;     // pixels/sec²
      
      // Triple Shot Power-up Constants
      const TRIPLE_SHOT_DURATION = 20;  // Seconds the power-up lasts
      const TRIPLE_SHOT_POWERUP_COLOR = "#1e90ff"; // Dodger blue color
      const ENHANCED_SHOT_MULTIPLIER = 6; // For Infinity mode when reaching 150% spawn rate
      const TRIPLE_SHOT_SPAWN_TIME = 3; // Seconds before big comets to spawn power-up
      
      // Missile Barrage Power-up Constants
      const MISSILE_BARRAGE_DURATION = 5; // Seconds the power-up lasts
      const MISSILE_BARRAGE_POWERUP_COLOR = "#ffdd00"; // Yellow color
      const MISSILE_SPAWN_FREQUENCY = 0.15; // Seconds between missile volleys
      const MISSILE_SPEED = 900; // Pixels/sec (faster than normal bullets)
      const MISSILE_DAMAGE = 3; // 3x normal damage
      const MISSILE_ROTATION_SPEED = 5; // Rotation speed in radians per second

      // Normal Comets – speeds: 400 to 700
      const COMET_SPEED_MIN = 400;
      const COMET_SPEED_MAX = 700;
      const COMET_FRICTION = 0.998;
      const MAX_COMET_TIER = 3;
      const BASE_COMET_RADIUS = 30;
      const COMET_SPAWN_MIN = 2;
      const COMET_SPAWN_MAX = 3;
      const COMET_SPAWN_BATCH_MIN = 1;
      const COMET_SPAWN_BATCH_MAX = 3;
      const COMET_MIN_SPEED = 250;

      // Big Comets
      let bigComets = [];
      let bigCometSpawnTimer = 0;
      const BIG_COMET_SPAWN_INTERVAL = 25;
      const BIG_COMET_SPAWN_MAX = 1;
      const DIAGONAL_ANGLES = [Math.PI / 4, 3 * Math.PI / 4, 5 * Math.PI / 4, 7 * Math.PI / 4];
      const BIG_COMET_SPEED_MIN = 150;
      const BIG_COMET_SPEED_MAX = 200;
      const BIG_COMET_COLOR = "#cd7f32";
      const BIG_COMET_SCALE = 5.5;
      const BIG_COMET_HEALTH = 1000; // Number of bullet hits required to break
      const BIG_COMET_BREAKUP_PIECES = 20; // Number of tier 2 comets to spawn on explosion

      // Power‑Up Constants
      const POWERUP_SPAWN_INTERVAL = 15;
      const POWERUP_LIFETIME = 15;
      const POWERUP_SIZE = 45; // Core size of power-ups (increased from 30)
      const POWERUP_RADIUS = POWERUP_SIZE; // For collision detection
      const POWERUP_BLINK_SPEED = 5; // Blinking effect speed for power-ups
      const POWERUP_PULSE_SPEED = 2; // Pulsation speed for the glow effect
      const POWERUP_ROTATION_SPEED = 1; // Rotation speed for the orbital particles

      // Pulsar animation variables
      let pulsarActive = true;
      let pulsarX = 100;
      let pulsarY = 100;
      let pulsarRadius = 25;
      let pulsarTime = 0;
      let pulsarColor = 'rgba(100, 200, 255, ';
      
      let powerUps = [];
      let powerUpSpawnTimer = 0;
      let tripleShootPowerUpTimer = 0;
      let tripleShootPowerUpSpawned = false;

      // ----- Difficulty Settings -----
      const DIFFICULTY = {
        EASY: "easy",
        MEDIUM: "medium",
        HARD: "hard",
        INFINITY: "infinity"
      };
      
      // Game duration in seconds for each difficulty
      const GAME_DURATION = {
        [DIFFICULTY.EASY]: 90,
        [DIFFICULTY.MEDIUM]: 110,
        [DIFFICULTY.HARD]: 120,
        [DIFFICULTY.INFINITY]: Infinity
      };
      
      // Comet spawn rate multipliers for each difficulty
      const SPAWN_RATE_MULTIPLIER = {
        [DIFFICULTY.EASY]: 0.4,  // 70% of base rate
        [DIFFICULTY.MEDIUM]: 1.0, // Base rate (100%)
        [DIFFICULTY.HARD]: 1.5,  // 110% of base rate
        [DIFFICULTY.INFINITY]: 1.0 // Starts at base rate, increases over time
      };
      
      // ----- Game State & Timer -----
      let currentDifficulty = DIFFICULTY.MEDIUM; // Default difficulty
      let score = 0;
      let gameTime = 0;
      let winTriggered = false;
      let infinityModeTime = 0; // Tracks time in infinity mode
      let infinityModeSpawnMultiplier = 1.0; // Starting multiplier for infinity mode
      
      // Menu selection tracking
      let selectedMainMenuItem = 0;
      let selectedDifficultyItem = 1; // Default to Medium
      let selectedSettingsItem = 0;
      let selectedPauseMenuItem = 0; // For pause menu
      let previousGameState = null; // To track navigation between screens
      let refreshButtonActive = false; // For scoreboard refresh button

      // Spaceship
      let spaceship = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        vx: 0,
        vy: 0,
        angle: 0,
        size: SHIP_SIZE,
        hitPoints: 5,
        previousHitPoints: 5, // Track previous health for shake detection
        healthShakeTimer: 0,  // Timer for health bar shake animation
        healthScaleTimer: 0,  // Timer for health bar scale animation
        hitFlashTimer: 0,
        tripleShot: false,
        tripleShotTimer: 0,
        missileBarrageActive: false,
        missileBarrageTimer: 0,
        
        // Ship type specific properties
        type: SHIP_TYPE.DEFAULT,
        
        // Laser beam properties (for LASER type)
        laserActive: false,
        laserTimer: 0,
        laserCooldown: false,
        laserCooldownTimer: 0,
        
        // Missile properties (for MISSILE type)
        missileSpecialCooldown: 0,
        
        // Ship type movement modifiers
        speedModifier: 1.0
      };
      
      // Missile barrage state variables
      let lastMissileSpawnTime = 0;
      let missilePatternRotation = 0; // Current rotation angle of the missile pattern

      let bullets = [];
      let sparks = [];
      let smallExplosionParticles = [];
      let comets = [];

      // ----- Background Elements -----
      const NUM_STARS = 500;
      const NUM_DISTANT_STARS = 200;
      const NUM_NEBULA_CLOUDS = 5;
      const NUM_DUST_PARTICLES = 120;
      const NUM_SHOOTING_STARS = 3;
      
      let stars = [];
      let distantStars = []; // Parallax effect stars
      let nebulaClouds = [];
      let spaceDust = [];
      let shootingStars = [];
      let auroraPoints = [];
      
      // Initialize all background elements
      function initStarfield() {
        // Reset all arrays
        stars = [];
        distantStars = [];
        nebulaClouds = [];
        spaceDust = [];
        shootingStars = [];
        auroraPoints = [];
        
        // Regular stars (closer/faster)
        for (let i = 0; i < NUM_STARS; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const baseSize = Math.random() * 2 + 0.5;
          const flicker = Math.random() < 0.7;
          const sizeVariation = flicker ? (Math.random() * 1 + 0.2) : 0;
          const sizeSpeed = flicker ? (Math.random() * 0.5 + 0.2) : 0;
          const sizeTime = flicker ? Math.random() * Math.PI * 2 : 0;
          // Add color variations for some stars
          const colorHue = Math.random() < 0.2 ? 
            Math.floor(Math.random() * 60) + (Math.random() < 0.5 ? 0 : 180) : // red/orange or blue tones
            null; // white (default)
          stars.push({ 
            x, y, baseSize, sizeVariation, sizeSpeed, sizeTime, flicker, 
            colorHue,
            parallaxFactor: 1.0 
          });
        }
        
        // Distant stars (parallax effect - move slower)
        for (let i = 0; i < NUM_DISTANT_STARS; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const baseSize = Math.random() * 1.5 + 0.3;
          const flicker = Math.random() < 0.3; // Less flickering in distance
          const sizeVariation = flicker ? (Math.random() * 0.7 + 0.1) : 0;
          const sizeSpeed = flicker ? (Math.random() * 0.3 + 0.1) : 0;
          const sizeTime = flicker ? Math.random() * Math.PI * 2 : 0;
          distantStars.push({ 
            x, y, baseSize, sizeVariation, sizeSpeed, sizeTime, flicker,
            parallaxFactor: 0.3 // Move much slower
          });
        }
        
        // Nebula clouds
        for (let i = 0; i < NUM_NEBULA_CLOUDS; i++) {
          // Create larger-scale nebula elements
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const width = Math.random() * 300 + 200;
          const height = Math.random() * 200 + 150;
          
          // Random nebula colors - purples, blues, reds
          const colorPalette = [
            'rgba(110, 20, 170, 0.07)',  // Purple
            'rgba(50, 70, 180, 0.06)',   // Blue
            'rgba(180, 50, 90, 0.05)',   // Red
            'rgba(60, 100, 200, 0.07)',  // Light blue
            'rgba(180, 90, 30, 0.05)'    // Orange
          ];
          
          const color = colorPalette[Math.floor(Math.random() * colorPalette.length)];
          const driftSpeed = {
            x: (Math.random() - 0.5) * 4, // Slow horizontal drift
            y: (Math.random() - 0.5) * 2  // Even slower vertical drift
          };
          
          nebulaClouds.push({
            x, y, width, height, color, driftSpeed,
            // Each nebula has several "centers" to create irregular shapes
            centers: Array(Math.floor(Math.random() * 4 + 3)).fill().map(() => ({
              xOffset: (Math.random() - 0.5) * width * 0.7,
              yOffset: (Math.random() - 0.5) * height * 0.7,
              radius: Math.random() * 80 + 40
            })),
            // Animation variables
            time: Math.random() * Math.PI * 2,
            timeFactor: Math.random() * 0.4 + 0.1
          });
        }
        
        // Space dust particles
        for (let i = 0; i < NUM_DUST_PARTICLES; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const size = Math.random() * 1.5 + 0.5;
          const opacity = Math.random() * 0.15 + 0.05; // Very subtle
          const driftSpeed = {
            x: (Math.random() - 0.5) * 15, // Medium drift speed
            y: (Math.random() - 0.5) * 15
          };
          
          spaceDust.push({
            x, y, size, opacity, driftSpeed
          });
        }
        
        // Create shooting stars (inactive initially)
        for (let i = 0; i < NUM_SHOOTING_STARS; i++) {
          shootingStars.push({
            active: false,
            timeToNext: Math.random() * 10 + 5 // Random delay before first appearance
          });
        }
        
        // Aurora points
        const numPoints = 15;
        for (let i = 0; i < numPoints; i++) {
          const xPos = (i / (numPoints - 1)) * canvas.width;
          auroraPoints.push({
            x: xPos,
            y: canvas.height * 0.05, // Near top of screen
            wavePhase: Math.random() * Math.PI * 2,
            waveSpeed: Math.random() * 0.5 + 0.2
          });
        }
      }
      
      initStarfield();
      
      function updateStarfield(dt) {
        // Update regular stars
        for (let star of stars) {
          if (star.flicker) {
            star.sizeTime += dt * star.sizeSpeed;
          }
        }
        
        // Update distant stars (slower)
        for (let star of distantStars) {
          if (star.flicker) {
            star.sizeTime += dt * star.sizeSpeed * 0.7; // Even slower flicker
          }
        }
        
        // Update nebula clouds - slow drifting motion
        for (let cloud of nebulaClouds) {
          cloud.x += cloud.driftSpeed.x * dt * 0.2;
          cloud.y += cloud.driftSpeed.y * dt * 0.1;
          
          // Wrap around edges
          if (cloud.x < -cloud.width) cloud.x = canvas.width + cloud.width/2;
          if (cloud.x > canvas.width + cloud.width) cloud.x = -cloud.width/2;
          if (cloud.y < -cloud.height) cloud.y = canvas.height + cloud.height/2;
          if (cloud.y > canvas.height + cloud.height) cloud.y = -cloud.height/2;
          
          // Update animation time
          cloud.time += dt * cloud.timeFactor;
        }
        
        // Update space dust - faster drift
        for (let dust of spaceDust) {
          dust.x += dust.driftSpeed.x * dt;
          dust.y += dust.driftSpeed.y * dt;
          
          // Wrap around edges
          if (dust.x < 0) dust.x = canvas.width;
          if (dust.x > canvas.width) dust.x = 0;
          if (dust.y < 0) dust.y = canvas.height;
          if (dust.y > canvas.height) dust.y = 0;
        }
        
        // Update shooting stars
        for (let star of shootingStars) {
          if (!star.active) {
            // Count down to next activation
            star.timeToNext -= dt;
            if (star.timeToNext <= 0) {
              // Activate new shooting star
              star.active = true;
              star.x = Math.random() * canvas.width;
              star.y = Math.random() * (canvas.height * 0.3); // Top third of screen
              star.length = Math.random() * 100 + 50;
              star.angle = Math.PI * 0.25 + Math.random() * Math.PI * 0.5; // Downward angle
              star.speed = Math.random() * 300 + 200;
              star.duration = Math.random() * 2 + 1; // 1-3 seconds
              star.elapsed = 0;
              star.thickness = Math.random() * 2 + 1;
            }
          } else {
            // Update active shooting star
            star.x += Math.cos(star.angle) * star.speed * dt;
            star.y += Math.sin(star.angle) * star.speed * dt;
            star.elapsed += dt;
            
            // Check if shooting star is done
            if (star.elapsed >= star.duration || 
                star.x < -star.length || star.x > canvas.width + star.length ||
                star.y < -star.length || star.y > canvas.height + star.length) {
              star.active = false;
              star.timeToNext = Math.random() * 15 + 5; // 5-20 seconds until next appearance
            }
          }
        }
        
        // Update aurora points
        for (let point of auroraPoints) {
          point.wavePhase += dt * point.waveSpeed;
          // Aurora waves up and down slightly
          point.y = canvas.height * 0.05 + Math.sin(point.wavePhase) * 15;
        }
      }
      
      function drawStarfield(ctx) {
        ctx.save();
        
        // Draw nebula clouds first (behind everything)
        for (let cloud of nebulaClouds) {
          ctx.save();
          // For each cloud, draw multiple overlapping gradients at its "centers"
          for (let center of cloud.centers) {
            const x = cloud.x + center.xOffset;
            const y = cloud.y + center.yOffset;
            // Add subtle pulsing to the radius
            const adjustedRadius = center.radius * (1 + 0.1 * Math.sin(cloud.time));
            
            const gradient = ctx.createRadialGradient(
              x, y, 0,
              x, y, adjustedRadius
            );
            gradient.addColorStop(0, cloud.color);
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, adjustedRadius, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();
        }
        
        // Draw distant stars (parallax effect)
        for (let star of distantStars) {
          let currentSize = star.baseSize;
          if (star.flicker) {
            currentSize += star.sizeVariation * Math.sin(star.sizeTime);
            if (currentSize < 0) currentSize = 0;
          }
          let gradient = ctx.createRadialGradient(
            star.x, star.y, currentSize * 0.2,
            star.x, star.y, currentSize
          );
          gradient.addColorStop(0, "rgba(255,255,255,0.8)");
          gradient.addColorStop(1, "rgba(255,255,255,0)");
          ctx.fillStyle = gradient;
          ctx.shadowBlur = 3; // Less glow for distant stars
          ctx.shadowColor = "white";
          ctx.beginPath();
          ctx.arc(star.x, star.y, currentSize, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Draw closer/regular stars
        for (let star of stars) {
          let currentSize = star.baseSize;
          if (star.flicker) {
            currentSize += star.sizeVariation * Math.sin(star.sizeTime);
            if (currentSize < 0) currentSize = 0;
          }
          
          // Color or white based on star properties
          let innerColor, outerColor;
          if (star.colorHue !== null) {
            innerColor = `hsla(${star.colorHue}, 80%, 70%, 1)`;
            outerColor = `hsla(${star.colorHue}, 80%, 70%, 0)`;
          } else {
            innerColor = "rgba(255,255,255,1)";
            outerColor = "rgba(255,255,255,0)";
          }
          
          let gradient = ctx.createRadialGradient(
            star.x, star.y, currentSize * 0.2,
            star.x, star.y, currentSize
          );
          gradient.addColorStop(0, innerColor);
          gradient.addColorStop(1, outerColor);
          ctx.fillStyle = gradient;
          ctx.shadowBlur = 5;
          ctx.shadowColor = star.colorHue !== null ? innerColor : "white";
          ctx.beginPath();
          ctx.arc(star.x, star.y, currentSize, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Draw space dust particles
        ctx.shadowBlur = 0; // No glow for dust
        for (let dust of spaceDust) {
          ctx.fillStyle = `rgba(255,255,255,${dust.opacity})`;
          ctx.beginPath();
          ctx.arc(dust.x, dust.y, dust.size, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Draw shooting stars
        for (let star of shootingStars) {
          if (star.active) {
            ctx.save();
            // Fade in at start and out at end
            const fade = Math.min(star.elapsed, star.duration - star.elapsed) / 0.3;
            const alpha = Math.min(1, fade);
            
            // Trail gradient
            const gradient = ctx.createLinearGradient(
              star.x, star.y,
              star.x - Math.cos(star.angle) * star.length,
              star.y - Math.sin(star.angle) * star.length
            );
            gradient.addColorStop(0, `rgba(255,255,255,${alpha})`);
            gradient.addColorStop(0.3, `rgba(200,200,255,${alpha * 0.6})`);
            gradient.addColorStop(1, 'rgba(200,200,255,0)');
            
            ctx.strokeStyle = gradient;
            ctx.lineWidth = star.thickness;
            ctx.shadowBlur = 10;
            ctx.shadowColor = "white";
            
            ctx.beginPath();
            ctx.moveTo(star.x, star.y);
            ctx.lineTo(
              star.x - Math.cos(star.angle) * star.length,
              star.y - Math.sin(star.angle) * star.length
            );
            ctx.stroke();
            ctx.restore();
          }
        }
        
        // Draw aurora effect near the top of the screen
        if (auroraPoints.length > 1) {
          ctx.save();
          // Create aurora gradient
          const gradient = ctx.createLinearGradient(
            canvas.width / 2, 0,
            canvas.width / 2, canvas.height * 0.15
          );
          gradient.addColorStop(0, 'rgba(0, 200, 100, 0.2)'); // Green
          gradient.addColorStop(0.5, 'rgba(20, 100, 200, 0.1)'); // Blue
          gradient.addColorStop(1, 'rgba(0, 0, 0, 0)'); // Fade out
          
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.moveTo(0, canvas.height);
          
          // Draw top curve
          ctx.moveTo(0, auroraPoints[0].y);
          for (let i = 0; i < auroraPoints.length - 1; i++) {
            const xMid = (auroraPoints[i].x + auroraPoints[i+1].x) / 2;
            const yMid = (auroraPoints[i].y + auroraPoints[i+1].y) / 2;
            ctx.quadraticCurveTo(
              auroraPoints[i].x, auroraPoints[i].y,
              xMid, yMid
            );
          }
          // Last curve
          ctx.quadraticCurveTo(
            auroraPoints[auroraPoints.length-1].x, 
            auroraPoints[auroraPoints.length-1].y,
            canvas.width, auroraPoints[auroraPoints.length-1].y
          );
          
          // Complete the aurora shape
          ctx.lineTo(canvas.width, 0);
          ctx.lineTo(0, 0);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }
        
        ctx.restore();
      }

      function generateStonePattern() {
        const baseColors = [
        "#8B4513", // Saddle Brown
          "#A0522D", // Sienna
          "#6B4423", // Deep Brown
          "#8B5742", // Light Brown
          "#654321", // Dark Brown
          "#704214", // Rustic Brown
          "#5C4033", // Rich Brown
          "#4A3728", // Dark Chocolate
          "#6F4E37", // Coffee
          "#7B3F00"  // Chocolate
        ];
        // Pick a random base color
        const baseColor = baseColors[Math.floor(Math.random() * baseColors.length)];

        let patternCanvas = document.createElement("canvas");
        patternCanvas.width = 50;
        patternCanvas.height = 50;
        let pctx = patternCanvas.getContext("2d");

        // Use the chosen base color
        pctx.fillStyle = baseColor;
        pctx.fillRect(0, 0, patternCanvas.width, patternCanvas.height);

        // Add random speckles for texture
        for (let i = 0; i < 20; i++) {
          let x = Math.random() * patternCanvas.width;
          let y = Math.random() * patternCanvas.height;
          let radius = Math.random() * 3;
          // Use random gray values for the speckles
          let gray = Math.floor(100 + Math.random() * 50);
          pctx.fillStyle = `rgb(${gray}, ${gray}, ${gray})`;
          pctx.beginPath();
          pctx.arc(x, y, radius, 0, 2 * Math.PI);
          pctx.fill();
        }

        return ctx.createPattern(patternCanvas, "repeat");
      }

      // Planet animation state vars
      let ringRotation = -Math.PI / 6; // Fixed rotation angle - no rotation
      let planetGlowTime = 0; // Time for planet glow effect
      let planetGlowSpeed = 0.3; // Reduced speed of glow pulsation for less trembling
      
      // ----- Cronos Planet -----
      function drawCronos(ctx) {
        // Planet position & size
        const x = canvas.width * 0.75;
        const y = canvas.height * 0.5;
        const radius = 200; // Planet radius
        
        // Update planet animation values - reduced trembling
        planetGlowTime += 0.016; // Approximate dt for consistent animation
        const glowStrength = 3 + Math.sin(planetGlowTime * planetGlowSpeed) * 1.2; // Reduced oscillation
        
        // No rotation of rings
        
        // ---------- Planet Surface Features ----------
        // Create surface details canvas
        const surfaceCanvas = document.createElement('canvas');
        surfaceCanvas.width = radius * 2.5;
        surfaceCanvas.height = radius * 2.5;
        const surfaceCtx = surfaceCanvas.getContext('2d');
        
        // Base planet color
        surfaceCtx.fillStyle = "#b09b83";
        surfaceCtx.fillRect(0, 0, surfaceCanvas.width, surfaceCanvas.height);
        
        // Add some large darker areas (craters and surface features)
        for (let i = 0; i < 8; i++) {
          const featureX = Math.random() * surfaceCanvas.width;
          const featureY = Math.random() * surfaceCanvas.height;
          const featureSize = Math.random() * radius * 0.8 + radius * 0.3;
          const featureGradient = surfaceCtx.createRadialGradient(
            featureX, featureY, 0,
            featureX, featureY, featureSize
          );
          featureGradient.addColorStop(0, 'rgba(80, 70, 55, 0.4)');
          featureGradient.addColorStop(1, 'rgba(120, 110, 95, 0)');
          
          surfaceCtx.fillStyle = featureGradient;
          surfaceCtx.beginPath();
          surfaceCtx.arc(featureX, featureY, featureSize, 0, Math.PI * 2);
          surfaceCtx.fill();
        }
        
        // Create lighter areas for highlands
        for (let i = 0; i < 6; i++) {
          const featureX = Math.random() * surfaceCanvas.width;
          const featureY = Math.random() * surfaceCanvas.height;
          const featureSize = Math.random() * radius * 0.6 + radius * 0.2;
          const featureGradient = surfaceCtx.createRadialGradient(
            featureX, featureY, 0,
            featureX, featureY, featureSize
          );
          featureGradient.addColorStop(0, 'rgba(200, 190, 170, 0.3)');
          featureGradient.addColorStop(1, 'rgba(200, 190, 170, 0)');
          
          surfaceCtx.fillStyle = featureGradient;
          surfaceCtx.beginPath();
          surfaceCtx.arc(featureX, featureY, featureSize, 0, Math.PI * 2);
          surfaceCtx.fill();
        }
        
        // The planet's surface pattern
        const surfacePattern = ctx.createPattern(surfaceCanvas, 'no-repeat');

        // ---------- Planet Gradient with Surface ----------
        const grad = ctx.createRadialGradient(x, y, radius * 0.2, x, y, radius);
        grad.addColorStop(0.2, "#c9b8a3"); // center
        grad.addColorStop(0.5, "#b09b83");
        grad.addColorStop(0.8, "#97856f");
        grad.addColorStop(1, "#7f6f5a"); // outer edge

        // ---------- Ring Geometry ----------
        const ringOuter = radius * 1.9;   // Outer ellipse radius
        const ringInner = radius * 1.25;  // Inner ellipse radius
        const ringFlatten = 0.45;         // How "flat" the ring ellipse is

        // ---------- Ring Pattern with Dust ----------
        const ringCanvas = document.createElement("canvas");
        ringCanvas.width = 80;
        ringCanvas.height = 40;
        const ringCtx = ringCanvas.getContext("2d");

        // Semi‑transparent dark fill
        ringCtx.fillStyle = "rgba(60,50,40,0.4)";
        ringCtx.fillRect(0, 0, ringCanvas.width, ringCanvas.height);

        // Scatter small dots for ring dust with some color variation
        for (let i = 0; i < 40; i++) {
          const rx = Math.random() * ringCanvas.width;
          const ry = Math.random() * ringCanvas.height;
          const dustColor = Math.random() < 0.3 ? 
            "rgba(180,160,120,0.5)" : // Lighter dust particles
            "rgba(0,0,0,0.6)";        // Darker dust particles
          ringCtx.fillStyle = dustColor;
          ringCtx.beginPath();
          ringCtx.arc(rx, ry, Math.random() * 1.5 + 0.5, 0, 2 * Math.PI);
          ringCtx.fill();
        }

        const ringPattern = ctx.createPattern(ringCanvas, "repeat");

        // Helper function: draw half of a donut arc from angleStart to angleEnd
        // Using "evenodd" so the inner ellipse carves out a hole.
        function drawDonutArc(angleStart, angleEnd) {
          ctx.beginPath();
          // Outer ellipse arc
          ctx.ellipse(0, 0, ringOuter, ringOuter * ringFlatten, 0, angleStart, angleEnd, true);
          // Inner ellipse arc (reverse)
          ctx.ellipse(0, 0, ringInner, ringInner * ringFlatten, 0, angleEnd, angleStart, false);
          ctx.fillStyle = ringPattern;
          ctx.fill("evenodd");
        }

        // ---------- DRAW THE RING BACK HALF ----------
        // (the portion behind the planet)
        ctx.save();
        // Move to planet center & tilt the ring - now with animation
        ctx.translate(x, y);
        ctx.rotate(ringRotation);
        // e.g. 0..Math.PI is the "back half" after rotation
        drawDonutArc(0, Math.PI);
        ctx.restore();

        // ---------- DRAW THE PLANET ----------
        ctx.save();
        
        // Draw planet glow
        const glowGradient = ctx.createRadialGradient(
          x, y, radius * 0.9,
          x, y, radius * 1.5
        );
        glowGradient.addColorStop(0, 'rgba(180,160,140,0.2)');
        glowGradient.addColorStop(1, 'rgba(180,160,140,0)');
        
        ctx.fillStyle = glowGradient;
        ctx.beginPath();
        ctx.arc(x, y, radius * 1.5, 0, 2 * Math.PI);
        ctx.fill();
        
        // Draw the main planet with pattern
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI);
        ctx.fill();
        
        // Apply the surface pattern to the planet
        ctx.globalCompositeOperation = 'multiply';
        ctx.translate(x - radius * 1.25, y - radius * 1.25);
        ctx.fillStyle = surfacePattern;
        ctx.beginPath();
        ctx.arc(radius * 1.25, radius * 1.25, radius, 0, 2 * Math.PI);
        ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
        
        // Draw atmosphere highlight
        ctx.translate(-x + radius * 1.25, -y + radius * 1.25);
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI);
        const highlight = ctx.createRadialGradient(
          x - radius * 0.3, y - radius * 0.3, 0,
          x, y, radius
        );
        highlight.addColorStop(0, 'rgba(240,230,215,0.15)');
        highlight.addColorStop(0.6, 'rgba(240,230,215,0.03)');
        highlight.addColorStop(1, 'rgba(240,230,215,0)');
        ctx.fillStyle = highlight;
        ctx.fill();
        
        ctx.restore();

        // ---------- DRAW THE RING FRONT HALF ----------
        // (the portion in front of the planet)
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(ringRotation);
        // front half is Math.PI..2*Math.PI
        drawDonutArc(Math.PI, 2 * Math.PI);
        ctx.restore();
        
        // No ring shadow on the planet as requested
        ctx.restore();
      }


      function drawMusicIcon() {
        const iconSize = 40;
        const margin = 20;
        const x = margin;
        const y = margin;
        
        ctx.save();
        ctx.fillStyle = "white";
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        
        // Draw speaker base
        ctx.beginPath();
        ctx.moveTo(x, y + iconSize/2);
        ctx.lineTo(x + iconSize/3, y + iconSize/2);
        ctx.lineTo(x + iconSize*2/3, y);
        ctx.lineTo(x + iconSize*2/3, y + iconSize);
        ctx.lineTo(x + iconSize/3, y + iconSize/2);
        ctx.closePath();
        ctx.fill();
        
        // Draw sound waves if sound is enabled - check both music and sound effects
        if (musicEnabled && soundEnabled) {
          // First wave
          ctx.beginPath();
          ctx.arc(x + iconSize*2/3, y + iconSize/2, iconSize/3, -Math.PI/4, Math.PI/4);
          ctx.stroke();
          
          // Second wave
          ctx.beginPath();
          ctx.arc(x + iconSize*2/3, y + iconSize/2, iconSize*2/3, -Math.PI/4, Math.PI/4);
          ctx.stroke();
        } else {
          // Draw X over the speaker when either sound or music is off
          ctx.beginPath();
          ctx.moveTo(x + iconSize/3, y + iconSize/4);
          ctx.lineTo(x + iconSize, y + iconSize*3/4);
          ctx.stroke();
          
          ctx.beginPath();
          ctx.moveTo(x + iconSize, y + iconSize/4);
          ctx.lineTo(x + iconSize/3, y + iconSize*3/4);
          ctx.stroke();
        }
        
        ctx.restore();
      }

      function drawHealthBar(x, y, barWidth, barHeight) {
        // Use default values if not provided - now centered with bigger dimensions
        barWidth = barWidth || 150; // Wider bar (was 100)
        barHeight = barHeight || 20; // Taller bar (was 15)
        
        // Center the health bar by default
        x = x || (canvas.width / 2 - barWidth / 2);
        y = y || 60; // Positioned lower to avoid overlapping with high score text
        
        ctx.save();
        
        // Apply shake and scale effects if timers are active
        if (spaceship.healthShakeTimer > 0 || spaceship.healthScaleTimer > 0) {
          // Calculate the center of the health bar for transformations
          const centerX = x + barWidth / 2;
          const centerY = y + barHeight / 2;
          
          // First translate to the center point
          ctx.translate(centerX, centerY);
          
          // Apply symmetric circular shake effect if timer is active
          if (spaceship.healthShakeTimer > 0) {
            // Create a deliberate, circular shake pattern rather than random
            const progress = 1 - (spaceship.healthShakeTimer / 0.5); // 0-1 representing shake progress
            const frequency = 20; // Controls shake oscillation speed
            const maxAmplitude = 8; // Maximum pixels to move in any direction
            
            // Calculate decreasing amplitude as shake fades out
            const amplitude = maxAmplitude * (1 - progress);
            
            // Create circular motion with decreasing radius
            const angle = progress * frequency * Math.PI * 2; // Rotates through 2π multiple times
            const shakeX = Math.cos(angle) * amplitude;
            const shakeY = Math.sin(angle) * amplitude;
            
            ctx.translate(shakeX, shakeY);
          }
          
          // Apply smooth pulsing scale effect if timer is active
          if (spaceship.healthScaleTimer > 0) {
            // Start larger and smoothly decrease
            const progress = 1 - (spaceship.healthScaleTimer / 0.3); // 0-1 representing scale progress
            
            // Non-linear easing for more natural animation
            const easing = 1 - Math.pow(progress, 2); // Quadratic ease-out
            
            // Scale from 1.3 down to 1.0 over time
            const scaleAmount = 1 + (0.3 * easing);
            
            ctx.scale(scaleAmount, scaleAmount);
          }
          
          // Translate back to apply the transformations correctly
          ctx.translate(-centerX, -centerY);
        }
        
        // Draw health bar background and border
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        ctx.fillStyle = "rgba(0, 0, 0, 0.5)"; // Dark background
        ctx.fillRect(x, y, barWidth, barHeight); // Fill the background
        ctx.strokeRect(x, y, barWidth, barHeight);
        ctx.strokeRect(x, y, barWidth, barHeight);
        
        // Get max HP based on ship type
        let maxHP;
        if (spaceship.type === SHIP_TYPE.LASER) {
          maxHP = 7; // Heavy cruiser has more HP
        } else if (spaceship.type === SHIP_TYPE.MISSILE) {
          maxHP = 5; // Missile ship now has same HP as default
        } else {
          maxHP = 5; // Default ship has standard HP
        }
        
        // Draw health bar fill
        // Ensure hitPoints is never negative and calculate fraction
        let hitPoints = Math.max(0, spaceship.hitPoints);
        let hpFraction = hitPoints / maxHP;
        
        // Make sure the fraction is valid (between 0 and 1)
        hpFraction = Math.max(0, Math.min(1, hpFraction));
        
        // Change color based on health level
        if (hpFraction > 0.6) {
          ctx.fillStyle = "rgba(50, 205, 50, 0.8)"; // Green for good health (slightly more opaque)
        } else if (hpFraction > 0.3) {
          ctx.fillStyle = "rgba(255, 165, 0, 0.8)"; // Orange for medium health
        } else {
          ctx.fillStyle = "rgba(255, 0, 0, 0.8)"; // Red for low health
        }
        
        // Draw the health bar with a minimum width of 2 pixels when health is low but not zero
        const fillWidth = hitPoints > 0 ? Math.max(2, barWidth * hpFraction) : 0;
        ctx.fillRect(x, y, fillWidth, barHeight);
        
        // Add "HP" label
        ctx.fillStyle = "white";
        ctx.font = "14px sans-serif"; // Slightly larger font
        ctx.textAlign = "right";
        ctx.fillText("HP:", x - 8, y + barHeight/2 + 5);
        
        // Add segments to the health bar for visual clarity
        ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
        ctx.lineWidth = 1;
        
        for (let i = 1; i < maxHP; i++) {
          const segX = x + (barWidth / maxHP) * i;
          ctx.beginPath();
          ctx.moveTo(segX, y);
          ctx.lineTo(segX, y + barHeight);
          ctx.stroke();
        }
        
        ctx.restore();
        
        // Draw shield bar for laser ship if it has a shield
        if (spaceship.type === SHIP_TYPE.LASER && spaceship.hasShield) {
          const shieldBarHeight = barHeight - 2; // Slightly smaller than health bar
          const shieldY = y + barHeight + 8; // Position shield bar below health bar with a bit more space
          
          ctx.save();
          
          // Apply shake effect if health shake is active (same circular pattern)
          if (spaceship.healthShakeTimer > 0) {
            // Calculate the center of the shield bar for transformations
            const centerX = x + barWidth / 2;
            const centerY = shieldY + shieldBarHeight / 2;
            
            // First translate to the center point
            ctx.translate(centerX, centerY);
            
            // Create a deliberate, circular shake pattern
            const progress = 1 - (spaceship.healthShakeTimer / 0.5); // 0-1 representing shake progress
            const frequency = 20; // Controls shake oscillation speed
            const maxAmplitude = 7; // Maximum pixels to move (slightly less than health bar)
            
            // Calculate decreasing amplitude as shake fades out
            const amplitude = maxAmplitude * (1 - progress);
            
            // Create circular motion with decreasing radius
            const angle = progress * frequency * Math.PI * 2; // Rotates through 2π multiple times
            const shakeX = Math.cos(angle) * amplitude;
            const shakeY = Math.sin(angle) * amplitude;
            
            ctx.translate(shakeX, shakeY);
            
            // Translate back to apply the transformations correctly
            ctx.translate(-centerX, -centerY);
          }
          
          // Draw shield bar background and border
          ctx.strokeStyle = "white";
          ctx.lineWidth = 1.5;
          ctx.fillStyle = "rgba(0, 0, 0, 0.5)"; // Dark background
          ctx.fillRect(x, shieldY, barWidth, shieldBarHeight); // Fill the background
          ctx.strokeRect(x, shieldY, barWidth, shieldBarHeight);
          
          // Draw shield bar fill based on shield health
          const shieldFraction = spaceship.shieldHealth / 3; // 3 is max shield health
          
          // Make shield bar flash when hit
          let shieldAlpha = 0.7;
          if (spaceship.shieldFlashTimer > 0) {
            // Pulsing effect
            shieldAlpha = 0.7 + Math.sin(gameTime * 30) * 0.3;
          }
          
          // Shield color based on remaining shield strength
          let shieldColor;
          if (shieldFraction > 0.7) {
            shieldColor = `rgba(0, 150, 255, ${shieldAlpha})`; // Blue for strong shield
          } else if (shieldFraction > 0.3) {
            shieldColor = `rgba(0, 220, 220, ${shieldAlpha})`; // Cyan for medium shield
          } else if (shieldFraction > 0) {
            shieldColor = `rgba(255, 170, 0, ${shieldAlpha})`; // Orange for weak shield
          } else {
            shieldColor = `rgba(100, 100, 100, ${shieldAlpha * 0.5})`; // Gray for depleted shield
          }
          
          // Fill shield bar
          ctx.fillStyle = shieldColor;
          // Ensure valid fraction and minimum visible width when shield exists
          const shieldFillWidth = shieldFraction > 0 ? Math.max(2, barWidth * shieldFraction) : 0;
          ctx.fillRect(x, shieldY, shieldFillWidth, shieldBarHeight);
          
          // Add "SH" label (Shield)
          ctx.fillStyle = "white";
          ctx.font = "12px sans-serif"; // Slightly larger font
          ctx.textAlign = "right";
          ctx.fillText("SH:", x - 8, shieldY + shieldBarHeight/2 + 4);
          
          // Add segments to the shield bar for visual clarity
          ctx.strokeStyle = "rgba(255, 255, 255, 0.3)";
          ctx.lineWidth = 1;
          
          for (let i = 1; i < 3; i++) { // 3 segments for shield
            const segX = x + (barWidth / 3) * i;
            ctx.beginPath();
            ctx.moveTo(segX, shieldY);
            ctx.lineTo(segX, shieldY + shieldBarHeight);
            ctx.stroke();
          }
          
          ctx.restore();
        }
      }

      // Helper function to check if a power-up of a specific type already exists
      function powerUpTypeExists(type) {
        return powerUps.some(pu => pu.type === type);
      }
      
      function spawnPowerUp() {
        let loc = getPowerUpSpawnLocation(); // Use the central spawn location
        
        // Define possible power-up types and their weights
        const powerUpTypes = ["health", "tripleShot", "missileBarrage"];
        let weightMap;
        
        if (currentDifficulty === DIFFICULTY.INFINITY) {
          weightMap = {"health": 0.5, "tripleShot": 0.3, "missileBarrage": 0.2};
        } else {
          weightMap = {"health": 0.7, "tripleShot": 0.3, "missileBarrage": 0};
        }
        
        // Filter out types that already exist as power-ups
        const availableTypes = powerUpTypes.filter(type => !powerUpTypeExists(type));
        
        // If all types exist, default to health
        let type = "health";
        
        if (availableTypes.length > 0) {
          // Recalculate total weight and choose from available types
          let totalWeight = 0;
          for (const t of availableTypes) {
            totalWeight += weightMap[t];
          }
          
          const random = Math.random() * totalWeight;
          let cumulativeWeight = 0;
          
          for (const t of availableTypes) {
            cumulativeWeight += weightMap[t];
            if (random < cumulativeWeight) {
              type = t;
              break;
            }
          }
        }
        
        return {
          x: loc.x,
          y: loc.y,
          vx: randomRange(-40, 40),
          vy: randomRange(-40, 40),
          lifetime: 10,
          radius: POWERUP_RADIUS,
          type: type
        };
      }
      
      function spawnTripleShotPowerUp() {
        let loc = getPowerUpSpawnLocation(); // Use the central spawn location
        return {
          x: loc.x,
          y: loc.y,
          vx: randomRange(-40, 40), // Slightly slower movement
          vy: randomRange(-40, 40),
          lifetime: TRIPLE_SHOT_DURATION, // Power-up exists for 20 seconds before disappearing
          radius: POWERUP_RADIUS,
          type: "tripleShot",
          enhanced: currentDifficulty === DIFFICULTY.INFINITY && infinityModeSpawnMultiplier >= 1.5
        };
      }
      
      // Function to spawn a missile barrage power-up (Infinity mode only)
      function spawnMissileBarragePowerUp() {
        let loc = getPowerUpSpawnLocation(); // Use the central spawn location
        return {
          x: loc.x,
          y: loc.y,
          vx: randomRange(-40, 40), // Slightly slower movement
          vy: randomRange(-40, 40),
          lifetime: 15, // Power-up exists for 15 seconds before disappearing
          radius: POWERUP_RADIUS,
          type: "missileBarrage"
        };
      }
      
      // Function to start missile barrage
      function startMissileBarrage() {
        spaceship.missileBarrageActive = true;
        spaceship.missileBarrageTimer = MISSILE_BARRAGE_DURATION;
        lastMissileSpawnTime = 0;
        
        // Play power-up activation sound
        if (soundEnabled) {
          powerUpSound.volume = 0.4;
          powerUpSound.play().catch(err => console.error("Error playing powerup sound:", err));
        }
      }
      
      // Function to update missile barrage logic
      function updateMissileBarrage(dt) {
        if (!spaceship.missileBarrageActive) return;
        
        // Update missile barrage timer
        spaceship.missileBarrageTimer -= dt;
        lastMissileSpawnTime += dt;
        
        // Spawn missiles in 8 directions at set intervals
        if (lastMissileSpawnTime >= MISSILE_SPAWN_FREQUENCY) {
          lastMissileSpawnTime = 0;
          spawnMissileVolley();
        }
        
        // End missile barrage when timer expires
        if (spaceship.missileBarrageTimer <= 0) {
          spaceship.missileBarrageActive = false;
        }
      }
      
      // Function to spawn a volley of missiles in a rotating star pattern
      function spawnMissileVolley() {
        // Update rotation angle for this volley
        missilePatternRotation += (Math.PI / 8); // Rotate pattern by 22.5 degrees each volley
        
        // Create a star pattern with 12 missiles (more missiles than before)
        // 8 missiles in a circle + 4 missiles at 45° angles with different distances
        for (let i = 0; i < 12; i++) {
          // Base angle with current rotation
          let angle;
          let distanceMultiplier;
          
          if (i < 8) {
            // First 8 missiles in a circle (45° intervals)
            angle = missilePatternRotation + (i * Math.PI / 4);
            distanceMultiplier = 1.0;
          } else {
            // Additional 4 missiles at 45° angles with longer range
            angle = missilePatternRotation + ((i - 8) * Math.PI / 2 + Math.PI / 4);
            distanceMultiplier = 1.2; // These missiles go a bit farther out
          }
          
          // Create missile at spaceship position
          bullets.push({
            x: spaceship.x + Math.cos(angle) * spaceship.size * 1.2,
            y: spaceship.y + Math.sin(angle) * spaceship.size * 1.2,
            vx: Math.cos(angle) * MISSILE_SPEED * distanceMultiplier,
            vy: Math.sin(angle) * MISSILE_SPEED * distanceMultiplier,
            radius: 5, // Slightly larger than normal bullets
            isMissile: true,
            creation: gameTime // Track when the missile was created
          });
        }
        
        // Play missile firing sound
        if (soundEnabled) {
          bulletSoundPool[nextBulletSoundIndex].currentTime = 0;
          bulletSoundPool[nextBulletSoundIndex].volume = 0.4; // Louder for missiles
          bulletSoundPool[nextBulletSoundIndex].play();
          nextBulletSoundIndex = (nextBulletSoundIndex + 1) % BULLET_SOUND_POOL_SIZE;
        }
      }

      // Timers
      let lastBulletTime = 0;
      let cometSpawnTimer = 0;

      // Big Comet logic
      function updateBigComets(dt) {
        for (let i = bigComets.length - 1; i >= 0; i--) {
          let bc = bigComets[i];
          
          // Update hit flash timer
          if (bc.hitFlashTimer > 0) {
            bc.hitFlashTimer -= dt;
            if (bc.hitFlashTimer < 0) bc.hitFlashTimer = 0;
          }
          
          // Update shake effect with higher frequency for more damage
          if (bc.shakeTimer > 0) {
            bc.shakeTimer -= dt;
            
            // Adjust frequency based on damage - much higher frequency
            const shakeFrequency = 10 + (bc.hitCount / BIG_COMET_HEALTH) * 50; // Increase from 10 to 60 Hz
            
            // Use sine waves with increasing frequency for more natural vibration
            const time = performance.now() / 1000; // Current time in seconds
            
            // Apply shake with higher frequency but MUCH smaller amplitude as damage increases
            // Cap the maximum shake distance to a small value
            const maxShakeDistance = Math.min(bc.shakeAmount, 8); // Never shake more than 8 pixels
            const dampingFactor = Math.max(0.15, 1 - (bc.hitCount / BIG_COMET_HEALTH)); // More damping
            
            // Use multiple sine waves at different frequencies for more chaotic vibration
            bc.shakeX = (
              Math.sin(time * shakeFrequency) * 0.6 + 
              Math.sin(time * shakeFrequency * 1.3) * 0.4
            ) * maxShakeDistance * dampingFactor;
            bc.shakeY = Math.cos(time * shakeFrequency * 1.3) * maxShakeDistance * dampingFactor * 0.8; // Y-shake is slightly less
            
            // Gradually reduce shake amount
            bc.shakeAmount *= 0.98;
            
            if (bc.shakeTimer <= 0) {
              bc.shakeTimer = 0;
              bc.shakeX = 0;
              bc.shakeY = 0;
            }
          }
          
          // Apply movement with reduced speed based on hit count
          // The more hits, the slower it moves
          const speedFactor = Math.max(0.2, 1 - (bc.hitCount / BIG_COMET_HEALTH) * 0.8);
          bc.x += bc.vx * dt * speedFactor;
          bc.y += bc.vy * dt * speedFactor;
          
          // Remove if out of bounds
          if (bc.x < -bc.radius || bc.x > canvas.width + bc.radius ||
              bc.y < -bc.radius || bc.y > canvas.height + bc.radius) {
            bigComets.splice(i, 1);
          }
          
          // Check if it should explode
          if (bc.hitPoints <= 0) {
            // Create a huge explosion
            createHugeExplosion(bc.x, bc.y);
            
            // Spawn tier 2 comets
            for (let j = 0; j < BIG_COMET_BREAKUP_PIECES; j++) {
              const angle = Math.random() * Math.PI * 2;
              const distance = bc.radius * 0.5 * Math.random();
              const speed = randomRange(COMET_SPEED_MIN, COMET_SPEED_MAX);
              
              spawnComet(
                2, // Tier 2 comets
                bc.x + Math.cos(angle) * distance,
                bc.y + Math.sin(angle) * distance,
                Math.cos(angle) * speed,
                Math.sin(angle) * speed
              );
            }
            
            // Award score
            score += 100;
            
            // Remove the big comet
            bigComets.splice(i, 1);
          }
        }
      }

      function updateTimers(dt) {
        // Big comet spawn timer
        bigCometSpawnTimer += dt;
        if (bigCometSpawnTimer >= BIG_COMET_SPAWN_INTERVAL) {
          for (let i = 0; i < BIG_COMET_SPAWN_MAX; i++) {
            spawnBigComet();
          }
          bigCometSpawnTimer = 0;
        }
        
        // Health bar animation timers
        if (spaceship.healthShakeTimer > 0) {
          spaceship.healthShakeTimer -= dt;
          if (spaceship.healthShakeTimer < 0) spaceship.healthShakeTimer = 0;
        }
        
        if (spaceship.healthScaleTimer > 0) {
          spaceship.healthScaleTimer -= dt;
          if (spaceship.healthScaleTimer < 0) spaceship.healthScaleTimer = 0;
        }
      }

      // INPUT HANDLING
      const keys = {};
      document.addEventListener("keydown", function(e) {
        // Normalize the key for easier comparison
        const key = e.key.toLowerCase();
        const code = e.code;
        
        // If game is loading, ignore key input
        if (gameState === "loading") {
          e.preventDefault();
          return;
        }
        
        // Global music toggle, works in any state
        if (key === "m" || code === "KeyM") {
          // Get the current state before toggling
          const wasMusicEnabled = musicEnabled;
          const wasSoundEnabled = soundEnabled;
          
          // Set both to the same state (both on or both off)
          if (wasMusicEnabled || wasSoundEnabled) {
            // If either was on, turn both off
            musicEnabled = false;
            soundEnabled = false;
            // Apply changes
            bgMusic.pause();
            
            // Mute all sound effects
            powerUpSound.muted = true;
            victorySound.muted = true;
            defeatSound.muted = true;
            
            // Mute sound pools
            for (let sound of bulletSoundPool) {
              sound.muted = true;
            }
            for (let sound of hitSoundPool) {
              sound.muted = true;
            }
          } else {
            // If both were off, turn both on
            musicEnabled = true;
            soundEnabled = true;
            
            // Resume appropriate music
            if (gameState === GAME_STATE.MAIN_MENU || gameState === GAME_STATE.SETTINGS || 
                gameState === GAME_STATE.DIFFICULTY_SELECT || gameState === GAME_STATE.HOW_TO_PLAY || 
                gameState === GAME_STATE.HIGH_SCORES) {
              startMenuMusic();
            } else if (gameState === GAME_STATE.PLAYING) {
              startGameplayMusic();
            }
            
            // Unmute all sound effects
            powerUpSound.muted = false;
            victorySound.muted = false;
            defeatSound.muted = false;
            
            // Unmute sound pools
            for (let sound of bulletSoundPool) {
              sound.muted = false;
            }
            for (let sound of hitSoundPool) {
              sound.muted = false;
            }
          }
          
          // Show feedback
          const statusText = musicEnabled ? "ON" : "OFF";
          addTemporaryMessage(`Sound: ${statusText}`, 1000);
          e.preventDefault();
          return;
        }
        
        // Main branch: handle keys based on the current game state
        switch (gameState) {
          case GAME_STATE.PLAYING:
            // --- Gameplay-specific keys ---
            // Special abilities (F key)
            if (key === "f" || code === "KeyF") {
              // Missile ship special ability
              if (spaceship.type === SHIP_TYPE.MISSILE && 
                  spaceship.missileSpecialCooldown <= 0) {
                // Activate special missile ability
                fireSpecialMissiles();
                // Cooldown is now set inside fireSpecialMissiles()
                e.preventDefault();
                return;
              } 
              // Laser ship special ability
              else if (spaceship.type === SHIP_TYPE.LASER && 
                      !spaceship.laserCooldown && 
                      !spaceship.laserActive) {
                // Activate laser beam
                spaceship.laserActive = true;
                spaceship.laserTimer = 0;
                // Reset laser beam endpoint variables
                spaceship.laserBeamEndX = null;
                spaceship.laserBeamEndY = null;
                
                // Play laser activation sound
                if (soundEnabled) {
                  bulletSoundPool[nextBulletSoundIndex].currentTime = 0;
                  bulletSoundPool[nextBulletSoundIndex].volume = 0.4;
                  bulletSoundPool[nextBulletSoundIndex].play();
                  nextBulletSoundIndex = (nextBulletSoundIndex + 1) % BULLET_SOUND_POOL_SIZE;
                }
                e.preventDefault();
                return;
              }
            }
            
            // Special EMP ability (E key)
            if (key === "e" || code === "KeyE") {
              // Default ship (Nova Striker) special ability
              if (spaceship.type === SHIP_TYPE.DEFAULT && !spaceship.empCooldown) {
                // Activate EMP blast
                activateEMPBlast();
                e.preventDefault();
                return;
              }
            }
            
            // ESC key toggles pause
            if (key === "escape" || code === "Escape") {
              updateGameState(GAME_STATE.PAUSE_MENU);
              pauseMenuSelectedItem = 0; // Reset menu selection
              selectedPauseMenuItem = 0; // Reset selected item for the other menu system
              console.log("Game paused");
              // Keep game music playing but at lower volume
              if (musicEnabled && !bgMusic.paused) {
                bgMusic.volume = 0.05;
              }
              e.preventDefault();
              return;
            }
            break;
            
          case GAME_STATE.PAUSE_MENU:
            // --- In-game Pause Menu ---
            // Allow ESC to resume game
            if (key === "escape" || code === "Escape") {
              updateGameState(GAME_STATE.PLAYING);
              // Restore music volume
              if (musicEnabled && !bgMusic.paused) {
                bgMusic.volume = 0.1;
              }
              console.log("Game resumed");
              e.preventDefault();
              return;
            }
            
            // Navigation keys for pause menu
            if (key === "arrowup" || code === "ArrowUp") {
              // Use whichever menu system is active in the game
              pauseMenuSelectedItem = Math.max(0, pauseMenuSelectedItem - 1);
              selectedPauseMenuItem = (selectedPauseMenuItem - 1 + 4) % 4;
              e.preventDefault();
              return;
            }
            
            if (key === "arrowdown" || code === "ArrowDown") {
              // Use whichever menu system is active in the game
              pauseMenuSelectedItem = Math.min(2, pauseMenuSelectedItem + 1);
              selectedPauseMenuItem = (selectedPauseMenuItem + 1) % 4;
              e.preventDefault();
              return;
            }
            
            // Enter key: select pause menu option
            if (key === "enter" || code === "Enter") {
              // Handle pause menu selection (there seem to be two different menu systems)
              // First, try the pauseMenuSelectedItem system
              switch (pauseMenuSelectedItem) {
                case 0: // Resume
                  updateGameState(GAME_STATE.PLAYING);
                  // Restore music volume
                  if (musicEnabled && !bgMusic.paused) {
                    bgMusic.volume = 0.1;
                  }
                  break;
                case 1: // Restart
                  resetGameState();
                  updateGameState(GAME_STATE.PLAYING);
                  break;
                case 2: // Main Menu
                  restartGame();
                  break;
              }
              
              // Also handle the selectedPauseMenuItem system if it's used
              switch(selectedPauseMenuItem) {
                case 0: // Resume Game
                  updateGameState(GAME_STATE.PLAYING);
                  // Restore music volume
                  if (musicEnabled && !bgMusic.paused) {
                    bgMusic.volume = 0.1;
                  }
                  break;
                case 1: // Settings
                  previousGameState = GAME_STATE.PAUSE_MENU; // Remember we came from pause menu
                  gameState = GAME_STATE.SETTINGS;
                  break;
                case 2: // How to Play
                  previousGameState = GAME_STATE.PAUSE_MENU; // Remember we came from pause menu
                  gameState = GAME_STATE.HOW_TO_PLAY;
                  break;
                case 3: // Exit to Main Menu
                  // Confirm exit dialog
                  if (confirm("Are you sure you want to exit? Your progress will be lost.")) {
                    // Reset the game state manually
                    
                    // Clear all game objects
                    bullets = [];
                    sparks = [];
                    comets = [];
                    bigComets = [];
                    smallExplosionParticles = [];
                    powerUps = [];
                    
                    // Reset spaceship
                    spaceship.x = canvas.width / 2;
                    spaceship.y = canvas.height / 2;
                    spaceship.vx = 0;
                    spaceship.vy = 0;
                    spaceship.angle = 0;
                    spaceship.hitPoints = 5;
                    spaceship.tripleShot = false;
                    
                    // Reset game parameters
                    // Keep the score for display on main menu
                    // score = 0; 
                    gameTime = 0;
                    winTriggered = false;
                    
                    // Keep the current difficulty selection
                    // currentDifficulty = DIFFICULTY.MEDIUM;
                    
                    // Reset menu positions but keep difficulty selection
                    selectedMainMenuItem = 0;
                    // Keep the selected difficulty item
                    // selectedDifficultyItem = 1;
                    selectedPauseMenuItem = 0;
                    selectedSettingsItem = 0;
                    
                    // Set game state directly to main menu (not difficulty select)
                    previousGameState = null;
                    updateGameState(GAME_STATE.MAIN_MENU);
                    
                    // Start menu music
                    startMenuMusic();
                  } else {
                    // If canceled, stay in pause menu
                    updateGameState(GAME_STATE.PAUSE_MENU);
                  }
                  break;
              }
              e.preventDefault();
              return;
            }
            break;
            
          case GAME_STATE.MAIN_MENU:
            // Handle main menu navigation
            if (key === "arrowup" || code === "ArrowUp") {
              selectedMainMenuItem = (selectedMainMenuItem - 1 + 4) % 4;
              startMenuMusic();
              e.preventDefault();
              return;
            }
            
            if (key === "arrowdown" || code === "ArrowDown") {
              selectedMainMenuItem = (selectedMainMenuItem + 1) % 4;
              startMenuMusic();
              e.preventDefault();
              return;
            }
            
            if (key === "enter" || code === "Enter") {
              switch(selectedMainMenuItem) {
                case 0: // Play Game
                  updateGameState(GAME_STATE.DIFFICULTY_SELECT);
                  break;
                case 1: // Settings
                  updateGameState(GAME_STATE.SETTINGS);
                  break;
                case 2: // How to Play
                  updateGameState(GAME_STATE.HOW_TO_PLAY);
                  break;
                case 3: // High Scores
                  updateGameState(GAME_STATE.HIGH_SCORES);
                  // Refresh high scores when entering the scoreboard
                  loadHighScores();
                  break;
              }
              e.preventDefault();
              return;
            }
            break;
            
          case GAME_STATE.DIFFICULTY_SELECT:
            // Handle difficulty menu navigation
            if (key === "arrowup" || code === "ArrowUp") {
              selectedDifficultyItem = (selectedDifficultyItem - 1 + 4) % 4;
              // Update the current difficulty based on selection
              switch(selectedDifficultyItem) {
                case 0: currentDifficulty = DIFFICULTY.EASY; break;
                case 1: currentDifficulty = DIFFICULTY.MEDIUM; break;
                case 2: currentDifficulty = DIFFICULTY.HARD; break;
                case 3: currentDifficulty = DIFFICULTY.INFINITY; break;
              }
              e.preventDefault();
              return;
            }
            
            if (key === "arrowdown" || code === "ArrowDown") {
              selectedDifficultyItem = (selectedDifficultyItem + 1) % 4;
              // Update the current difficulty based on selection
              switch(selectedDifficultyItem) {
                case 0: currentDifficulty = DIFFICULTY.EASY; break;
                case 1: currentDifficulty = DIFFICULTY.MEDIUM; break;
                case 2: currentDifficulty = DIFFICULTY.HARD; break;
                case 3: currentDifficulty = DIFFICULTY.INFINITY; break;
              }
              e.preventDefault();
              return;
            }
            
            if (key === "enter" || code === "Enter") {
              // Go to ship selection screen
              updateGameState(GAME_STATE.SHIP_SELECT);
              // Reset to first ship in the selection
              selectedShipMenuItem = 0;
              e.preventDefault();
              return;
            }
            
            if (key === "escape" || code === "Escape") {
              // Back to main menu
              gameState = GAME_STATE.MAIN_MENU;
              e.preventDefault();
              return;
            }
            break;

          case GAME_STATE.SHIP_SELECT:
            // Handle ship selection navigation
            if (key === "arrowleft" || code === "ArrowLeft") {
              // Navigate left in ship selection
              selectedShipMenuItem = (selectedShipMenuItem - 1 + 3) % 3;
              e.preventDefault();
              return;
            }
            
            if (key === "arrowright" || code === "ArrowRight") {
              // Navigate right in ship selection
              selectedShipMenuItem = (selectedShipMenuItem + 1) % 3;
              e.preventDefault();
              return;
            }
            
            if (key === "enter" || code === "Enter") {
              // Set the selected ship type
              switch(selectedShipMenuItem) {
                case 0: selectedShipType = SHIP_TYPE.DEFAULT; break;
                case 1: selectedShipType = SHIP_TYPE.LASER; break;
                case 2: selectedShipType = SHIP_TYPE.MISSILE; break;
              }
              
              // Start the game
              updateGameState(GAME_STATE.PLAYING);
              score = 0;
              gameTime = 0;
              winTriggered = false;
              
              // Reset infinity mode time and multiplier
              infinityModeTime = 0;
              infinityModeSpawnMultiplier = 1.0;
              
              // Initialize ship based on selected type
              initializeShip(selectedShipType);
              
              startGameplayMusic();
              e.preventDefault();
              return;
            }
            
            if (key === "escape" || code === "Escape") {
              // Back to difficulty selection
              updateGameState(GAME_STATE.DIFFICULTY_SELECT);
              e.preventDefault();
              return;
            }
            break;
            
          case GAME_STATE.SETTINGS:
            // Handle settings menu navigation
            if (key === "arrowup" || code === "ArrowUp") {
              // Navigate up in settings menu
              selectedSettingsItem = (selectedSettingsItem - 1 + 2) % 2;
              e.preventDefault();
              return;
            }
            
            if (key === "arrowdown" || code === "ArrowDown") {
              // Navigate down in settings menu
              selectedSettingsItem = (selectedSettingsItem + 1) % 2;
              e.preventDefault();
              return;
            }
            
            if (key === "enter" || code === "Enter") {
              // Toggle the selected setting
              if (selectedSettingsItem === 0) {
                // Toggle music
                toggleMusic();
              } else if (selectedSettingsItem === 1) {
                // Toggle sound effects
                toggleAllSounds();
              }
              
              // Stop sound from affecting infinity mode multiplier
              // Reset to default values if we accidentally started changing them
              if (currentDifficulty === DIFFICULTY.INFINITY) {
                // Only reset if we're in settings and not actively playing
                if (gameState !== GAME_STATE.PLAYING) {
                  infinityModeSpawnMultiplier = 1.0;
                }
              }
              e.preventDefault();
              return;
            }
            
            if (key === "escape" || code === "Escape") {
              // Return to previous screen (either game or main menu)
              if (previousGameState === GAME_STATE.PAUSE_MENU) {
                // Return to game if we came from pause menu
                updateGameState(GAME_STATE.PLAYING);
                // Restore gameplay music and volume
                if (musicEnabled) {
                  // First check if we need to change the track
                  if (currentMusicTrack !== "gameplay") {
                    startGameplayMusic();
                  } else {
                    // Just restore volume if track is already correct
                    bgMusic.volume = 0.1;
                  }
                }
              } else {
                // Return to main menu if we came from there
                gameState = previousGameState || GAME_STATE.MAIN_MENU;
                // Ensure menu music is playing if returning to main menu
                if (musicEnabled && (previousGameState === GAME_STATE.MAIN_MENU || !previousGameState)) {
                  if (currentMusicTrack !== "menu") {
                    startMenuMusic();
                  }
                }
              }
              e.preventDefault();
              return;
            }
            break;
            
          case GAME_STATE.HOW_TO_PLAY:
          case GAME_STATE.HIGH_SCORES:
            // ESC to go back from these screens
            if (key === "escape" || code === "Escape" || key === "b" || code === "KeyB") {
              console.log("ESC or B pressed in high scores or how to play screen");
              if (previousGameState) {
                gameState = previousGameState;
                previousGameState = null;
              } else {
                gameState = GAME_STATE.MAIN_MENU;
                updateGameState(GAME_STATE.MAIN_MENU);
                startMenuMusic();
              }
              e.preventDefault();
              return;
            }
            break;
            
          case GAME_STATE.GAME_OVER:
          case GAME_STATE.WIN:
            // Any key to return to main menu
            if (key === "enter" || code === "Enter" || key === "escape" || code === "Escape") {
              // Stop any sounds before restarting
              victorySound.pause();
              victorySound.currentTime = 0;
              defeatSound.pause();
              defeatSound.currentTime = 0;
              
              restartGame();
              gameState = GAME_STATE.MAIN_MENU;
              startMenuMusic();
              e.preventDefault();
              return;
            }
            break;
            
          default:
            break;
        }
        
        // Store key state for movement handling
        keys[e.key] = true;
        e.preventDefault();
      });
      document.addEventListener("keyup", (e) => {
        keys[e.key] = false;
        e.preventDefault();
      });


      let touchStartX = null, touchStartY = null;
      canvas.addEventListener("touchstart", function (e) {
        e.preventDefault();
        let touch = e.touches[0];
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
      }, false);
      canvas.addEventListener("touchmove", function (e) {
        e.preventDefault();
        let touch = e.touches[0];
        let deltaX = touch.clientX - touchStartX;
        let deltaY = touch.clientY - touchStartY;
        if (deltaX > 20) {
          keys["ArrowRight"] = true;
          keys["ArrowLeft"] = false;
        } else if (deltaX < -20) {
          keys["ArrowLeft"] = true;
          keys["ArrowRight"] = false;
        } else {
          keys["ArrowLeft"] = false;
          keys["ArrowRight"] = false;
        }
        if (deltaY < -20) {
          keys["ArrowUp"] = true;
          keys["ArrowDown"] = false;
        } else if (deltaY > 20) {
          keys["ArrowDown"] = true;
          keys["ArrowUp"] = false;
        } else {
          keys["ArrowUp"] = false;
          keys["ArrowDown"] = false;
        }
      }, false);
      canvas.addEventListener("touchend", function (e) {
        e.preventDefault();
        keys["ArrowUp"] = false;
        keys["ArrowDown"] = false;
        keys["ArrowLeft"] = false;
        keys["ArrowRight"] = false;
        touchStartX = null;
        touchStartY = null;
      }, false);
      
      // Simplified click handler - temporarily disabled
      canvas.addEventListener("click", function(e) {
        // No button handlers for now - just log clicks in high score screen
        if (gameState === GAME_STATE.HIGH_SCORES) {
          console.log("High score screen clicked at:", e.clientX, e.clientY);
        }
      });

      // Utility
      function randomRange(min, max) {
        return Math.random() * (max - min) + min;
      }
      function randomColor() {


        const hue = Math.floor(Math.random() * 360);
        return "hsl(" + hue + ", 70%, 30%)";
      }
      function bounce(obj, radius, damping = 1) {
        if (obj.x - radius < 0) {
          obj.x = radius;
          obj.vx = -obj.vx * damping;
        }
        if (obj.x + radius > canvas.width) {
          obj.x = canvas.width - radius;
          obj.vx = -obj.vx * damping;
        }
        if (obj.y - radius < 0) {
          obj.y = radius;
          obj.vy = -obj.vy * damping;
        }
        if (obj.y + radius > canvas.height) {
          obj.y = canvas.height - radius;
          obj.vy = -obj.vy * damping;
        }
      }
      function roundRect(ctx, x, y, width, height, radius) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      }

      // 1) Generate Comet Shape with freq/phase:
      function generateCometShape(segments) {
        let shape = [];
        for (let i = 0; i < segments; i++) {
          let angle = i * 2 * Math.PI / segments;
          // Make comets more round by reducing the factor variation (0.6 -> 0.3)
          let factor = 1 + (Math.random() * 0.3 - 0.15);
          // Increase frequency to make them rotate faster (multiply by 2)
          let frequency = (Math.random() * 2 + 1) * 2; // ~2..6
          let phase = Math.random() * 2 * Math.PI;
          shape.push({ angle, factor, frequency, phase });
        }
        return shape;
      }


      function randomRockColor() {
        const colors = [
          "#4B4B4B", // Dark gray
       
        ];
        return colors[Math.floor(Math.random() * colors.length)];
      }



      // 2) Spawn Comet with optional morph
      function spawnComet(tier = MAX_COMET_TIER, x, y, vx, vy) {
        if (x === undefined || y === undefined) {
          let loc = getSpawnLocation();
          x = loc.x;
          y = loc.y;
        }
        if (vx === undefined || vy === undefined) {
          const angle = Math.random() * Math.PI * 2;
          const speed = randomRange(COMET_SPEED_MIN, COMET_SPEED_MAX);
          vx = Math.cos(angle) * speed;
          vy = Math.sin(angle) * speed;
        }
        const radius = BASE_COMET_RADIUS * Math.pow(0.6, MAX_COMET_TIER - tier);
        let hp;
        if (tier === 3) hp = 5;
        else if (tier === 2) hp = 4;
        else hp = 3;

        // Add more segments to make comets rounder (8 -> 12)
        const segments = 12;
        
        const comet = {
          x, y, vx, vy,
          radius,
          tier,
          color: randomRockColor(),
          hitPoints: hp,
          hitEffectTimer: 0,
          slowEffectTimer: 0,
          indestructableTimer: 0,
          oldVX: vx,
          oldVY: vy,
          trail: [],
          trailTimer: 0,
          shape: generateCometShape(segments),
          pattern: generateStonePattern(),
          morph: true,
          // Add rotation speed
          rotationSpeed: randomRange(1, 3)
        };
        comets.push(comet);
      }

      // Additional helper for spawn location
      function getQuadrant(x, y) {
        const midX = canvas.width / 2;
        const midY = canvas.height / 2;
        if (x < midX && y < midY) return "top-left";
        if (x >= midX && y < midY) return "top-right";
        if (x < midX && y >= midY) return "bottom-left";
        return "bottom-right";
      }
      function isInSameQuadrant(x1, y1, x2, y2) {
        return getQuadrant(x1, y1) === getQuadrant(x2, y2);
      }
      function getSpawnLocation() {
        let loc, attempt = 0;
        do {
          if (Math.random() < 0.5) {
            loc = { x: randomRange(0, canvas.width), y: 0 };
          } else {
            loc = { x: randomRange(0, canvas.width), y: canvas.height };
          }
          attempt++;
          if (attempt > 10) break;
        } while (isInSameQuadrant(loc.x, loc.y, spaceship.x, spaceship.y));
        return loc;
      }
      
      // Special function for power-up spawn locations closer to the middle
      function getPowerUpSpawnLocation() {
        // Define central area of the screen (20-80% of width and height)
        const minX = canvas.width * 0.2;
        const maxX = canvas.width * 0.8;
        const minY = canvas.height * 0.2;
        const maxY = canvas.height * 0.8;
        
        // Calculate a random position within this area
        const x = randomRange(minX, maxX);
        const y = randomRange(minY, maxY);
        
        // Make sure it's not too close to the player's ship
        const minDistanceFromShip = SHIP_SIZE * 5; // Keep some distance from ship
        const dx = x - spaceship.x;
        const dy = y - spaceship.y;
        const distanceFromShip = Math.sqrt(dx*dx + dy*dy);
        
        // If too close to ship, try again with a different position
        if (distanceFromShip < minDistanceFromShip) {
          return getPowerUpSpawnLocation(); // Recursively try again
        }
        
        return { x, y };
      }
      
      // Create bullet impact effect when bullets hit comets
      function createBulletImpact(x, y, scale = 1, color = null) {
        const count = 8 * scale; // Fewer particles than a small explosion, scaled based on parameter
        for (let i = 0; i < count; i++) {
          let angle = Math.random() * Math.PI * 2;
          let speed = randomRange(30, 100) * scale; // Lower speed than explosion, scaled
          
          // Allow custom color or use default colors
          let particleColor;
          if (color) {
            particleColor = color;
          } else {
            particleColor = randomRange(0, 1) > 0.5 ? "orange" : "yellow"; // Mix of colors
          }
          
          smallExplosionParticles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            lifetime: randomRange(0.1, 0.3) * scale, // Shorter lifetime, scaled
            size: randomRange(1, 3) * scale, // Smaller particles, scaled
            color: particleColor
          });
        }
      }

      // -------------- PLACEHOLDERS FILLED BELOW -------------- //

      // Explosion Effects
      function createSmallExplosion(x, y) {
        if (soundEnabled) {
          let exp = new Audio(explosionSoundURL);
          exp.volume = 0.125;
          exp.play().catch(err => console.error("Explosion play error:", err));
        }
        const count = 10;
        for (let i = 0; i < count; i++) {
          let angle = Math.random() * Math.PI * 2;
          let speed = randomRange(50, 150);
          smallExplosionParticles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            lifetime: randomRange(0.3, 0.7),
            size: randomRange(2, 4),
            color: "orange"
          });
        }
      }

      function createHugeExplosion(x, y) {
        if (soundEnabled) {
          let exp = new Audio(explosionSoundURL);
          exp.volume = 1.0;
          exp.play().catch(err => console.error("Huge explosion play error:", err));
        }
        const count = 50;
        for (let i = 0; i < count; i++) {
          let angle = Math.random() * Math.PI * 2;
          let speed = randomRange(100, 300);
          smallExplosionParticles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            lifetime: randomRange(0.8, 1.5),
            size: randomRange(5, 10),
            color: "orange"
          });
        }
      }

      function updateExplosionParticles(dt) {
        for (let i = smallExplosionParticles.length - 1; i >= 0; i--) {
          const p = smallExplosionParticles[i];
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.lifetime -= dt;
          p.size *= 0.98;
          if (p.lifetime <= 0) {
            smallExplosionParticles.splice(i, 1);
          }
        }
      }

      function checkCometCollisions() {
        let indicesToRemove = new Set();
        for (let i = 0; i < comets.length; i++) {
          for (let j = i + 1; j < comets.length; j++) {
            let c1 = comets[i];
            let c2 = comets[j];
            let dx = c2.x - c1.x;
            let dy = c2.y - c1.y;
            let dist = Math.hypot(dx, dy);
            let minDist = c1.radius + c2.radius;
            // Colliding
            if (dist < minDist && dist > 0) {
              // If either is < MAX tier, we remove it
              if (c1.tier < MAX_COMET_TIER) {
                indicesToRemove.add(i);
                createSmallExplosion(c1.x, c1.y);
                score += 5;
              }
              if (c2.tier < MAX_COMET_TIER) {
                indicesToRemove.add(j);
                createSmallExplosion(c2.x, c2.y);
                score += 5;
              }
              // If both are MAX tier, bounce
              if (c1.tier === MAX_COMET_TIER && c2.tier === MAX_COMET_TIER) {
                let nx = dx / dist;
                let ny = dy / dist;
                let dvx = c1.vx - c2.vx;
                let dvy = c1.vy - c2.vy;
                let dot = dvx * nx + dvy * ny;
                if (dot <= 0) {
                  let impulse = dot;
                  c1.vx -= impulse * nx;
                  c1.vy -= impulse * ny;
                  c2.vx += impulse * nx;
                  c2.vy += impulse * ny;
                  let overlap = minDist - dist;
                  c1.x -= nx * overlap / 2;
                  c1.y -= ny * overlap / 2;
                  c2.x += nx * overlap / 2;
                  c2.y += ny * overlap / 2;
                }
              }
            }
          }
        }
        // Remove comets that were marked
        comets = comets.filter((_, index) => !indicesToRemove.has(index));
      }


      function checkBigCometCollisions() {
        // Big Comets vs. Big Comets
        for (let i = 0; i < bigComets.length; i++) {
          for (let j = i + 1; j < bigComets.length; j++) {
            let bc1 = bigComets[i];
            let bc2 = bigComets[j];
            let dx = bc2.x - bc1.x;
            let dy = bc2.y - bc1.y;
            let dist = Math.hypot(dx, dy);
            let minDist = bc1.radius + bc2.radius;
            if (dist < minDist && dist > 0) {
              let nx = dx / dist;
              let ny = dy / dist;
              let overlap = minDist - dist;
              // Bounce them apart equally
              bc1.x -= nx * (overlap / 2);
              bc1.y -= ny * (overlap / 2);
              bc2.x += nx * (overlap / 2);
              bc2.y += ny * (overlap / 2);
              // Adjust velocities (optional, to simulate a bounce)
              let impulse = (bc1.vx - bc2.vx) * nx + (bc1.vy - bc2.vy) * ny;
              if (impulse < 0) {
                bc1.vx -= impulse * nx;
                bc1.vy -= impulse * ny;
                bc2.vx += impulse * nx;
                bc2.vy += impulse * ny;
              }
            }
          }
        }

        // Big Comets vs. Normal Comets
        for (let i = 0; i < bigComets.length; i++) {
          for (let j = 0; j < comets.length; j++) {
            let bc = bigComets[i];
            let c = comets[j];
            let dx = c.x - bc.x;
            let dy = c.y - bc.y;
            let dist = Math.hypot(dx, dy);
            let minDist = bc.radius + c.radius;
            if (dist < minDist && dist > 0) {
              let nx = dx / dist;
              let ny = dy / dist;
              let overlap = minDist - dist;
              // Adjust positions so they bounce apart
              c.x += nx * (overlap / 2);
              c.y += ny * (overlap / 2);
              bc.x -= nx * (overlap / 2);
              bc.y -= ny * (overlap / 2);
              // Bounce the normal comet more strongly (big comets remain mostly unaffected)
              c.vx = -c.vx * 0.5;
              c.vy = -c.vy * 0.5;
            }
          }
        }
      }


      // Initialize ship based on selected type
      function initializeShip(shipType) {
        // Reset basic properties
        spaceship.x = canvas.width / 2;
        spaceship.y = canvas.height / 2;
        spaceship.vx = 0;
        spaceship.vy = 0;
        spaceship.angle = 0;
        spaceship.hitPoints = 5; // Default hitpoints
        spaceship.hitFlashTimer = 0;
        spaceship.tripleShot = false;
        spaceship.tripleShotTimer = 0;
        spaceship.missileBarrageActive = false;
        spaceship.missileBarrageTimer = 0;
        
        // Set ship type
        spaceship.type = shipType;
        
        // Reset type-specific properties
        spaceship.laserActive = false;
        spaceship.laserTimer = 0;
        spaceship.laserCooldown = false;
        spaceship.laserCooldownTimer = 0;
        spaceship.missileSpecialCooldown = 0;
        
        // Reset shield properties
        spaceship.hasShield = false;
        spaceship.shieldHealth = 0;
        spaceship.shieldRechargeTimer = 0;
        spaceship.shieldFlashTimer = 0;
        spaceship.frontArcOnly = false;
        
        // Apply ship type-specific modifications
        switch(shipType) {
          case SHIP_TYPE.DEFAULT:
            // Default balanced ship
            spaceship.size = SHIP_SIZE;
            spaceship.speedModifier = 1.0;
            spaceship.hitPoints = 5; // Standard health
            // Default ship has no shield
            
            // EMP weapon properties
            spaceship.empActive = false;
            spaceship.empCooldown = false;
            spaceship.empCooldownTimer = 0;
            spaceship.empEffectTimer = 0;
            spaceship.empWaveRadius = 0;
            break;
            
          case SHIP_TYPE.LASER:
            // Bulkier, slower ship with laser beam and shield
            spaceship.size = SHIP_SIZE * 1.83; // Original size
            spaceship.speedModifier = 0.7; // Slower but powerful
            spaceship.hitPoints = 7; // Increased health (40% more)
            
            // Heavy cruiser has frontal shield
            spaceship.hasShield = true;
            spaceship.shieldHealth = 3; // Shield can absorb 3 full hits
            spaceship.frontArcOnly = true; // Shield only covers the front
            break;
            
          case SHIP_TYPE.MISSILE:
            // Futuristic, agile ship with special missiles
            spaceship.size = SHIP_SIZE * 0.85;
            spaceship.speedModifier = 1.1; // Faster
            spaceship.hitPoints = 5; // Now equal to the standard fighter
            break;
        }
      }
      
      // Store the state of sequential missile firing
      const missileSequenceState = {
        isActive: false,
        currentMissile: 0,
        totalMissiles: 7,
        lastFiredTime: 0,
        missileDelay: 0.1 // 0.1 seconds between each missile
      };
      
      // Fire special missiles (for MISSILE type ship)
      function fireSpecialMissiles() {
        if (spaceship.type !== SHIP_TYPE.MISSILE) return;
        
        // If a sequence is not active, start one
        if (!missileSequenceState.isActive) {
          missileSequenceState.isActive = true;
          missileSequenceState.currentMissile = 0;
          missileSequenceState.lastFiredTime = gameTime;
          
          // Start the sequence by firing the first missile
          fireNextMissileInSequence();
          
          // Set cooldown - but don't disable firing yet since we're in a sequence
          spaceship.missileSpecialCooldown = 1;
        }
      }
      
      // Function to fire the next missile in the 7-missile sequence
      function fireNextMissileInSequence() {
        // Play missile firing sound
        if (soundEnabled) {
          bulletSoundPool[nextBulletSoundIndex].currentTime = 0;
          bulletSoundPool[nextBulletSoundIndex].volume = 0.5; // Louder for super missiles
          bulletSoundPool[nextBulletSoundIndex].play();
          nextBulletSoundIndex = (nextBulletSoundIndex + 1) % BULLET_SOUND_POOL_SIZE;
        }
        
        // Determine angle offset based on which missile in the sequence
        let angleOffset = 0;
        
        if (missileSequenceState.currentMissile === 0) {
          // First missile - center (no offset)
          angleOffset = 0;
        } else if (missileSequenceState.currentMissile === 1) {
          // Second missile - left side
          angleOffset = -Math.PI / 24; // 7.5 degrees to the left
        } else {
          // Third missile - right side
          angleOffset = Math.PI / 24; // 7.5 degrees to the right
        }
        
        // Calculate missile position with the same start point
        const missileX = spaceship.x + Math.cos(spaceship.angle) * spaceship.size * 0.9;
        const missileY = spaceship.y + Math.sin(spaceship.angle) * spaceship.size * 0.9;
        
        // Calculate missile angle with offset
        const missileAngle = spaceship.angle + angleOffset;
        
        // Create a more powerful missile (20x regular bullet)
        bullets.push({
          x: missileX,
          y: missileY,
          vx: Math.cos(missileAngle) * MISSILE_SPEED * 1.2, // 20% faster
          vy: Math.sin(missileAngle) * MISSILE_SPEED * 1.2,
          radius: 8, // Larger than regular missiles
          isMissile: true,
          isPowerfulMissile: true, // Flag for increased damage
          missilePower: 20, // 20x regular bullet damage
          creation: gameTime, // Track when the missile was created
          sequenceNumber: missileSequenceState.currentMissile // Track which missile in sequence (for color variation)
        });
        
        // Increment to the next missile
        missileSequenceState.currentMissile++;
        missileSequenceState.lastFiredTime = gameTime;
        
        // If we've fired all missiles, end the sequence
        if (missileSequenceState.currentMissile >= missileSequenceState.totalMissiles) {
          missileSequenceState.isActive = false;
        }
      }
      
      // Activate EMP blast (for DEFAULT ship type - Nova Striker)
      function activateEMPBlast() {
        if (spaceship.type !== SHIP_TYPE.DEFAULT) return;
        
        // Add stricter cooldown check
        if (spaceship.empActive || spaceship.empCooldown) {
          console.log("EMP is active or in cooldown");
          return;
        }
        
        // Play EMP activation sound
        if (soundEnabled) {
          // Use an existing sound for now
          bulletSoundPool[nextBulletSoundIndex].currentTime = 0;
          bulletSoundPool[nextBulletSoundIndex].volume = 0.7;
          bulletSoundPool[nextBulletSoundIndex].play();
          nextBulletSoundIndex = (nextBulletSoundIndex + 1) % bulletSoundPool.length;
        }
        
        // Set EMP active state
        spaceship.empActive = true;
        spaceship.empEffectTimer = 0;
        spaceship.empWaveRadius = 0;
        console.log("EMP activated");
      }

      function restartGame() {
        // Go directly to main menu, not difficulty select
        gameState = GAME_STATE.MAIN_MENU;
        startMenuMusic();
        
        // Reload high scores from Firebase
        loadHighScores();
        
        // Keep the difficulty selected for next game
        // but reset infinity mode parameters
        infinityModeTime = 0;
        infinityModeSpawnMultiplier = 1.0;
        
        // Reset spaceship
        initializeShip(spaceship.type);
        
        // Nothing to reset now that missile barrage is a pickup
        
        // Clear all game objects
        bullets = [];
        sparks = [];
        comets = [];
        bigComets = [];
        smallExplosionParticles = [];
        
        // Reset timers
        lastBulletTime = 0;
        cometSpawnTimer = 0;
        bigCometSpawnTimer = 0;
        powerUps = [];
        powerUpSpawnTimer = 0;
        tripleShootPowerUpTimer = 0;
        tripleShootPowerUpSpawned = false;
        
        // Score and game state
        // Don't reset score so player can see their previous score
        gameTime = 0;
        winTriggered = false;
        
        // Reset any navigation state
        previousGameState = null;
        
        // Spawn an initial comet for menu background
        spawnComet();
        initStarfield();
      }

      // Spaceship
      // Draw EMP wave if active
      function drawEMPWave() {
        if (!spaceship.empActive) return;
        
        ctx.save();
        
        // Calculate fade based on expansion progress (more transparent as it grows)
        const progressFactor = Math.min(1, spaceship.empWaveRadius / 500);
        const alphaBase = 0.8 - progressFactor * 0.7; // Fade from 0.8 to 0.1 as it expands
        
        // Adjust opacity based on time and radius 
        ctx.globalAlpha = alphaBase - (spaceship.empEffectTimer / 6.0) * 0.3; // Additional fade over time
        
        // Draw only the ring, not the filled circle
        const ringWidth = 15 - progressFactor * 10; // Ring gets thinner as it expands
        
        // Create a subtle glow for the ring
        ctx.shadowBlur = 10 - progressFactor * 8;
        ctx.shadowColor = 'rgba(100, 180, 255, 0.6)';
        
        // Draw the wave as just a ring instead of a filled circle
        ctx.strokeStyle = 'rgba(140, 200, 255, ' + alphaBase + ')';
        ctx.lineWidth = ringWidth;
        ctx.beginPath();
        ctx.arc(spaceship.x, spaceship.y, spaceship.empWaveRadius, 0, Math.PI * 2);
        ctx.stroke();
        
        ctx.restore();
      }
      
      function drawSpaceship() {
        // Draw EMP wave if active
        if (spaceship.type === SHIP_TYPE.DEFAULT && spaceship.empActive) {
          drawEMPWave();
        }
        
        ctx.save();
        ctx.translate(spaceship.x, spaceship.y);
        ctx.rotate(spaceship.angle);
        ctx.shadowBlur = 20;
        ctx.shadowColor = "cyan";

        let shipFill = "gray";
        if (spaceship.hitFlashTimer > 0) {
          shipFill = "red";
        } else if (spaceship.hitPoints <= 2) {
          shipFill = (Math.floor(gameTime * 10) % 2 === 0) ? "red" : "gray";
        }

        let shipGrad = ctx.createLinearGradient(spaceship.size, 0, -spaceship.size, 0);
        shipGrad.addColorStop(0, shipFill);
        shipGrad.addColorStop(1, "#111");
        
        // Draw ship based on type
        switch(spaceship.type) {
          case SHIP_TYPE.DEFAULT:
            drawDefaultShip(shipGrad);
            break;
          case SHIP_TYPE.LASER:
            drawLaserShip(shipGrad);
            break;
          case SHIP_TYPE.MISSILE:
            drawMissileShip(shipGrad);
            break;
          default:
            drawDefaultShip(shipGrad);
        }
        
        // Draw active laser beam if present
        if (spaceship.type === SHIP_TYPE.LASER && spaceship.laserActive) {
          drawLaserBeam();
        }

        ctx.restore();
      }
      
      // Default balanced ship
      function drawDefaultShip(shipGrad) {
        // Body - original shape
        ctx.beginPath();
        ctx.moveTo(spaceship.size, 0);
        ctx.lineTo(spaceship.size * 0.2, spaceship.size * 0.7);
        ctx.quadraticCurveTo(-spaceship.size * 0.7, spaceship.size * 0.5, -spaceship.size * 0.6, 0);
        ctx.quadraticCurveTo(-spaceship.size * 0.7, -spaceship.size * 0.5, spaceship.size * 0.2, -spaceship.size * 0.7);
        ctx.closePath();
        ctx.fillStyle = shipGrad;
        ctx.fill();
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Add side gun 1 (top)
        ctx.beginPath();
        ctx.moveTo(spaceship.size * 0.5, -spaceship.size * 0.4);
        ctx.lineTo(spaceship.size * 0.9, -spaceship.size * 0.4);
        ctx.lineTo(spaceship.size * 0.9, -spaceship.size * 0.6);
        ctx.lineTo(spaceship.size * 0.5, -spaceship.size * 0.5);
        ctx.closePath();
        ctx.fillStyle = "#555";
        ctx.fill();
        ctx.strokeStyle = "#ccc";
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Add side gun 2 (bottom)
        ctx.beginPath();
        ctx.moveTo(spaceship.size * 0.5, spaceship.size * 0.4);
        ctx.lineTo(spaceship.size * 0.9, spaceship.size * 0.4);
        ctx.lineTo(spaceship.size * 0.9, spaceship.size * 0.6);
        ctx.lineTo(spaceship.size * 0.5, spaceship.size * 0.5);
        ctx.closePath();
        ctx.fillStyle = "#555";
        ctx.fill();
        ctx.strokeStyle = "#ccc";
        ctx.lineWidth = 2;
        ctx.stroke();

        // Flame
        ctx.save();
        ctx.globalAlpha = 0.7;
        let flameLength = spaceship.size * 0.8;
        let flameWidth = spaceship.size * 0.3;
        let flameGrad = ctx.createLinearGradient(-spaceship.size * 0.6, 0, -spaceship.size * 0.6 - flameLength, 0);
        flameGrad.addColorStop(0, "yellow");
        flameGrad.addColorStop(1, "red");
        ctx.fillStyle = flameGrad;
        ctx.beginPath();
        ctx.moveTo(-spaceship.size * 0.6, flameWidth / 2);
        ctx.lineTo(-spaceship.size * 0.6 - flameLength, 0);
        ctx.lineTo(-spaceship.size * 0.6, -flameWidth / 2);
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        // Cockpit
        let cockpitRadius = spaceship.size * 0.3;
        let cockpitGrad = ctx.createRadialGradient(
          spaceship.size * 0.3, 0,
          cockpitRadius * 0.3,
          spaceship.size * 0.3, 0,
          cockpitRadius 
        );
        cockpitGrad.addColorStop(0, "lightblue");
        cockpitGrad.addColorStop(1, "blue");
        ctx.beginPath();
        ctx.arc(spaceship.size * 0.3, 0, cockpitRadius, 0, Math.PI * 2);
        ctx.fillStyle = cockpitGrad;
        ctx.fill();
        ctx.strokeStyle = "white";
        ctx.stroke();
      }
      
      // Bulky laser ship
      function drawLaserShip(shipGrad) {
        // Draw frontal shield first (if active) so ship will appear on top
        if (spaceship.hasShield && spaceship.shieldHealth > 0) {
          drawLaserShipShield();
        }
        
        // Body - more bulky, armored shape
        ctx.beginPath();
        ctx.moveTo(spaceship.size * 0.95, 0); // More pointed front
        ctx.lineTo(spaceship.size * 0.8, spaceship.size * 0.5);
        ctx.lineTo(spaceship.size * 0.4, spaceship.size * 0.7);
        ctx.lineTo(-spaceship.size * 0.45, spaceship.size * 0.6);
        ctx.lineTo(-spaceship.size * 0.75, 0);
        ctx.lineTo(-spaceship.size * 0.45, -spaceship.size * 0.6);
        ctx.lineTo(spaceship.size * 0.4, -spaceship.size * 0.7);
        ctx.lineTo(spaceship.size * 0.8, -spaceship.size * 0.5);
        ctx.closePath();
        
        // Create a more metallic gradient
        const armorGrad = ctx.createLinearGradient(
          -spaceship.size * 0.75, 0,
          spaceship.size * 0.95, 0
        );
        armorGrad.addColorStop(0, "#333355"); // Darker blue-gray
        armorGrad.addColorStop(0.4, "#556688"); // Medium blue-gray
        armorGrad.addColorStop(0.6, "#667799"); // Light blue-gray
        armorGrad.addColorStop(1, "#99AACC"); // Highlight at front
        
        // Fill with gradient
        ctx.fillStyle = armorGrad;
        ctx.fill();
        
        // Add armor plating details
        ctx.strokeStyle = "#AABBDD";
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Add armor panel details
        ctx.beginPath();
        // Top armor panel
        ctx.moveTo(spaceship.size * 0.7, -spaceship.size * 0.2);
        ctx.lineTo(spaceship.size * 0.4, -spaceship.size * 0.4);
        ctx.lineTo(spaceship.size * 0.1, -spaceship.size * 0.4);
        // Bottom armor panel
        ctx.moveTo(spaceship.size * 0.7, spaceship.size * 0.2);
        ctx.lineTo(spaceship.size * 0.4, spaceship.size * 0.4);
        ctx.lineTo(spaceship.size * 0.1, spaceship.size * 0.4);
        // Middle armor lines
        ctx.moveTo(spaceship.size * 0.0, -spaceship.size * 0.2);
        ctx.lineTo(spaceship.size * 0.0, spaceship.size * 0.2);
        ctx.moveTo(-spaceship.size * 0.4, -spaceship.size * 0.3);
        ctx.lineTo(-spaceship.size * 0.4, spaceship.size * 0.3);
        
        ctx.strokeStyle = "rgba(170, 190, 220, 0.6)";
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Enhanced laser cannon (center) - larger and more imposing
        ctx.beginPath();
        ctx.moveTo(spaceship.size * 0.95, -spaceship.size * 0.15);
        ctx.lineTo(spaceship.size * 1.3, -spaceship.size * 0.15);
        ctx.lineTo(spaceship.size * 1.3, spaceship.size * 0.15);
        ctx.lineTo(spaceship.size * 0.95, spaceship.size * 0.15);
        ctx.closePath();
        
        // Cannon gradient
        const cannonGrad = ctx.createLinearGradient(
          spaceship.size * 0.95, 0,
          spaceship.size * 1.3, 0
        );
        cannonGrad.addColorStop(0, "#444");
        cannonGrad.addColorStop(0.6, "#666");
        cannonGrad.addColorStop(1, "#888");
        
        ctx.fillStyle = cannonGrad;
        ctx.fill();
        ctx.strokeStyle = "#aaa";
        ctx.lineWidth = 1.5;
        ctx.stroke();
        
        // Add cooling vents to the cannon
        ctx.beginPath();
        // Top vents
        for (let i = 0; i < 3; i++) {
          const ventX = spaceship.size * (1.0 + i * 0.08);
          ctx.moveTo(ventX, -spaceship.size * 0.1);
          ctx.lineTo(ventX + spaceship.size * 0.05, -spaceship.size * 0.1);
        }
        // Bottom vents
        for (let i = 0; i < 3; i++) {
          const ventX = spaceship.size * (1.0 + i * 0.08);
          ctx.moveTo(ventX, spaceship.size * 0.1);
          ctx.lineTo(ventX + spaceship.size * 0.05, spaceship.size * 0.1);
        }
        ctx.strokeStyle = "#99AACC";
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // Laser cannon glow - more intense when active
        const glowSize = spaceship.laserActive ? spaceship.size * 0.1 : spaceship.size * 0.07;
        const glowX = spaceship.size * 1.2;
        
        // Enhanced glow effect with animation
        const time = performance.now() / 1000;
        let glowOpacity;
        let glowColor;
        
        if (spaceship.laserActive) {
          // Pulsing cyan glow for active laser
          glowOpacity = 0.7 + Math.sin(time * 15) * 0.3;
          glowColor = `rgba(0, 255, 255, ${glowOpacity})`;
        } else if (spaceship.laserCooldown) {
          // Pulsing red for cooldown
          glowOpacity = 0.3 + Math.sin(time * 8) * 0.2;
          glowColor = `rgba(255, 100, 100, ${glowOpacity})`;
        } else {
          // Subtle blue standby mode
          glowOpacity = 0.2 + Math.sin(time * 2) * 0.1;
          glowColor = `rgba(100, 150, 255, ${glowOpacity})`;
        }
        
        // Create radial gradient for better glow effect
        const glowGradient = ctx.createRadialGradient(
          glowX, 0, 0,
          glowX, 0, glowSize
        );
        glowGradient.addColorStop(0, "rgba(255, 255, 255, 0.9)");
        glowGradient.addColorStop(0.5, glowColor);
        glowGradient.addColorStop(1, "rgba(0, 50, 100, 0)");
        
        ctx.beginPath();
        ctx.arc(glowX, 0, glowSize * 1.5, 0, Math.PI * 2);
        ctx.fillStyle = glowGradient;
        ctx.fill();
        
        // Enhanced side thrusters - more armored and powerful
        ctx.beginPath();
        ctx.moveTo(-spaceship.size * 0.75, spaceship.size * 0.35);
        ctx.lineTo(-spaceship.size * 0.95, spaceship.size * 0.25);
        ctx.lineTo(-spaceship.size * 0.95, -spaceship.size * 0.25);
        ctx.lineTo(-spaceship.size * 0.75, -spaceship.size * 0.35);
        ctx.closePath();
        
        // Thruster gradient
        const thrusterGrad = ctx.createLinearGradient(
          -spaceship.size * 0.75, 0,
          -spaceship.size * 0.95, 0
        );
        thrusterGrad.addColorStop(0, "#444");
        thrusterGrad.addColorStop(1, "#222");
        
        ctx.fillStyle = thrusterGrad;
        ctx.fill();
        ctx.strokeStyle = "#888";
        ctx.lineWidth = 1.5;
        ctx.stroke();
        
        // Thruster vents
        ctx.beginPath();
        for (let i = 0; i < 3; i++) {
          const ventY = spaceship.size * (-0.2 + i * 0.2);
          ctx.moveTo(-spaceship.size * 0.85, ventY);
          ctx.lineTo(-spaceship.size * 0.90, ventY);
        }
        ctx.strokeStyle = "#99AACC";
        ctx.stroke();
        
        // Enhanced engine flames - more powerful looking
        ctx.save();
        ctx.globalAlpha = 0.8; // More visible
        let flameLength = spaceship.size * 0.7; // Longer flames
        let flameWidth = spaceship.size * 0.5; // Wider flames
        
        // Animate flame
        const flameTime = performance.now() / 100;
        const flameFlicker = 0.85 + Math.sin(flameTime) * 0.15;
        flameLength *= flameFlicker;
        
        // More vibrant flame gradient
        let flameGrad = ctx.createLinearGradient(-spaceship.size * 0.95, 0, -spaceship.size * 0.95 - flameLength, 0);
        flameGrad.addColorStop(0, "rgba(255, 200, 50, 0.9)");
        flameGrad.addColorStop(0.4, "rgba(255, 120, 30, 0.8)");
        flameGrad.addColorStop(0.8, "rgba(220, 50, 10, 0.6)");
        flameGrad.addColorStop(1, "rgba(180, 20, 0, 0)");
        
        ctx.fillStyle = flameGrad;
        ctx.beginPath();
        ctx.moveTo(-spaceship.size * 0.95, flameWidth / 2);
        
        // Create a more dynamic flame shape with curves
        ctx.quadraticCurveTo(
          -spaceship.size * 0.95 - flameLength * 0.7, flameWidth * 0.2,
          -spaceship.size * 0.95 - flameLength, 0
        );
        
        ctx.quadraticCurveTo(
          -spaceship.size * 0.95 - flameLength * 0.7, -flameWidth * 0.2,
          -spaceship.size * 0.95, -flameWidth / 2
        );
        
        ctx.closePath();
        ctx.fill();
        
        // Add inner core to flame
        const innerFlameGrad = ctx.createLinearGradient(-spaceship.size * 0.95, 0, -spaceship.size * 0.95 - flameLength * 0.6, 0);
        innerFlameGrad.addColorStop(0, "rgba(255, 255, 200, 0.9)");
        innerFlameGrad.addColorStop(0.5, "rgba(255, 200, 50, 0.7)");
        innerFlameGrad.addColorStop(1, "rgba(255, 120, 30, 0)");
        
        ctx.fillStyle = innerFlameGrad;
        ctx.beginPath();
        ctx.moveTo(-spaceship.size * 0.95, flameWidth / 4);
        ctx.quadraticCurveTo(
          -spaceship.size * 0.95 - flameLength * 0.4, flameWidth * 0.1,
          -spaceship.size * 0.95 - flameLength * 0.6, 0
        );
        ctx.quadraticCurveTo(
          -spaceship.size * 0.95 - flameLength * 0.4, -flameWidth * 0.1,
          -spaceship.size * 0.95, -flameWidth / 4
        );
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
        
        // Enhanced cockpit - more armored looking
        let cockpitRadius = spaceship.size * 0.25;
        let cockpitX = spaceship.size * 0.3;
        let cockpitY = 0;
        
        // Armor ring around cockpit
        ctx.beginPath();
        ctx.arc(cockpitX, cockpitY, cockpitRadius + 5, 0, Math.PI * 2);
        ctx.fillStyle = "#445566";
        ctx.fill();
        ctx.strokeStyle = "#99AACC";
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Inner cockpit with upgraded gradient
        let cockpitGrad = ctx.createRadialGradient(
          cockpitX, cockpitY, cockpitRadius * 0.3,
          cockpitX, cockpitY, cockpitRadius 
        );
        cockpitGrad.addColorStop(0, "rgba(180, 230, 255, 0.9)"); // Brighter blue
        cockpitGrad.addColorStop(0.5, "rgba(80, 150, 255, 0.8)"); // Medium blue
        cockpitGrad.addColorStop(1, "rgba(30, 80, 180, 0.7)"); // Dark blue
        
        ctx.beginPath();
        ctx.arc(cockpitX, cockpitY, cockpitRadius, 0, Math.PI * 2);
        ctx.fillStyle = cockpitGrad;
        ctx.fill();
        ctx.strokeStyle = "white";
        ctx.lineWidth = 1.5;
        ctx.stroke();
        
        // Add cockpit details - cross shape
        ctx.beginPath();
        ctx.moveTo(cockpitX - cockpitRadius * 0.7, cockpitY);
        ctx.lineTo(cockpitX + cockpitRadius * 0.7, cockpitY);
        ctx.moveTo(cockpitX, cockpitY - cockpitRadius * 0.7);
        ctx.lineTo(cockpitX, cockpitY + cockpitRadius * 0.7);
        ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
        ctx.lineWidth = 1;
        ctx.stroke();
      }
      
      // Draw shield for laser ship
      function drawLaserShipShield() {
        // Get current time for animation
        const time = performance.now() / 1000;
        
        // Shield pulse effect
        const shieldPulse = 0.7 + Math.sin(time * 3) * 0.3;
        
        // Different appearance based on shield health
        let shieldOpacity;
        let shieldColor;
        let hexColor;
        
        // Make shield flash when recently hit
        if (spaceship.shieldFlashTimer > 0) {
          shieldOpacity = 0.8;
          hexColor = "#FFFFFF";
          shieldColor = `rgba(255, 255, 255, ${shieldOpacity * shieldPulse})`;
        } else {
          // Normal shield state based on health
          const healthRatio = spaceship.shieldHealth / 3;
          
          if (healthRatio > 0.7) {
            // Strong shield - blue
            shieldOpacity = 0.3 + (healthRatio * 0.2);
            hexColor = "#00AAFF";
            shieldColor = `rgba(0, 170, 255, ${shieldOpacity * shieldPulse})`;
          } else if (healthRatio > 0.3) {
            // Medium shield - cyan with some yellow
            shieldOpacity = 0.25 + (healthRatio * 0.15);
            hexColor = "#00FFAA";
            shieldColor = `rgba(0, 255, 170, ${shieldOpacity * shieldPulse})`;
          } else {
            // Weak shield - orange/red
            shieldOpacity = 0.2 + (healthRatio * 0.15);
            hexColor = "#FFAA00";
            shieldColor = `rgba(255, 170, 0, ${shieldOpacity * shieldPulse})`;
          }
        }
        
        ctx.save();
        
        // Define shield arc angle
        const arcRadius = spaceship.size * 1.2;
        const arcWidth = spaceship.size * 0.15;
        
        // Calculate starting and ending angles for frontal arc shield
        const arcStart = -Math.PI / 3; // 60 degrees left of center
        const arcEnd = Math.PI / 3;    // 60 degrees right of center
        
        // Create gradient for shield edge
        const gradient = ctx.createRadialGradient(
          0, 0, arcRadius - arcWidth,
          0, 0, arcRadius + arcWidth
        );
        
        gradient.addColorStop(0, "rgba(0, 0, 0, 0)");
        gradient.addColorStop(0.5, shieldColor);
        gradient.addColorStop(1, "rgba(0, 0, 0, 0)");
        
        // Draw main shield arc
        ctx.beginPath();
        ctx.arc(0, 0, arcRadius, arcStart, arcEnd);
        ctx.lineWidth = arcWidth;
        ctx.strokeStyle = gradient;
        ctx.stroke();
        
        // Add subtle energy ripples along shield
        const rippleCount = 3;
        for (let i = 0; i < rippleCount; i++) {
          // Calculate ripple position along the arc
          const ripplePos = arcStart + ((arcEnd - arcStart) * (i / (rippleCount - 1)));
          const rippleRadius = arcWidth * 0.6;
          
          // Calculate position on the arc
          const x = Math.cos(ripplePos) * arcRadius;
          const y = Math.sin(ripplePos) * arcRadius;
          
          // Draw ripple
          ctx.beginPath();
          ctx.arc(x, y, rippleRadius, 0, Math.PI * 2);
          
          // Create ripple gradient
          const rippleGradient = ctx.createRadialGradient(
            x, y, 0,
            x, y, rippleRadius
          );
          
          rippleGradient.addColorStop(0, `rgba(255, 255, 255, ${shieldOpacity * 1.5 * shieldPulse})`);
          rippleGradient.addColorStop(0.5, shieldColor);
          rippleGradient.addColorStop(1, "rgba(0, 0, 0, 0)");
          
          ctx.fillStyle = rippleGradient;
          ctx.fill();
        }
        
        // Add hexagon pattern to shield
        const hexSize = arcWidth * 0.4;
        const hexSpacing = hexSize * 1.8;
        const hexRows = 2;
        
        ctx.strokeStyle = `rgba(255, 255, 255, ${shieldOpacity * 0.7 * shieldPulse})`;
        ctx.lineWidth = 1;
        
        for (let row = 0; row < hexRows; row++) {
          const rowRadius = arcRadius - arcWidth/2 + (row * hexSpacing);
          const arcLength = rowRadius * (arcEnd - arcStart);
          const hexCount = Math.floor(arcLength / hexSpacing);
          
          for (let i = 0; i < hexCount; i++) {
            const hexAngle = arcStart + ((arcEnd - arcStart) * (i / (hexCount - 1)));
            const x = Math.cos(hexAngle) * rowRadius;
            const y = Math.sin(hexAngle) * rowRadius;
            
            // Draw hexagon
            ctx.beginPath();
            for (let j = 0; j < 6; j++) {
              const angle = (j * Math.PI / 3) + time * 0.2;
              const hx = x + Math.cos(angle) * hexSize;
              const hy = y + Math.sin(angle) * hexSize;
              
              if (j === 0) {
                ctx.moveTo(hx, hy);
              } else {
                ctx.lineTo(hx, hy);
              }
            }
            ctx.closePath();
            ctx.stroke();
          }
        }
        
        ctx.restore();
      }
      
      // Draw laser beam when active
      function drawLaserBeam() {
        // Get the current time for various flicker/trembling effects
        const time = performance.now() / 1000;
        
        // Create multiple flicker frequencies for realistic effect
        const primaryFlicker = Math.sin(time * 25) * 0.15 + 0.85; // Fast primary flicker
        const secondaryFlicker = Math.sin(time * 8) * 0.1 + 0.9; // Slower secondary flicker
        const microFlicker = (Math.sin(time * 120) * 0.05 + 0.95); // Very fast micro-flicker
        
        // Combine all flicker effects
        const flickerEffect = primaryFlicker * secondaryFlicker * microFlicker;
        
        // Create trembling effect for the beam
        const trembleAmount = spaceship.size * 0.05;
        const trembleX = Math.sin(time * 30) * trembleAmount;
        const trembleY = Math.cos(time * 27) * trembleAmount;
        
        // Make beam thicker than before
        const baseBeamWidth = spaceship.size * 0.3; // Doubled from 0.15
        const beamWidth = baseBeamWidth * flickerEffect;
        
        // Get beam endpoint from the collision detection or use default endpoint
        const beamEndX = spaceship.laserBeamEndX || (spaceship.x + Math.cos(spaceship.angle) * 2000);
        const beamEndY = spaceship.laserBeamEndY || (spaceship.y + Math.sin(spaceship.angle) * 2000);
        
        // Calculate beam length dynamically based on end point
        const dx = beamEndX - spaceship.x;
        const dy = beamEndY - spaceship.y;
        const beamLength = Math.sqrt(dx * dx + dy * dy);
        
        // Create beam gradient
        const beamGrad = ctx.createLinearGradient(
          spaceship.size * 1.2, 0,
          spaceship.size * 1.2 + beamLength, 0
        );
        beamGrad.addColorStop(0, "rgba(0, 255, 255, 0.95)");
        beamGrad.addColorStop(0.05, "rgba(230, 255, 255, 0.9)");
        beamGrad.addColorStop(0.2, "rgba(180, 240, 255, 0.8)");
        beamGrad.addColorStop(0.7, "rgba(100, 200, 255, 0.5)");
        beamGrad.addColorStop(1, "rgba(0, 100, 200, 0)");
        
        // Apply trembling to the beam
        ctx.save();
        ctx.translate(trembleX, trembleY);
        
        // Outer glow - thicker and more pronounced
        ctx.beginPath();
        ctx.moveTo(spaceship.size * 1.2, 0);
        ctx.lineTo(spaceship.size * 1.2 + beamLength, beamWidth * 3);
        ctx.lineTo(spaceship.size * 1.2 + beamLength, -beamWidth * 3);
        ctx.closePath();
        ctx.fillStyle = `rgba(0, 150, 255, ${0.3 * flickerEffect})`;
        ctx.fill();
        
        // Main beam with trembling effect
        ctx.beginPath();
        ctx.moveTo(spaceship.size * 1.2, 0);
        ctx.lineTo(spaceship.size * 1.2 + beamLength, beamWidth * 1.5);
        ctx.lineTo(spaceship.size * 1.2 + beamLength, -beamWidth * 1.5);
        ctx.closePath();
        ctx.fillStyle = beamGrad;
        ctx.fill();
        
        // Core of the beam - intense center with slight randomness
        ctx.beginPath();
        ctx.moveTo(spaceship.size * 1.2, 0);
        ctx.lineTo(spaceship.size * 1.2 + beamLength, beamWidth * 0.4 + trembleY * 0.2);
        ctx.lineTo(spaceship.size * 1.2 + beamLength, -beamWidth * 0.4 - trembleY * 0.2);
        ctx.closePath();
        ctx.fillStyle = `rgba(255, 255, 255, ${0.95 * flickerEffect})`;
        ctx.fill();
        
        // Energy particles effect along the beam
        const particleCount = Math.max(5, Math.floor(beamLength / 80)); // Scale particles based on beam length
        for (let i = 0; i < particleCount; i++) {
          // Calculate particle position along beam - limit to actual beam length
          const distanceAlongBeam = (i / particleCount) * Math.min(beamLength, beamLength * 0.95);
          const particleX = spaceship.size * 1.2 + distanceAlongBeam;
          
          // Particle size decreases with distance
          const particleSize = beamWidth * 0.8 * (1 - i/particleCount);
          
          // Randomize particle position with more randomness further from ship
          const particleOffsetFactor = i / particleCount; // Increases with distance
          const particleY = (Math.sin(time * 30 + i * 5) * beamWidth * particleOffsetFactor);
          
          // Draw particle
          ctx.beginPath();
          ctx.arc(particleX, particleY, particleSize * flickerEffect, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(230, 255, 255, ${0.7 * flickerEffect * (1 - particleOffsetFactor)})`;
          ctx.fill();
        }
        
        // Impact flare at beam's endpoint
        if (beamLength < 1900) { // Only draw impact flare if beam is hitting something (not max length)
          const flareSize = beamWidth * 2.5;
          const flareX = spaceship.size * 1.2 + beamLength;
          
          // Flare gradient
          const flareGrad = ctx.createRadialGradient(
            flareX, 0, 0,
            flareX, 0, flareSize
          );
          flareGrad.addColorStop(0, `rgba(255, 255, 255, ${0.9 * flickerEffect})`);
          flareGrad.addColorStop(0.3, `rgba(100, 200, 255, ${0.7 * flickerEffect})`);
          flareGrad.addColorStop(1, `rgba(0, 100, 200, 0)`);
          
          ctx.beginPath();
          ctx.arc(flareX, 0, flareSize, 0, Math.PI * 2);
          ctx.fillStyle = flareGrad;
          ctx.fill();
          
          // Add random spark particles at impact point
          const sparkCount = Math.floor(3 + Math.random() * 3); // 3-5 sparks
          for (let i = 0; i < sparkCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * flareSize * 0.7;
            const sparkX = flareX + Math.cos(angle) * distance;
            const sparkY = Math.sin(angle) * distance;
            const sparkSize = Math.random() * beamWidth * 0.4 + beamWidth * 0.1;
            
            ctx.beginPath();
            ctx.arc(sparkX, sparkY, sparkSize * flickerEffect, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(220, 240, 255, ${0.8 * flickerEffect})`;
            ctx.fill();
          }
        }
        
        ctx.restore();
      }
      
      // Draw EMP effect for the Nova Striker (DEFAULT ship) - Simplified version
      function drawEMPEffect() {
        if (!spaceship.empActive) return;
        
        // Calculate wave radius based on effect timer
        const waveRadius = spaceship.empWaveRadius;
        
        ctx.save();
        
        // Draw simple expanding ring with fixed opacity
        ctx.beginPath();
        ctx.arc(spaceship.x, spaceship.y, waveRadius, 0, Math.PI * 2);
        ctx.strokeStyle = "rgba(0, 180, 255, 0.6)";
        ctx.lineWidth = 4;
        ctx.stroke();
        
        // Draw secondary ring (slightly transparent)
        ctx.beginPath();
        ctx.arc(spaceship.x, spaceship.y, waveRadius * 0.9, 0, Math.PI * 2);
        ctx.strokeStyle = "rgba(120, 220, 255, 0.3)";
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.restore();
      }
      
      // Fighter-like missile ship
      function drawMissileShip(shipGrad) {
        // More fighter-like body but still unique
        ctx.beginPath();
        // Front point (similar to fighter shape)
        ctx.moveTo(spaceship.size, 0);
        // Right side (slightly different curve)
        ctx.lineTo(spaceship.size * 0.3, spaceship.size * 0.6);
        // Bottom right curve
        ctx.quadraticCurveTo(-spaceship.size * 0.6, spaceship.size * 0.5, -spaceship.size * 0.5, 0);
        // Bottom left mirror
        ctx.quadraticCurveTo(-spaceship.size * 0.6, -spaceship.size * 0.5, spaceship.size * 0.3, -spaceship.size * 0.6);
        ctx.closePath();
        
        // Fill with gradient
        ctx.fillStyle = shipGrad;
        ctx.fill();
        
        // Add stroke
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Add distinctive wing details - double fins
        ctx.beginPath();
        // Top fin
        ctx.moveTo(spaceship.size * 0.3, -spaceship.size * 0.3);
        ctx.lineTo(spaceship.size * 0.7, -spaceship.size * 0.5);
        ctx.lineTo(spaceship.size * 0.5, -spaceship.size * 0.6);
        ctx.closePath();
        // Bottom fin
        ctx.moveTo(spaceship.size * 0.3, spaceship.size * 0.3);
        ctx.lineTo(spaceship.size * 0.7, spaceship.size * 0.5);
        ctx.lineTo(spaceship.size * 0.5, spaceship.size * 0.6);
        ctx.closePath();
        ctx.fillStyle = "#444";
        ctx.fill();
        ctx.lineWidth = 1.5;
        ctx.stroke();
        
        // Top missile launcher (similar to fighter gun)
        ctx.beginPath();
        ctx.moveTo(spaceship.size * 0.5, -spaceship.size * 0.25);
        ctx.lineTo(spaceship.size * 0.9, -spaceship.size * 0.25);
        ctx.lineTo(spaceship.size * 0.9, -spaceship.size * 0.4);
        ctx.lineTo(spaceship.size * 0.5, -spaceship.size * 0.3);
        ctx.closePath();
        ctx.fillStyle = "#555";
        ctx.fill();
        ctx.strokeStyle = "#ccc";
        ctx.lineWidth = 1.5;
        ctx.stroke();
        
        // Bottom missile launcher (similar to fighter gun)
        ctx.beginPath();
        ctx.moveTo(spaceship.size * 0.5, spaceship.size * 0.25);
        ctx.lineTo(spaceship.size * 0.9, spaceship.size * 0.25);
        ctx.lineTo(spaceship.size * 0.9, spaceship.size * 0.4);
        ctx.lineTo(spaceship.size * 0.5, spaceship.size * 0.3);
        ctx.closePath();
        ctx.fillStyle = "#555";
        ctx.fill();
        ctx.strokeStyle = "#ccc";
        ctx.lineWidth = 1.5;
        ctx.stroke();
        
        // Missile indicator lights
        const missileReadyColor = spaceship.missileSpecialCooldown <= 0 ? 
                                "rgba(255, 255, 0, 0.8)" : 
                                "rgba(100, 100, 100, 0.6)";
        
        // Top missile indicator
        ctx.beginPath();
        ctx.arc(spaceship.size * 0.8, -spaceship.size * 0.32, spaceship.size * 0.04, 0, Math.PI * 2);
        ctx.fillStyle = missileReadyColor;
        ctx.fill();
        
        // Bottom missile indicator
        ctx.beginPath();
        ctx.arc(spaceship.size * 0.8, spaceship.size * 0.32, spaceship.size * 0.04, 0, Math.PI * 2);
        ctx.fillStyle = missileReadyColor;
        ctx.fill();
        
        // Engine flame - regular orange/red like fighter
        ctx.save();
        ctx.globalAlpha = 0.7;
        let flameLength = spaceship.size * 0.8;
        let flameWidth = spaceship.size * 0.3;
        let flameGrad = ctx.createLinearGradient(-spaceship.size * 0.5, 0, -spaceship.size * 0.5 - flameLength, 0);
        flameGrad.addColorStop(0, "yellow");
        flameGrad.addColorStop(1, "red");
        ctx.fillStyle = flameGrad;
        ctx.beginPath();
        ctx.moveTo(-spaceship.size * 0.5, flameWidth / 2);
        ctx.lineTo(-spaceship.size * 0.5 - flameLength, 0);
        ctx.lineTo(-spaceship.size * 0.5, -flameWidth / 2);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
        
        // Cockpit (similar to fighter)
        let cockpitRadius = spaceship.size * 0.25;
        let cockpitGrad = ctx.createRadialGradient(
          spaceship.size * 0.3, 0,
          cockpitRadius * 0.3,
          spaceship.size * 0.3, 0,
          cockpitRadius 
        );
        cockpitGrad.addColorStop(0, "lightblue");
        cockpitGrad.addColorStop(1, "blue");
        ctx.beginPath();
        ctx.arc(spaceship.size * 0.3, 0, cockpitRadius, 0, Math.PI * 2);
        ctx.fillStyle = cockpitGrad;
        ctx.fill();
        ctx.strokeStyle = "white";
        ctx.lineWidth = 1.5;
        ctx.stroke();
        
        // Simplified missile cooldown indicator (if needed)
        if (spaceship.missileSpecialCooldown > 0) {
          const cooldownPercentage = 1 - (spaceship.missileSpecialCooldown / 1); // 1s is max cooldown now
          
          // Draw pulsing ring around cockpit when cooldown active
          ctx.save();
          ctx.beginPath();
          ctx.arc(spaceship.size * 0.3, 0, cockpitRadius + 5, 0, Math.PI * 2);
          ctx.strokeStyle = `rgba(255, 200, 0, ${0.5 * cooldownPercentage})`;
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.restore();
        }
      }

      // 3) Draw normal comets with morph
      function drawNormalComets() {
        for (let c of comets) {
          // Draw comet trail
          if (c.trail && c.trail.length > 0) {
            ctx.save();
            let maxAlpha = 0.1;
            for (let i = 0; i < c.trail.length; i++) {
              let pos = c.trail[i];
              let alpha = ((i + 1) / c.trail.length) * maxAlpha;
              ctx.globalAlpha = alpha;
              ctx.beginPath();
              ctx.arc(pos.x, pos.y, c.radius, 0, 2 * Math.PI);
              ctx.fillStyle = "lightblue";
              ctx.fill();
            }
            ctx.restore();
          }

          // Draw comet body
          ctx.save();
          ctx.globalAlpha = 0.8;
          ctx.beginPath();
          if (c.shape && c.shape.length > 0) {
            // First vertex
            let v0 = c.shape[0];
            let factor0 = v0.factor;
            if (c.morph) {
              // Apply rotation speed if available (for new comets)
              const rotSpeed = c.rotationSpeed || 1;
              factor0 += 0.1 * Math.sin(gameTime * v0.frequency * rotSpeed + v0.phase);
            }
            ctx.moveTo(
              c.x + c.radius * factor0 * Math.cos(v0.angle),
              c.y + c.radius * factor0 * Math.sin(v0.angle)
            );

            // Remaining vertices
            for (let i = 1; i < c.shape.length; i++) {
              let v = c.shape[i];
              let f = v.factor;
              if (c.morph) {
                // Apply rotation speed if available (for new comets)
                const rotSpeed = c.rotationSpeed || 1;
                f += 0.1 * Math.sin(gameTime * v.frequency * rotSpeed + v.phase);
              }
              ctx.lineTo(
                c.x + c.radius * f * Math.cos(v.angle),
                c.y + c.radius * f * Math.sin(v.angle)
              );
            }
            ctx.closePath();
          } else {
            ctx.arc(c.x, c.y, c.radius, 0, 2 * Math.PI);
          }
          ctx.fillStyle = c.pattern;
          ctx.fill();
          // Use the comet's color for its outline, with some opacity
          ctx.strokeStyle = c.color;
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.restore();
        }
      }

      // New rocky pattern for big comets with a darker base color
      function generateRockPattern() {
        let patternCanvas = document.createElement("canvas");
        patternCanvas.width = 50;
        patternCanvas.height = 50;
        let pctx = patternCanvas.getContext("2d");
        // Use a deep, dark brown for the background:
        pctx.fillStyle = "#4a2c2a";
        pctx.fillRect(0, 0, patternCanvas.width, patternCanvas.height);
        // Add random speckles to simulate rock:
        // Reduced number of speckles for a smoother, more uniform look
        for (let i = 0; i < 20; i++) {
          let rx = Math.random() * patternCanvas.width;
          let ry = Math.random() * patternCanvas.height;
          let r = Math.random() * 1.5 + 0.5; // Smaller variations in speckle size
          pctx.fillStyle = "rgba(30,15,15,0.5)"; // More transparent speckles
          pctx.beginPath();
          pctx.arc(rx, ry, r, 0, 2 * Math.PI);
          pctx.fill();
        }
        return pctx.createPattern(patternCanvas, "repeat");
      }


      // Cache the new rock pattern
      const cachedRockPattern = generateRockPattern();

      function spawnBigComet() {
        // Choose starting position that will cross closer to center screen
        // Use either top/bottom or left/right edges
        let x, y, angle;
        
        if (Math.random() < 0.5) {
          // Spawn from left or right edge
          x = Math.random() < 0.5 ? -BASE_COMET_RADIUS * BIG_COMET_SCALE : canvas.width + BASE_COMET_RADIUS * BIG_COMET_SCALE;
          
          // Calculate y to aim toward center-ish area (with some variation)
          const targetY = canvas.height * (0.3 + Math.random() * 0.4); // Target 30-70% of screen height
          y = randomRange(0, canvas.height);
          
          // Calculate angle toward target point near center
          angle = Math.atan2(targetY - y, (canvas.width/2) - x);
        } else {
          // Spawn from top or bottom edge
          y = Math.random() < 0.5 ? -BASE_COMET_RADIUS * BIG_COMET_SCALE : canvas.height + BASE_COMET_RADIUS * BIG_COMET_SCALE;
          
          // Calculate x to aim toward center-ish area (with some variation)
          const targetX = canvas.width * (0.3 + Math.random() * 0.4); // Target 30-70% of screen width
          x = randomRange(0, canvas.width);
          
          // Calculate angle toward target point near center
          angle = Math.atan2((canvas.height/2) - y, targetX - x);
        }
        
        // Slow down big comets for longer screen time
        const speed = randomRange(BIG_COMET_SPEED_MIN * 0.7, BIG_COMET_SPEED_MAX * 0.7);
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;
        let radius = BASE_COMET_RADIUS * BIG_COMET_SCALE;
        
        // Use more segments for a smoother, rounder shape (12 -> 18)
        let shape = generateCometShape(18);
        
        // Make big comets much more round with minimal variation
        shape.forEach(v => {
          // Minimal variation for near-perfect roundness (0.2 -> 0.05)
          v.factor = 1 + (v.factor - 1) * 0.05;
          // Greatly reduce frequency for slower rotation
          v.frequency = v.frequency * 0.3;
        });
        
        let big = {
          x, y, vx, vy,
          radius,
          color: BIG_COMET_COLOR,
          hitPoints: BIG_COMET_HEALTH,
          indestructible: false,
          shape: shape,
          // Generate a unique rock pattern for each comet
          pattern: generateRockPattern(),
          trail: [],
          trailTimer: 0,
          morph: true,
          // Slow rotation for big comets
          rotationSpeed: randomRange(0.3, 0.5),
          // Properties for hit effects
          hitFlashTimer: 0,
          hitCount: 0,
          shakeAmount: 0,
          shakeTimer: 0,
          shakeX: 0,
          shakeY: 0
        };
        bigComets.push(big);
      }



      // Function to draw the distant pulsar
      function drawPulsar(ctx) {
        if (!pulsarActive) return;
        
        // Update pulsar animation
        pulsarTime += 0.016; // Approx 60fps
        const pulseScale = 0.5 + Math.sin(pulsarTime * 2) * 0.3;
        const pulseAlpha = 0.2 + Math.sin(pulsarTime * 3) * 0.1;
        
        // Draw pulsar with pulsing effect
        ctx.save();
        
        // Outer glow
        const outerRadius = pulsarRadius * (1.5 + pulseScale);
        const gradient = ctx.createRadialGradient(
          pulsarX, pulsarY, pulsarRadius * 0.2,
          pulsarX, pulsarY, outerRadius
        );
        
        gradient.addColorStop(0, pulsarColor + (pulseAlpha + 0.1) + ')');
        gradient.addColorStop(0.4, pulsarColor + (pulseAlpha * 0.6) + ')');
        gradient.addColorStop(1, pulsarColor + '0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(pulsarX, pulsarY, outerRadius, 0, Math.PI * 2);
        ctx.fill();
        
        // Core
        ctx.beginPath();
        ctx.arc(pulsarX, pulsarY, pulsarRadius * pulseScale, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(200, 240, 255, ' + (pulseAlpha + 0.3) + ')';
        ctx.shadowBlur = 15;
        ctx.shadowColor = 'rgba(100, 200, 255, 0.8)';
        ctx.fill();
        
        // Light rays (occasionally)
        if (Math.sin(pulsarTime * 1.5) > 0.7) {
          const numRays = 4;
          const rayLength = pulsarRadius * 4 * pulseScale;
          
          ctx.strokeStyle = 'rgba(180, 230, 255, ' + (pulseAlpha * 0.4) + ')';
          ctx.lineWidth = 1;
          
          for (let i = 0; i < numRays; i++) {
            const angle = (i / numRays) * Math.PI * 2;
            ctx.beginPath();
            ctx.moveTo(pulsarX, pulsarY);
            ctx.lineTo(
              pulsarX + Math.cos(angle) * rayLength,
              pulsarY + Math.sin(angle) * rayLength
            );
            ctx.stroke();
          }
        }
        
        ctx.restore();
      }
      
      function drawBigComets(ctx) {
        for (let bc of bigComets) {
          ctx.save();
          ctx.globalAlpha = 1.0;
          
          // Create a simple pattern for the comet
          // We'll create it once and cache it with the comet
          if (!bc.simplePattern) {
            const patternSize = 100;
            const patternCanvas = document.createElement('canvas');
            patternCanvas.width = patternSize;
            patternCanvas.height = patternSize;
            const patternCtx = patternCanvas.getContext('2d');
            
            // Fill with base color
            patternCtx.fillStyle = "#704020";
            patternCtx.fillRect(0, 0, patternSize, patternSize);
            
            // Create a simple grid pattern
            patternCtx.strokeStyle = "#603010";
            patternCtx.lineWidth = 1;
            
            // Draw horizontal lines
            const lineSpacing = 10;
            for (let y = 0; y < patternSize; y += lineSpacing) {
              patternCtx.beginPath();
              patternCtx.moveTo(0, y);
              patternCtx.lineTo(patternSize, y);
              patternCtx.stroke();
            }
            
            // Draw vertical lines
            for (let x = 0; x < patternSize; x += lineSpacing) {
              patternCtx.beginPath();
              patternCtx.moveTo(x, 0);
              patternCtx.lineTo(x, patternSize);
              patternCtx.stroke();
            }
            
            // Add some random darker spots
            for (let i = 0; i < 30; i++) {
              const spotX = Math.random() * patternSize;
              const spotY = Math.random() * patternSize;
              const spotRadius = 2 + Math.random() * 5;
              
              patternCtx.fillStyle = 'rgba(40, 20, 10, 0.5)';
              patternCtx.beginPath();
              patternCtx.arc(spotX, spotY, spotRadius, 0, Math.PI * 2);
              patternCtx.fill();
            }
            
            // Add a few lighter spots
            for (let i = 0; i < 20; i++) {
              const spotX = Math.random() * patternSize;
              const spotY = Math.random() * patternSize;
              const spotRadius = 1 + Math.random() * 3;
              
              patternCtx.fillStyle = 'rgba(150, 100, 50, 0.5)';
              patternCtx.beginPath();
              patternCtx.arc(spotX, spotY, spotRadius, 0, Math.PI * 2);
              patternCtx.fill();
            }
            
            // Store the pattern with the comet
            bc.simplePattern = ctx.createPattern(patternCanvas, 'repeat');
          }
          
          // Apply shake effect if active
          const drawX = bc.x + (bc.shakeX || 0);
          const drawY = bc.y + (bc.shakeY || 0);
          
          // Draw comet outline with potential hit flash
          ctx.beginPath();
          if (bc.shape && bc.shape.length > 0) {
            let v0 = bc.shape[0];
            let factor0 = v0.factor;
            if (bc.morph) {
              // Apply rotation speed to big comets too
              const rotSpeed = bc.rotationSpeed || 1.5;
              factor0 += 0.1 * Math.sin(gameTime * v0.frequency * rotSpeed + v0.phase);
            }
            ctx.moveTo(
              drawX + bc.radius * factor0 * Math.cos(v0.angle),
              drawY + bc.radius * factor0 * Math.sin(v0.angle)
            );
            for (let i = 1; i < bc.shape.length; i++) {
              let v = bc.shape[i];
              let f = v.factor;
              if (bc.morph) {
                // Apply rotation speed to big comets too
                const rotSpeed = bc.rotationSpeed || 1.5;
                f += 0.1 * Math.sin(gameTime * v.frequency * rotSpeed + v.phase);
              }
              ctx.lineTo(
                drawX + bc.radius * f * Math.cos(v.angle),
                drawY + bc.radius * f * Math.sin(v.angle)
              );
            }
            ctx.closePath();
          } else {
            ctx.arc(drawX, drawY, bc.radius, 0, Math.PI * 2);
          }
          
          // Add hit flash effect
          if (bc.hitFlashTimer > 0) {
            // White flash overlay
            ctx.fillStyle = `rgba(255, 255, 255, ${bc.hitFlashTimer * 5})`;
            ctx.fill();
          }
          
          // Apply the pattern with rotation
          ctx.save();
          
          // Create a transform matrix for the pattern
          ctx.translate(drawX, drawY);
          // Very slow pattern rotation - faster when damaged
          const rotationSpeed = 0.01 * (1 + (bc.hitCount / BIG_COMET_HEALTH));
          ctx.rotate(gameTime * rotationSpeed); 
          ctx.translate(-drawX, -drawY);
          
          // Fill with pattern
          ctx.fillStyle = bc.simplePattern;
          ctx.fill();
          
          ctx.restore();
          
          // Add a subtle 3D effect with gradient overlay
          ctx.globalCompositeOperation = 'overlay';
          const gradient = ctx.createRadialGradient(
            drawX - bc.radius * 0.3, drawY - bc.radius * 0.3, 0,
            drawX, drawY, bc.radius
          );
          
          // Change gradient colors based on damage - more gradual with higher health
          const damageRatio = bc.hitCount / BIG_COMET_HEALTH;
          
          // Create a more dynamic gradient for the higher health
          if (damageRatio > 0.9) {
            // Critically damaged - bright red glow
            gradient.addColorStop(0, 'rgba(255, 100, 50, 0.4)');
            gradient.addColorStop(0.7, 'rgba(220, 30, 30, 0.25)');
            gradient.addColorStop(1, 'rgba(120, 0, 0, 0.3)');
          } else if (damageRatio > 0.7) {
            // Severely damaged - red
            gradient.addColorStop(0, 'rgba(255, 150, 100, 0.3)');
            gradient.addColorStop(0.7, 'rgba(200, 50, 50, 0.2)');
            gradient.addColorStop(1, 'rgba(100, 0, 0, 0.3)');
          } else if (damageRatio > 0.4) {
            // Moderately damaged - orange tint
            gradient.addColorStop(0, 'rgba(255, 200, 100, 0.25)');
            gradient.addColorStop(0.7, 'rgba(150, 100, 50, 0.15)');
            gradient.addColorStop(1, 'rgba(100, 50, 0, 0.3)');
          } else if (damageRatio > 0.1) {
            // Slightly damaged - yellowish
            gradient.addColorStop(0, 'rgba(255, 240, 150, 0.2)');
            gradient.addColorStop(0.7, 'rgba(150, 140, 80, 0.15)');
            gradient.addColorStop(1, 'rgba(80, 70, 20, 0.3)');
          } else {
            // Normal
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
            gradient.addColorStop(0.7, 'rgba(100, 100, 100, 0.1)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
          }
          
          // Use the same path that's already defined (no new circle)
          ctx.fillStyle = gradient;
          ctx.fill();
          
          // Display health indicator when damaged
          if (bc.hitCount > 0) {
            const healthBarWidth = bc.radius * 1.5;
            const healthBarHeight = bc.radius * 0.15;
            const healthPercent = bc.hitPoints / BIG_COMET_HEALTH; // Show percentage of total health
            
            ctx.globalCompositeOperation = 'source-over';
            
            // Draw health bar background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(
              drawX - healthBarWidth/2,
              drawY - bc.radius - 20,
              healthBarWidth,
              healthBarHeight
            );
            
            // Draw health bar
            ctx.fillStyle = 'rgba(255, 50, 50, 0.8)';
            ctx.fillRect(
              drawX - healthBarWidth/2,
              drawY - bc.radius - 20,
              healthBarWidth * healthPercent,
              healthBarHeight
            );
          }
          
          // Reset composite operation
          ctx.globalCompositeOperation = 'source-over';
          
          ctx.restore();
        }
      }


      // Main Draw
      // Initialize pulsar position
      function initPulsar() {
        // Position near the top-left or bottom-left corner
        pulsarX = Math.random() * canvas.width * 0.2 + 60;
        pulsarY = Math.random() < 0.5 ? 
                 Math.random() * canvas.height * 0.2 + 60 : 
                 canvas.height - (Math.random() * canvas.height * 0.2 + 60);
        
        // Random variations in appearance
        pulsarRadius = Math.random() * 10 + 20;
        pulsarColor = Math.random() < 0.3 ? 
                     'rgba(220, 150, 70, ' :  // Orange pulsar
                     'rgba(100, 200, 255, ';  // Blue pulsar
      }
      
      // Call initialization on startup
      initPulsar();
      
      // Function to draw background spaceships
      function drawBackgroundSpaceships() {
        const time = performance.now() / 2000; // Slower animation cycle
        
        // Draw three additional spaceships with different properties
        drawSpaceship1(time);
        drawSpaceship2(time);
        drawSpaceship3(time);
        
        // Draw the main large rocket
        drawLargeBackgroundRocket();
      }
      
      // First additional spaceship (small, distant)
      function drawSpaceship1(time) {
        // Position in top left area
        const shipX = canvas.width * 0.2;
        const shipY = canvas.height * 0.25;
        const shipSize = canvas.height * 0.15; // Smaller size
        const shipTilt = Math.PI / 12; // Slight positive tilt
        
        // Very subtle movement
        const floatX = Math.sin(time * 0.8) * 3;
        const floatY = Math.cos(time * 0.6) * 2;
        
        ctx.save();
        ctx.translate(shipX + floatX, shipY + floatY);
        ctx.rotate(shipTilt);
        
        // Most transparent (appears furthest)
        ctx.globalAlpha = 0.08;
        
        // Draw simplified ship
        ctx.fillStyle = "white";
        ctx.strokeStyle = "rgba(150, 200, 255, 0.5)";
        ctx.lineWidth = shipSize * 0.02;
        
        // Ship body
        ctx.beginPath();
        ctx.moveTo(0, -shipSize/2); // Top point
        ctx.lineTo(shipSize/5, shipSize/2); // Bottom right
        ctx.lineTo(-shipSize/5, shipSize/2); // Bottom left
        ctx.closePath();
        ctx.fill();
        
        // Small exhaust flame
        const flameHeight = shipSize/5 + Math.sin(time * 5) * shipSize/25;
        
        const flameGradient = ctx.createLinearGradient(
          0, shipSize/2,
          0, shipSize/2 + flameHeight
        );
        flameGradient.addColorStop(0, "rgba(255, 200, 50, 0.6)");
        flameGradient.addColorStop(1, "rgba(255, 100, 50, 0)");
        
        ctx.fillStyle = flameGradient;
        ctx.beginPath();
        ctx.moveTo(-shipSize/10, shipSize/2); // Left base
        ctx.quadraticCurveTo(0, shipSize/2 + flameHeight, shipSize/10, shipSize/2); // Curve to right
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
      }
      
      // Second additional spaceship (medium, different design)
      function drawSpaceship2(time) {
        // Position in bottom left
        const shipX = canvas.width * 0.25;
        const shipY = canvas.height * 0.7;
        const shipSize = canvas.height * 0.2; // Medium size
        const shipTilt = -Math.PI / 18; // Small negative tilt
        
        // Medium movement
        const floatX = Math.sin(time * 0.5 + 1) * 4;
        const floatY = Math.cos(time * 0.7 + 2) * 3;
        
        ctx.save();
        ctx.translate(shipX + floatX, shipY + floatY);
        ctx.rotate(shipTilt);
        
        // Medium transparency
        ctx.globalAlpha = 0.12;
        
        // Draw slightly different ship design
        ctx.fillStyle = "white";
        ctx.strokeStyle = "rgba(150, 200, 255, 0.6)";
        ctx.lineWidth = shipSize * 0.015;
        
        // Ship body (more rounded)
        ctx.beginPath();
        ctx.moveTo(0, -shipSize/2); // Top point
        ctx.quadraticCurveTo(shipSize/4, 0, shipSize/5, shipSize/2); // Right curve
        ctx.lineTo(-shipSize/5, shipSize/2); // Bottom
        ctx.quadraticCurveTo(-shipSize/4, 0, 0, -shipSize/2); // Left curve
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // Window
        ctx.beginPath();
        ctx.fillStyle = "rgba(150, 220, 255, 0.7)";
        ctx.arc(0, -shipSize/6, shipSize/15, 0, Math.PI * 2);
        ctx.fill();
        
        // Ship fins
        ctx.beginPath();
        ctx.moveTo(-shipSize/5, shipSize/3);
        ctx.lineTo(-shipSize/3, shipSize/2);
        ctx.lineTo(-shipSize/5, shipSize/2);
        
        ctx.moveTo(shipSize/5, shipSize/3);
        ctx.lineTo(shipSize/3, shipSize/2);
        ctx.lineTo(shipSize/5, shipSize/2);
        ctx.stroke();
        
        // Medium exhaust flame
        const flameHeight = shipSize/4 + Math.sin(time * 7) * shipSize/20;
        
        const flameGradient = ctx.createLinearGradient(
          0, shipSize/2,
          0, shipSize/2 + flameHeight
        );
        flameGradient.addColorStop(0, "rgba(255, 180, 50, 0.7)");
        flameGradient.addColorStop(0.6, "rgba(255, 100, 50, 0.4)");
        flameGradient.addColorStop(1, "rgba(255, 50, 20, 0)");
        
        ctx.fillStyle = flameGradient;
        ctx.beginPath();
        ctx.moveTo(-shipSize/7, shipSize/2);
        ctx.quadraticCurveTo(0, shipSize/2 + flameHeight * 1.1, 0, shipSize/2 + flameHeight);
        ctx.quadraticCurveTo(0, shipSize/2 + flameHeight * 1.1, shipSize/7, shipSize/2);
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
      }
      
      // Third additional spaceship (larger, more visible)
      function drawSpaceship3(time) {
        // Position in middle right area
        const shipX = canvas.width * 0.6;
        const shipY = canvas.height * 0.4;
        const shipSize = canvas.height * 0.25; // Larger size
        const shipTilt = Math.PI / 24; // Very slight tilt
        
        // More noticeable movement
        const floatX = Math.sin(time * 0.6 + 2) * 6;
        const floatY = Math.cos(time * 0.4 + 1) * 5;
        
        ctx.save();
        ctx.translate(shipX + floatX, shipY + floatY);
        ctx.rotate(shipTilt);
        
        // Most visible of the three additional ships
        ctx.globalAlpha = 0.13;
        
        // Draw more detailed ship
        ctx.fillStyle = "white";
        ctx.strokeStyle = "rgba(150, 200, 255, 0.7)";
        ctx.lineWidth = shipSize * 0.02;
        
        // Ship body
        ctx.beginPath();
        ctx.moveTo(0, -shipSize/2); // Top point
        ctx.lineTo(shipSize/4, shipSize/2); // Bottom right
        ctx.lineTo(-shipSize/4, shipSize/2); // Bottom left
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // Window
        ctx.beginPath();
        ctx.fillStyle = "rgba(150, 220, 255, 0.7)";
        ctx.arc(0, -shipSize/5, shipSize/10, 0, Math.PI * 2);
        ctx.fill();
        
        // Ship fins (more prominent)
        ctx.beginPath();
        // Left fin
        ctx.moveTo(-shipSize/4, shipSize/3);
        ctx.lineTo(-shipSize/2.5, shipSize/2 + shipSize/6);
        ctx.lineTo(-shipSize/6, shipSize/2);
        // Right fin
        ctx.moveTo(shipSize/4, shipSize/3);
        ctx.lineTo(shipSize/2.5, shipSize/2 + shipSize/6);
        ctx.lineTo(shipSize/6, shipSize/2);
        ctx.stroke();
        
        // Larger flame
        const flameHeight = shipSize/3 + Math.sin(time * 8) * shipSize/15;
        
        const flameGradient = ctx.createLinearGradient(
          0, shipSize/2,
          0, shipSize/2 + flameHeight
        );
        flameGradient.addColorStop(0, "rgba(255, 220, 50, 0.8)");
        flameGradient.addColorStop(0.5, "rgba(255, 130, 50, 0.5)");
        flameGradient.addColorStop(1, "rgba(255, 70, 20, 0)");
        
        ctx.fillStyle = flameGradient;
        ctx.beginPath();
        ctx.moveTo(-shipSize/5, shipSize/2);
        ctx.quadraticCurveTo(0, shipSize/2 + flameHeight * 1.2, 0, shipSize/2 + flameHeight);
        ctx.quadraticCurveTo(0, shipSize/2 + flameHeight * 1.2, shipSize/5, shipSize/2);
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
      }
      
      // Draw the pause menu
      function drawPauseMenu() {
        // Draw gameplay elements in the background
        // Draw Spaceship
        drawSpaceship();
        
        // Draw comets, bullets, etc.
        for (let b of bullets) {
          ctx.fillStyle = "white";
          ctx.beginPath();
          ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
          ctx.fill();
        }
        
        for (let c of comets) {
          ctx.fillStyle = c.color;
          ctx.beginPath();
          ctx.arc(c.x, c.y, c.radius, 0, Math.PI * 2);
          ctx.fill();
        }
        
        for (let p of smallExplosionParticles) {
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fillStyle = p.color;
          ctx.fill();
        }
        
        // Create a semi-transparent overlay
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw pause menu
        ctx.fillStyle = "white";
        ctx.font = "48px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Game Paused", canvas.width / 2, canvas.height / 3);
        
        // Menu options
        const menuItems = [
          { text: "Resume Game", action: "resume" },
          { text: "Restart", action: "restart" },
          { text: "Return to Main Menu", action: "menu" }
        ];
        
        const menuStartY = canvas.height / 2;
        const menuSpacing = 60;
        const buttonWidth = 300;
        const buttonHeight = 50;
        
        for (let i = 0; i < menuItems.length; i++) {
          const item = menuItems[i];
          const y = menuStartY + i * menuSpacing;
          
          // Create button with hover effect
          ctx.beginPath();
          ctx.roundRect(canvas.width/2 - buttonWidth/2, y, buttonWidth, buttonHeight, 10);
          
          // Highlight selected item
          if (i === pauseMenuSelectedItem) {
            ctx.fillStyle = "rgba(0, 150, 255, 0.7)";
            ctx.strokeStyle = "rgba(100, 200, 255, 0.9)";
            ctx.lineWidth = 3;
          } else {
            ctx.fillStyle = "rgba(0, 100, 200, 0.4)";
            ctx.strokeStyle = "rgba(100, 150, 255, 0.5)";
            ctx.lineWidth = 1;
          }
          
          ctx.fill();
          ctx.stroke();
          
          // Item text
          ctx.fillStyle = "white";
          ctx.font = "20px sans-serif";
          ctx.textAlign = "center";
          ctx.fillText(item.text, canvas.width/2, y + 32);
        }
        
        // Instructions
        ctx.fillStyle = "rgba(200, 200, 255, 0.7)";
        ctx.font = "18px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("↑/↓: Navigate   ENTER: Select   ESC: Resume Game", canvas.width / 2, canvas.height - 40);
      }
      
      // Function to draw a large background rocket
      function drawLargeBackgroundRocket() {
        const rocketTime = performance.now() / 2000; // Slower animation
        
        // Position on the right side of the screen, tilted
        const rocketX = canvas.width * 0.85;
        const rocketY = canvas.height * 0.65;
        const rocketSize = canvas.height * 0.45; // Large size (45% of screen height)
        const rocketTilt = -Math.PI / 9; // Approx -20 degrees tilt
        
        // Subtle floating motion
        const floatX = Math.sin(rocketTime * 0.7) * 5; 
        const floatY = Math.cos(rocketTime * 0.5) * 5;
        
        ctx.save();
        // Translate to position and apply tilt
        ctx.translate(rocketX + floatX, rocketY + floatY);
        ctx.rotate(rocketTilt);
        
        // Semi-transparent rocket for background effect
        ctx.globalAlpha = 0.15;
        
        // Rocket body
        ctx.fillStyle = "white";
        ctx.strokeStyle = "rgba(150, 200, 255, 0.7)";
        ctx.lineWidth = rocketSize * 0.02;
        
        // Main rocket body
        ctx.beginPath();
        ctx.moveTo(0, -rocketSize/2); // Top point
        ctx.lineTo(rocketSize/5, rocketSize/2); // Bottom right
        ctx.lineTo(-rocketSize/5, rocketSize/2); // Bottom left
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // Rocket window
        ctx.beginPath();
        ctx.fillStyle = "rgba(150, 200, 255, 0.6)";
        ctx.arc(0, -rocketSize/6, rocketSize/12, 0, Math.PI * 2);
        ctx.fill();
        
        // Rocket fins
        ctx.beginPath();
        // Left fin
        ctx.moveTo(-rocketSize/5, rocketSize/2);
        ctx.lineTo(-rocketSize/3, rocketSize/2 + rocketSize/6);
        ctx.lineTo(-rocketSize/6, rocketSize/2);
        // Right fin
        ctx.moveTo(rocketSize/5, rocketSize/2);
        ctx.lineTo(rocketSize/3, rocketSize/2 + rocketSize/6);
        ctx.lineTo(rocketSize/6, rocketSize/2);
        ctx.stroke();
        
        // Rocket exhaust/flame (animated)
        const flameHeight = rocketSize/3 + Math.sin(rocketTime * 6) * rocketSize/20;
        
        const flameGradient = ctx.createLinearGradient(
          0, rocketSize/2,
          0, rocketSize/2 + flameHeight
        );
        flameGradient.addColorStop(0, "rgba(255, 200, 50, 0.6)");
        flameGradient.addColorStop(0.7, "rgba(255, 100, 50, 0.3)");
        flameGradient.addColorStop(1, "rgba(255, 50, 20, 0)");
        
        ctx.fillStyle = flameGradient;
        ctx.beginPath();
        ctx.moveTo(-rocketSize/6, rocketSize/2); // Left base
        ctx.quadraticCurveTo(0, rocketSize/2 + flameHeight * 1.2, 0, rocketSize/2 + flameHeight); // Curve to bottom
        ctx.quadraticCurveTo(0, rocketSize/2 + flameHeight * 1.2, rocketSize/6, rocketSize/2); // Curve to right
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
      }
      
      // Draw the Main Menu
      function drawMainMenu() {
        // Draw all background spaceships
        drawBackgroundSpaceships();
        
        // Game Title with enhanced styling
        const titleY = canvas.height / 4;
        
        // Draw outer glow
        ctx.save();
        ctx.shadowBlur = 15;
        ctx.shadowColor = "rgba(0, 150, 255, 0.8)";
        ctx.fillStyle = "#ffffff";
        ctx.font = "bold 52px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("SPLITTING COMETS", canvas.width / 2, titleY);
        ctx.restore();
        
        // Draw subtle text stroke
        ctx.save();
        ctx.strokeStyle = "rgba(0, 200, 255, 0.6)";
        ctx.lineWidth = 2;
        ctx.font = "bold 52px sans-serif";
        ctx.textAlign = "center";
        ctx.strokeText("SPLITTING COMETS", canvas.width / 2, titleY);
        
        // Main text with gradient
        const gradient = ctx.createLinearGradient(
          canvas.width/2 - 200, titleY - 40, 
          canvas.width/2 + 200, titleY + 10
        );
        gradient.addColorStop(0, "#ffffff");
        gradient.addColorStop(0.5, "#80c0ff");
        gradient.addColorStop(1, "#ffffff");
        
        ctx.fillStyle = gradient;
        ctx.font = "bold 52px sans-serif";
        ctx.fillText("SPLITTING COMETS", canvas.width / 2, titleY);
        ctx.restore();
        
        // Add a subtle animated underline
        const lineWidth = 320;
        const lineTime = performance.now() / 1000;
        
        ctx.save();
        ctx.strokeStyle = "rgba(0, 150, 255, 0.7)";
        ctx.lineWidth = 3;
        ctx.beginPath();
        
        // Wavy animated line
        for (let x = -lineWidth/2; x < lineWidth/2; x++) {
          const waveHeight = 3 * Math.sin((x / 30) + lineTime * 2);
          const xPos = canvas.width/2 + x;
          const yPos = titleY + 15 + waveHeight;
          
          if (x === -lineWidth/2) {
            ctx.moveTo(xPos, yPos);
          } else {
            ctx.lineTo(xPos, yPos);
          }
        }
        
        ctx.stroke();
        ctx.restore();
        
        // Add minimalistic rocket and comet
        const rocketTime = performance.now() / 1000;
        
        // Draw comet (right side)
        ctx.save();
        const cometX = canvas.width/2 + 230;
        const cometY = titleY - 15;
        const cometTilt = Math.PI * 0.25; // Angle for comet trajectory
        const cometFloat = Math.sin(rocketTime * 1.5) * 5; // Subtle floating motion
        
        // Draw comet body (semi-transparent circle)
        ctx.beginPath();
        ctx.fillStyle = "rgba(180, 220, 255, 0.7)";
        ctx.strokeStyle = "rgba(220, 240, 255, 0.9)";
        ctx.lineWidth = 1.5;
        ctx.arc(cometX, cometY + cometFloat, 15, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        
        // Draw comet tail
        ctx.beginPath();
        const tailGradient = ctx.createLinearGradient(
          cometX, cometY + cometFloat,
          cometX - 40, cometY + cometFloat - 40
        );
        tailGradient.addColorStop(0, "rgba(180, 220, 255, 0.7)");
        tailGradient.addColorStop(1, "rgba(180, 220, 255, 0)");
        
        ctx.fillStyle = tailGradient;
        ctx.moveTo(cometX, cometY + cometFloat);
        ctx.lineTo(cometX - 45, cometY + cometFloat - 45);
        ctx.lineTo(cometX - 30, cometY + cometFloat - 25);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
        
        // Draw rocket (left side)
        ctx.save();
        const rocketX = canvas.width/2 - 230;
        const rocketY = titleY + 15;
        const rocketFloat = Math.sin(rocketTime) * 3; // Subtle floating motion
        
        // Rocket body
        ctx.fillStyle = "white";
        ctx.strokeStyle = "rgba(100, 180, 255, 0.8)";
        ctx.lineWidth = 1.5;
        
        // Main rocket body
        ctx.beginPath();
        ctx.moveTo(rocketX, rocketY + rocketFloat - 20); // Top point
        ctx.lineTo(rocketX + 8, rocketY + rocketFloat); // Bottom right
        ctx.lineTo(rocketX - 8, rocketY + rocketFloat); // Bottom left
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // Rocket window
        ctx.beginPath();
        ctx.fillStyle = "rgba(100, 180, 255, 0.8)";
        ctx.arc(rocketX, rocketY + rocketFloat - 10, 3, 0, Math.PI * 2);
        ctx.fill();
        
        // Rocket fins
        ctx.beginPath();
        ctx.moveTo(rocketX - 8, rocketY + rocketFloat); // Left bottom
        ctx.lineTo(rocketX - 12, rocketY + rocketFloat + 5); // Left fin
        ctx.lineTo(rocketX - 6, rocketY + rocketFloat); // Back to rocket
        ctx.moveTo(rocketX + 8, rocketY + rocketFloat); // Right bottom
        ctx.lineTo(rocketX + 12, rocketY + rocketFloat + 5); // Right fin
        ctx.lineTo(rocketX + 6, rocketY + rocketFloat); // Back to rocket
        ctx.stroke();
        
        // Rocket exhaust/flame (animated)
        const flameHeight = 6 + Math.sin(rocketTime * 10) * 2; // Animate flame
        
        const flameGradient = ctx.createLinearGradient(
          rocketX, rocketY + rocketFloat,
          rocketX, rocketY + rocketFloat + flameHeight + 5
        );
        flameGradient.addColorStop(0, "rgba(255, 200, 50, 0.9)");
        flameGradient.addColorStop(1, "rgba(255, 100, 50, 0)");
        
        ctx.fillStyle = flameGradient;
        ctx.beginPath();
        ctx.moveTo(rocketX - 5, rocketY + rocketFloat); // Left base
        ctx.lineTo(rocketX, rocketY + rocketFloat + flameHeight + 5); // Bottom point
        ctx.lineTo(rocketX + 5, rocketY + rocketFloat); // Right base
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
        
        // Menu options
        const menuY = canvas.height / 2 - 40;
        const menuSpacing = 50;
        const buttonWidth = 200;
        const buttonHeight = 40;
        
        const menuOptions = [
          { text: "Play Game" },
          { text: "Settings" },
          { text: "How to Play" },
          { text: "Scoreboard" }
        ];
        
        for (let i = 0; i < menuOptions.length; i++) {
          const option = menuOptions[i];
          const y = menuY + i * menuSpacing;
          
          // Button background - semi-transparent with rounded corners
          const cornerRadius = 8;
          
          // Create button path with rounded corners
          ctx.beginPath();
          ctx.moveTo(canvas.width/2 - buttonWidth/2 + cornerRadius, y);
          ctx.lineTo(canvas.width/2 + buttonWidth/2 - cornerRadius, y);
          ctx.quadraticCurveTo(canvas.width/2 + buttonWidth/2, y, canvas.width/2 + buttonWidth/2, y + cornerRadius);
          ctx.lineTo(canvas.width/2 + buttonWidth/2, y + buttonHeight - cornerRadius);
          ctx.quadraticCurveTo(canvas.width/2 + buttonWidth/2, y + buttonHeight, canvas.width/2 + buttonWidth/2 - cornerRadius, y + buttonHeight);
          ctx.lineTo(canvas.width/2 - buttonWidth/2 + cornerRadius, y + buttonHeight);
          ctx.quadraticCurveTo(canvas.width/2 - buttonWidth/2, y + buttonHeight, canvas.width/2 - buttonWidth/2, y + buttonHeight - cornerRadius);
          ctx.lineTo(canvas.width/2 - buttonWidth/2, y + cornerRadius);
          ctx.quadraticCurveTo(canvas.width/2 - buttonWidth/2, y, canvas.width/2 - buttonWidth/2 + cornerRadius, y);
          ctx.closePath();
          
          // Exactly matching settings menu style
          if (i === selectedMainMenuItem) {
            // Selected button styling
            ctx.fillStyle = "rgba(0, 150, 255, 0.4)";    // Brighter blue when selected
            ctx.strokeStyle = "rgba(0, 191, 255, 0.8)";  // Bright blue border
            ctx.lineWidth = 2;
          } else {
            // Unselected button styling
            ctx.fillStyle = "rgba(0, 100, 255, 0.2)";    // Darker blue when not selected
            ctx.strokeStyle = "rgba(0, 150, 255, 0.4)";  // Darker blue border
            ctx.lineWidth = 1;
          }
          
          ctx.fill();
          ctx.stroke();
          
          // Setting text just like settings menu
          ctx.textAlign = "center";
          ctx.font = "24px sans-serif";
          ctx.fillStyle = "white";  // Always white text for better visibility
          ctx.shadowBlur = 0;
          
          ctx.fillText(option.text, canvas.width/2, y + 28);
        }
        
        // Show previous score if any
        if (score > 0) {
          ctx.fillStyle = "#FFD700"; // Gold color
          ctx.font = "20px sans-serif";
          ctx.fillText(`Previous Score: ${score}`, canvas.width / 2, canvas.height - 60);
        }
        
        // Instructions with subtle backdrop at bottom
        const instructY = canvas.height - 70;
        const instructHeight = 60;
        
        // Draw semi-transparent backdrop for instructions
        ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
        ctx.fillRect(0, instructY, canvas.width, instructHeight);
        
        // Navigation instructions
        ctx.fillStyle = "rgba(200, 200, 220, 0.9)";
        ctx.font = "16px sans-serif";
        ctx.fillText("↑/↓: Navigate menu   ENTER: Select", canvas.width / 2, instructY + 20);
        
        // Show sound status
        const musicStatus = musicEnabled ? "ON" : "OFF";
        const soundFxStatus = soundEnabled ? "ON" : "OFF";
        ctx.fillText(`Music: ${musicStatus}   Sound FX: ${soundFxStatus}`, canvas.width / 2, instructY + 45);
        
        // Draw music icon
        drawMusicIcon();
      }
      
      // Draw the Difficulty Selection screen
      function drawDifficultySelect() {
        ctx.fillStyle = "white";
        ctx.font = "36px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Select Difficulty", canvas.width / 2, canvas.height / 4);
        
        const diffY = canvas.height / 2 - 80;
        const diffSpacing = 70;
        const buttonWidth = 250;
        const buttonHeight = 50;
        
        const difficulties = [
          { 
            name: "Easy", 
            desc: "For beginners - the calm before the storm", 
            value: DIFFICULTY.EASY 
          },
          { 
            name: "Medium", 
            desc: "The classic challenge - cosmic chaos awaits", 
            value: DIFFICULTY.MEDIUM 
          },
          { 
            name: "Hard", 
            desc: "For veterans - an asteroid hell", 
            value: DIFFICULTY.HARD 
          },
          { 
            name: "Infinity", 
            desc: "Endless void - how long can you survive?", 
            value: DIFFICULTY.INFINITY 
          }
        ];
        
        for (let i = 0; i < difficulties.length; i++) {
          const diff = difficulties[i];
          const y = diffY + i * diffSpacing;
          
          // Button background - semi-transparent with rounded corners
          const cornerRadius = 8;
          
          // Create button path with rounded corners
          ctx.beginPath();
          ctx.moveTo(canvas.width/2 - buttonWidth/2 + cornerRadius, y);
          ctx.lineTo(canvas.width/2 + buttonWidth/2 - cornerRadius, y);
          ctx.quadraticCurveTo(canvas.width/2 + buttonWidth/2, y, canvas.width/2 + buttonWidth/2, y + cornerRadius);
          ctx.lineTo(canvas.width/2 + buttonWidth/2, y + buttonHeight - cornerRadius);
          ctx.quadraticCurveTo(canvas.width/2 + buttonWidth/2, y + buttonHeight, canvas.width/2 + buttonWidth/2 - cornerRadius, y + buttonHeight);
          ctx.lineTo(canvas.width/2 - buttonWidth/2 + cornerRadius, y + buttonHeight);
          ctx.quadraticCurveTo(canvas.width/2 - buttonWidth/2, y + buttonHeight, canvas.width/2 - buttonWidth/2, y + buttonHeight - cornerRadius);
          ctx.lineTo(canvas.width/2 - buttonWidth/2, y + cornerRadius);
          ctx.quadraticCurveTo(canvas.width/2 - buttonWidth/2, y, canvas.width/2 - buttonWidth/2 + cornerRadius, y);
          ctx.closePath();
          
          // Exactly matching settings menu style
          if (i === selectedDifficultyItem) {
            // Selected button styling
            ctx.fillStyle = "rgba(0, 150, 255, 0.4)";    // Brighter blue when selected
            ctx.strokeStyle = "rgba(0, 191, 255, 0.8)";  // Bright blue border
            ctx.lineWidth = 2;
          } else {
            // Unselected button styling
            ctx.fillStyle = "rgba(0, 100, 255, 0.2)";    // Darker blue when not selected
            ctx.strokeStyle = "rgba(0, 150, 255, 0.4)";  // Darker blue border
            ctx.lineWidth = 1;
          }
          
          ctx.fill();
          ctx.stroke();
          
          // Setting text just like settings menu
          ctx.textAlign = "center";
          ctx.font = "24px sans-serif";
          ctx.fillStyle = "white";  // Always white text for better visibility
          ctx.shadowBlur = 0;
          
          ctx.fillText(diff.name, canvas.width/2, y + 30);
          
          // Description text - slightly smaller and more ethereal
          ctx.shadowBlur = 0; // No glow on description text
          ctx.fillStyle = "rgba(180, 200, 240, 0.8)";
          ctx.font = "italic 14px sans-serif";
          ctx.fillText(diff.desc, canvas.width/2, y + diffSpacing - 25);
          
          // Display high score for this difficulty
          const diffValue = diff.value.toLowerCase();
          const highScore = highScores[diffValue] || 0;
          ctx.fillStyle = "rgba(255, 215, 0, 0.8)"; // Gold color
          ctx.font = "12px sans-serif";
          // Check if high score username is available
          if (highScores.usernames && highScores.usernames[diffValue]) {
            ctx.fillText(`High Score: ${highScore} (${highScores.usernames[diffValue]})`, canvas.width/2, y + diffSpacing - 5);
          } else {
            ctx.fillText("High Score: " + highScore, canvas.width/2, y + diffSpacing - 5);
          }
        }
        
        // Instructions with subtle backdrop
        const instructY = diffY + difficulties.length * diffSpacing + 30;
        const instructHeight = 60;
        
        // Draw semi-transparent backdrop for instructions
        ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
        ctx.fillRect(canvas.width/2 - 200, instructY - 15, 400, instructHeight);
        
        // Instruction text
        ctx.fillStyle = "rgba(200, 200, 220, 0.9)";
        ctx.font = "18px sans-serif";
        ctx.fillText("↑/↓: Select difficulty   ENTER: Start game", canvas.width / 2, instructY + 10);
        ctx.fillText("ESC: Return to main menu", canvas.width / 2, instructY + 40);
      }
      
      // Draw the Pause Menu
      function drawPauseMenu() {
        // Add semi-transparent overlay on the game
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw game elements with reduced opacity to show game is paused
        ctx.globalAlpha = 0.3;
        
        // Draw the ship in its current position
        drawSpaceship();
        
        // Reset opacity
        ctx.globalAlpha = 1.0;
        
        // Draw pause menu title
        ctx.fillStyle = "white";
        ctx.font = "42px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("GAME PAUSED", canvas.width / 2, canvas.height / 4);
        
        // Display current game status
        let difficultyName = "";
        switch(currentDifficulty) {
          case DIFFICULTY.EASY: difficultyName = "Easy"; break;
          case DIFFICULTY.MEDIUM: difficultyName = "Medium"; break;
          case DIFFICULTY.HARD: difficultyName = "Hard"; break;
          case DIFFICULTY.INFINITY: difficultyName = "Infinity"; break;
        }
        
        ctx.font = "18px sans-serif";
        ctx.fillStyle = "rgba(200, 200, 220, 0.9)";
        ctx.fillText(`Difficulty: ${difficultyName}   Score: ${score}`, canvas.width / 2, canvas.height / 4 + 40);
        
        // Show health status
        ctx.fillText(`Ship Health: ${spaceship.hitPoints}/5`, canvas.width / 2, canvas.height / 4 + 70);
        
        // Draw menu options
        const menuY = canvas.height / 2 - 20;
        const menuSpacing = 60;
        const buttonWidth = 220;
        const buttonHeight = 45;
        
        const menuOptions = [
          { text: "Resume Game", desc: "Return to the battle" },
          { text: "Settings", desc: "Adjust music and sound effects" },
          { text: "How to Play", desc: "Review game controls and objectives" },
          { text: "Exit to Main Menu", desc: "Your progress will be lost" }
        ];
        
        for (let i = 0; i < menuOptions.length; i++) {
          const option = menuOptions[i];
          const y = menuY + i * menuSpacing;
          
          // Button background - semi-transparent with rounded corners
          const cornerRadius = 8;
          
          // Create button path with rounded corners
          ctx.beginPath();
          ctx.moveTo(canvas.width/2 - buttonWidth/2 + cornerRadius, y);
          ctx.lineTo(canvas.width/2 + buttonWidth/2 - cornerRadius, y);
          ctx.quadraticCurveTo(canvas.width/2 + buttonWidth/2, y, canvas.width/2 + buttonWidth/2, y + cornerRadius);
          ctx.lineTo(canvas.width/2 + buttonWidth/2, y + buttonHeight - cornerRadius);
          ctx.quadraticCurveTo(canvas.width/2 + buttonWidth/2, y + buttonHeight, canvas.width/2 + buttonWidth/2 - cornerRadius, y + buttonHeight);
          ctx.lineTo(canvas.width/2 - buttonWidth/2 + cornerRadius, y + buttonHeight);
          ctx.quadraticCurveTo(canvas.width/2 - buttonWidth/2, y + buttonHeight, canvas.width/2 - buttonWidth/2, y + buttonHeight - cornerRadius);
          ctx.lineTo(canvas.width/2 - buttonWidth/2, y + cornerRadius);
          ctx.quadraticCurveTo(canvas.width/2 - buttonWidth/2, y, canvas.width/2 - buttonWidth/2 + cornerRadius, y);
          ctx.closePath();
          
          // Styles matching the settings menu
          if (i === 3) { // Exit option
            if (i === selectedPauseMenuItem) {
              // Selected exit button with red tint
              ctx.fillStyle = "rgba(255, 70, 70, 0.4)";    // Bright red when selected
              ctx.strokeStyle = "rgba(255, 70, 70, 0.8)";  // Bright red border
              ctx.lineWidth = 2;
            } else {
              // Unselected exit button with red tint
              ctx.fillStyle = "rgba(200, 50, 50, 0.2)";    // Darker red when not selected
              ctx.strokeStyle = "rgba(200, 50, 50, 0.4)";  // Darker red border
              ctx.lineWidth = 1;
            }
          } else {
            // Normal menu options matching settings style
            if (i === selectedPauseMenuItem) {
              // Selected button styling
              ctx.fillStyle = "rgba(0, 150, 255, 0.4)";    // Brighter blue when selected
              ctx.strokeStyle = "rgba(0, 191, 255, 0.8)";  // Bright blue border
              ctx.lineWidth = 2;
            } else {
              // Unselected button styling
              ctx.fillStyle = "rgba(0, 100, 255, 0.2)";    // Darker blue when not selected
              ctx.strokeStyle = "rgba(0, 150, 255, 0.4)";  // Darker blue border
              ctx.lineWidth = 1;
            }
          }
          
          ctx.fill();
          ctx.stroke();
          
          // Setting text just like settings menu - clean white
          ctx.textAlign = "center";
          ctx.font = "22px sans-serif";
          ctx.fillStyle = "white";  // Always white text for better visibility
          ctx.shadowBlur = 0;
          
          ctx.fillText(option.text, canvas.width/2, y + 28);
          
          // Description text
          ctx.fillStyle = "rgba(200, 200, 220, 0.8)";
          ctx.font = "italic 14px sans-serif";
          ctx.fillText(option.desc, canvas.width/2, y + menuSpacing - 15);
        }
        
        // Instructions with subtle backdrop
        const instructY = canvas.height - 70;
        const instructHeight = 50;
        
        // Draw semi-transparent backdrop for instructions
        ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
        ctx.fillRect(0, instructY, canvas.width, instructHeight);
        
        // Instruction text
        ctx.fillStyle = "rgba(200, 200, 220, 0.9)";
        ctx.font = "18px sans-serif";
        ctx.fillText("↑/↓: Navigate menu   ENTER: Select   ESC: Resume game", canvas.width / 2, instructY + 30);
      }
      
      // Draw the Ship Selection screen
      // Preload flag to check if ships have been preloaded
      let shipsPreloaded = false;
      
      // Preload all ship assets to prevent freezing on first navigation
      function preloadShipAssets() {
        if (shipsPreloaded) return; // Only preload once
        
        console.log("Preloading ship assets...");
        
        // Create temporary ships of each type to initialize any required assets
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        
        // Preload each ship type
        [SHIP_TYPE.DEFAULT, SHIP_TYPE.LASER, SHIP_TYPE.MISSILE].forEach(shipType => {
          const tempShip = {
            x: 0,
            y: 0,
            size: SHIP_SIZE,
            angle: -Math.PI/2,
            type: shipType
          };
          
          // Save original ship
          const originalShip = spaceship;
          // Use temp ship
          spaceship = tempShip;
          
          // Draw ship to initialize/load any assets
          switch(shipType) {
            case SHIP_TYPE.DEFAULT:
              drawDefaultShip(tempCtx.createLinearGradient(SHIP_SIZE, 0, -SHIP_SIZE, 0));
              break;
            case SHIP_TYPE.LASER:
              drawLaserShip(tempCtx.createLinearGradient(SHIP_SIZE, 0, -SHIP_SIZE, 0));
              break;
            case SHIP_TYPE.MISSILE:
              drawMissileShip(tempCtx.createLinearGradient(SHIP_SIZE, 0, -SHIP_SIZE, 0));
              break;
          }
          
          // Restore original ship
          spaceship = originalShip;
        });
        
        shipsPreloaded = true;
        console.log("Ship assets preloaded");
      }
      
      function drawShipSelect() {
        // Preload all ship assets on first draw to prevent freezing
        preloadShipAssets();
        
        ctx.fillStyle = "white";
        ctx.font = "36px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Select Your Spaceship", canvas.width / 2, canvas.height / 5);
        
        // Define ship stats
        const shipStats = {
          [SHIP_TYPE.DEFAULT]: {
            speed: 6,     // Medium speed
            power: 5,     // Medium firepower
            defense: 7,   // Good defense
            special: 8    // Strong special ability
          },
          [SHIP_TYPE.LASER]: {
            speed: 4,     // Slow
            power: 10,    // Maximum firepower
            defense: 8,   // Strong defense
            special: 9    // Very strong special
          },
          [SHIP_TYPE.MISSILE]: {
            speed: 9,     // Very fast
            power: 7,     // Good firepower
            defense: 5,   // Medium defense
            special: 7    // Good special ability
          }
        };
        
        // Ships and their descriptions
        const ships = [
          {
            type: SHIP_TYPE.DEFAULT,
            name: "Nova Striker",
            desc: "Balanced ship with EMP weapon",
            features: ["EMP blast (F key)", "Slows all nearby comets", "Balanced maneuverability", "Twin blasters"]
          },
          {
            type: SHIP_TYPE.LASER,
            name: "Heavy Cruiser",
            desc: "Slow but powerful laser cannon",
            features: ["Powerful laser beam (F key)", "3-second beam duration", "10-second cooldown"]
          },
          {
            type: SHIP_TYPE.MISSILE,
            name: "Stealth Interceptor",
            desc: "Fast with 7-missile spread",
            features: ["Faster movement", "7-missile volley (F key)", "Spread pattern missiles", "20x damage per missile", "1-second cooldown"]
          }
        ];
        
        // We'll only show the currently selected ship
        const currentShip = ships[selectedShipMenuItem];
        const currentStats = shipStats[currentShip.type];
        
        // Layout for a single card
        const centerX = canvas.width / 2;
        const cardWidth = canvas.width * 0.4;  // Card width
        const cardHeight = canvas.height * 0.55; // Card height
        const cardY = canvas.height * 0.3;
        
        // Draw main card panel with 80s anime tech style
        ctx.save();
        
        // Intense glow effect
        ctx.shadowColor = "rgba(0, 220, 255, 0.9)";
        ctx.shadowBlur = 20;
        
        // Dark tech panel background
        ctx.fillStyle = "rgba(5, 15, 35, 0.85)";
        ctx.strokeStyle = "rgba(0, 240, 255, 0.9)";
        ctx.lineWidth = 3;
        
        // Draw card background
        roundRect(ctx, centerX - cardWidth/2, cardY, cardWidth, cardHeight, 15);
        
        // Draw tech grid pattern
        ctx.lineWidth = 0.5;
        ctx.strokeStyle = "rgba(0, 150, 255, 0.25)";
        
        // Horizontal grid lines
        for (let y = cardY + 50; y < cardY + cardHeight; y += 20) {
            ctx.beginPath();
            ctx.moveTo(centerX - cardWidth/2, y);
            ctx.lineTo(centerX + cardWidth/2, y);
            ctx.stroke();
        }
        
        // Vertical grid lines
        for (let x = centerX - cardWidth/2; x < centerX + cardWidth/2; x += 20) {
            ctx.beginPath();
            ctx.moveTo(x, cardY + 50);
            ctx.lineTo(x, cardY + cardHeight);
            ctx.stroke();
        }
        
        // Scan line effect - moving line across the card
        const scanLine = (performance.now() / 40) % cardHeight;
        ctx.fillStyle = "rgba(0, 220, 255, 0.15)";
        ctx.fillRect(centerX - cardWidth/2, cardY + scanLine, cardWidth, 3);
        
        // Add tech corner accents - very 80s anime mecha style
        ctx.strokeStyle = "rgba(0, 240, 255, 0.9)";
        ctx.lineWidth = 2;
        const cornerSize = 20;
        
        // Top-left corner
        ctx.beginPath();
        ctx.moveTo(centerX - cardWidth/2 + 5, cardY + 5);
        ctx.lineTo(centerX - cardWidth/2 + 5, cardY + 5 + cornerSize);
        ctx.moveTo(centerX - cardWidth/2 + 5, cardY + 5);
        ctx.lineTo(centerX - cardWidth/2 + 5 + cornerSize, cardY + 5);
        ctx.stroke();
        
        // Top-right corner
        ctx.beginPath();
        ctx.moveTo(centerX + cardWidth/2 - 5, cardY + 5);
        ctx.lineTo(centerX + cardWidth/2 - 5, cardY + 5 + cornerSize);
        ctx.moveTo(centerX + cardWidth/2 - 5, cardY + 5);
        ctx.lineTo(centerX + cardWidth/2 - 5 - cornerSize, cardY + 5);
        ctx.stroke();
        
        // Bottom-left corner
        ctx.beginPath();
        ctx.moveTo(centerX - cardWidth/2 + 5, cardY + cardHeight - 5);
        ctx.lineTo(centerX - cardWidth/2 + 5, cardY + cardHeight - 5 - cornerSize);
        ctx.moveTo(centerX - cardWidth/2 + 5, cardY + cardHeight - 5);
        ctx.lineTo(centerX - cardWidth/2 + 5 + cornerSize, cardY + cardHeight - 5);
        ctx.stroke();
        
        // Bottom-right corner
        ctx.beginPath();
        ctx.moveTo(centerX + cardWidth/2 - 5, cardY + cardHeight - 5);
        ctx.lineTo(centerX + cardWidth/2 - 5, cardY + cardHeight - 5 - cornerSize);
        ctx.moveTo(centerX + cardWidth/2 - 5, cardY + cardHeight - 5);
        ctx.lineTo(centerX + cardWidth/2 - 5 - cornerSize, cardY + cardHeight - 5);
        ctx.stroke();
        
        // Title header bar with tech pattern
        const headerHeight = 50;
        const headerGradient = ctx.createLinearGradient(0, cardY, 0, cardY + headerHeight);
        headerGradient.addColorStop(0, "rgba(0, 70, 130, 0.9)");
        headerGradient.addColorStop(1, "rgba(0, 40, 100, 0.8)");
        ctx.fillStyle = headerGradient;
        ctx.fillRect(centerX - cardWidth/2, cardY, cardWidth, headerHeight);
        
        // Tech pattern in header
        ctx.strokeStyle = "rgba(0, 220, 255, 0.6)";
        ctx.lineWidth = 1;
        
        // Left side lines
        for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.moveTo(centerX - cardWidth/2, cardY + 12 + i * 10);
            ctx.lineTo(centerX - cardWidth/2 + 80, cardY + 12 + i * 10);
            ctx.stroke();
        }
        
        // Right side lines
        for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.moveTo(centerX + cardWidth/2, cardY + 12 + i * 10);
            ctx.lineTo(centerX + cardWidth/2 - 80, cardY + 12 + i * 10);
            ctx.stroke();
        }
        
        // Ship title with retro tech font style
        ctx.textAlign = "center";
        
        // Shadow glow effect
        ctx.shadowColor = "rgba(0, 255, 255, 0.9)";
        ctx.shadowBlur = 10;
        
        // Main text in bright cyan
        ctx.fillStyle = "rgb(0, 255, 255)";
        ctx.font = "bold 28px monospace";
        ctx.fillText(currentShip.name, centerX, cardY + 35);
        
        // Subtle stroke for tech effect
        ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
        ctx.lineWidth = 0.5;
        ctx.strokeText(currentShip.name, centerX, cardY + 35);
        
        // Ship visualization
        ctx.save();
        ctx.translate(centerX, cardY + cardHeight * 0.35);
        
        // Make ship hover up and down slightly
        const hoverOffset = Math.sin(performance.now() / 500) * 5;
        ctx.translate(0, hoverOffset);
        
        // Scale the ship to fit nicely (larger than before)
        const shipScaleFactor = 1.8;
        ctx.scale(shipScaleFactor, shipScaleFactor);
        
        // Create temporary ship object to draw
        const tempShip = {
          x: 0,
          y: 0,
          size: SHIP_SIZE,
          angle: -Math.PI/2,  // Face upward
          type: currentShip.type
        };
        
        // Save the original spaceship object and replace it temporarily
        const originalShip = spaceship;
        spaceship = tempShip;
        
        // Draw the ship
        switch(currentShip.type) {
          case SHIP_TYPE.DEFAULT:
            drawDefaultShip(ctx.createLinearGradient(SHIP_SIZE, 0, -SHIP_SIZE, 0));
            break;
          case SHIP_TYPE.LASER:
            drawLaserShip(ctx.createLinearGradient(SHIP_SIZE, 0, -SHIP_SIZE, 0));
            break;
          case SHIP_TYPE.MISSILE:
            drawMissileShip(ctx.createLinearGradient(SHIP_SIZE, 0, -SHIP_SIZE, 0));
            break;
        }
        
        // Restore the original spaceship object
        spaceship = originalShip;
        ctx.restore();
        
        // Ship description with tech style
        ctx.textAlign = "center";
        
        // Tech style header box for description
        const descBoxY = cardY + cardHeight * 0.52;
        const descBoxHeight = 25;
        ctx.fillStyle = "rgba(0, 30, 80, 0.7)";
        ctx.fillRect(centerX - cardWidth * 0.4, descBoxY, cardWidth * 0.8, descBoxHeight);
        
        // Tech lines on sides
        ctx.strokeStyle = "rgba(0, 180, 255, 0.6)";
        ctx.lineWidth = 1;
        
        // Left line
        ctx.beginPath();
        ctx.moveTo(centerX - cardWidth * 0.4, descBoxY);
        ctx.lineTo(centerX - cardWidth * 0.4 - 10, descBoxY + descBoxHeight/2);
        ctx.lineTo(centerX - cardWidth * 0.4, descBoxY + descBoxHeight);
        ctx.stroke();
        
        // Right line
        ctx.beginPath();
        ctx.moveTo(centerX + cardWidth * 0.4, descBoxY);
        ctx.lineTo(centerX + cardWidth * 0.4 + 10, descBoxY + descBoxHeight/2);
        ctx.lineTo(centerX + cardWidth * 0.4, descBoxY + descBoxHeight);
        ctx.stroke();
        
        // Description text
        ctx.fillStyle = "rgba(255, 255, 255, 0.9)";
        ctx.font = "italic 16px sans-serif";
        ctx.fillText(currentShip.desc, centerX, descBoxY + 18);
        
        // Draw 80s anime-style stat bars with high-tech look
        // Reset shadow for stats
        ctx.shadowColor = "transparent";
        ctx.shadowBlur = 0;
        
        const statsStartY = cardY + cardHeight * 0.63;
        const statsWidth = cardWidth * 0.7;
        const statsLeftX = centerX - statsWidth/2;
        const barHeight = 16;
        const barSpacing = 28;
        
        // Stats to display
        const stats = [
          { name: "SPEED", value: currentStats.speed },
          { name: "POWER", value: currentStats.power },
          { name: "DEFENSE", value: currentStats.defense },
          { name: "SPECIAL", value: currentStats.special }
        ];
        
        // Draw "SPECS" header
        ctx.fillStyle = "rgb(255, 220, 50)";  // Bright yellow/gold title
        ctx.font = "bold 16px monospace";
        ctx.textAlign = "left";
        ctx.fillText("SPECIFICATIONS:", statsLeftX, statsStartY - 15);
        
        // Draw tech decorative line
        ctx.strokeStyle = "rgb(255, 220, 50)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(statsLeftX, statsStartY - 10);
        ctx.lineTo(statsLeftX + 140, statsStartY - 10);
        ctx.stroke();
        
        // Draw each stat bar with 80s tech style
        let currentY = statsStartY;
        
        ctx.font = "bold 14px monospace";  // Use monospace for tech look
        ctx.textAlign = "right";  // Change to right alignment for consistent width
        
        // Set a fixed position for all labels to ensure alignment
        const labelX = statsLeftX + 75;
        
        for (const stat of stats) {
          // Label with tech style
          ctx.fillStyle = "rgb(0, 255, 255)";  // Bright cyan for labels
          ctx.fillText(stat.name, labelX, currentY + 12);
          
          // Black tech bar border with inner glow
          ctx.fillStyle = "rgb(0, 0, 0)";
          const barX = statsLeftX + 80;
          const barWidth = statsWidth - 80;
          ctx.fillRect(barX - 2, currentY - 2, barWidth + 4, barHeight + 4);
          
          // Dark grid background
          ctx.fillStyle = "rgb(10, 20, 40)";
          ctx.fillRect(barX, currentY, barWidth, barHeight);
          
          // Draw grid lines within bar
          ctx.strokeStyle = "rgba(0, 100, 150, 0.5)";
          ctx.lineWidth = 0.5;
          
          for (let i = 1; i < 10; i++) {
            const gridX = barX + i * (barWidth / 10);
            ctx.beginPath();
            ctx.moveTo(gridX, currentY);
            ctx.lineTo(gridX, currentY + barHeight);
            ctx.stroke();
          }
          
          // Draw filled bar segments with 3D effect
          const segmentWidth = barWidth / 10; // 10 segments total
          
          for (let i = 0; i < stat.value; i++) {
            // Color gradient from blue to yellow to red
            let segmentColor;
            if (i < 3) {
              // Blue segments for low values
              segmentColor = "rgb(0, 150, 255)";
            } else if (i < 7) {
              // Yellow/green segments for mid values
              segmentColor = `rgb(${(i-3)*50 + 100}, 255, ${255 - (i-3)*60})`;
            } else {
              // Red/orange segments for high values
              segmentColor = `rgb(255, ${150 - (i-7)*50}, 0)`;
            }
            
            // Draw segment with 3D effect
            ctx.fillStyle = segmentColor;
            ctx.fillRect(barX + i * segmentWidth, currentY, segmentWidth - 1, barHeight);
            
            // Add highlight to top of segment for 3D look
            ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
            ctx.fillRect(barX + i * segmentWidth, currentY, segmentWidth - 1, 2);
            
            // Add shadow to bottom of segment
            ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
            ctx.fillRect(barX + i * segmentWidth, currentY + barHeight - 2, segmentWidth - 1, 2);
          }
          
          // Add pulsing effect on the last filled segment
          if (stat.value > 0) {
            const pulseOpacity = 0.5 + 0.5 * Math.sin(performance.now() / 200);
            const lastSegmentX = barX + (stat.value - 1) * segmentWidth;
            
            ctx.fillStyle = `rgba(255, 255, 255, ${pulseOpacity})`;
            ctx.fillRect(lastSegmentX, currentY, 2, barHeight);
          }
          
          // Add value number at the end of the bar
          ctx.fillStyle = "rgb(255, 255, 255)";
          ctx.textAlign = "right";
          ctx.font = "bold 12px monospace";
          ctx.fillText(stat.value.toString().padStart(2, "0"), barX + barWidth + 20, currentY + 12);
          
          currentY += barSpacing;
        }
        
        // 80s anime style navigation arrows
        const arrowY = cardY + cardHeight * 0.45;
        const pulseOpacity = 0.5 + 0.5 * Math.sin(performance.now() / 300);
        
        // Left arrow
        ctx.save();
        ctx.shadowColor = "rgba(0, 200, 255, 0.8)";
        ctx.shadowBlur = 10;
        
        // Arrow with tech polygon style
        ctx.beginPath();
        ctx.moveTo(centerX - cardWidth - 20, arrowY);
        ctx.lineTo(centerX - cardWidth - 40, arrowY - 10);
        ctx.lineTo(centerX - cardWidth - 50, arrowY);
        ctx.lineTo(centerX - cardWidth - 40, arrowY + 10);
        ctx.closePath();
        
        // Create gradient fill for arrow
        const leftGradient = ctx.createLinearGradient(
            centerX - cardWidth - 50, arrowY,
            centerX - cardWidth - 20, arrowY
        );
        leftGradient.addColorStop(0, `rgba(0, 100, 255, ${pulseOpacity})`);
        leftGradient.addColorStop(1, `rgba(0, 200, 255, ${pulseOpacity})`);
        ctx.fillStyle = leftGradient;
        ctx.fill();
        
        // Add tech accent lines
        ctx.strokeStyle = "rgba(255, 255, 255, 0.7)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(centerX - cardWidth - 60, arrowY - 20);
        ctx.lineTo(centerX - cardWidth - 30, arrowY - 20);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(centerX - cardWidth - 60, arrowY + 20);
        ctx.lineTo(centerX - cardWidth - 30, arrowY + 20);
        ctx.stroke();
        
        // Right arrow with tech polygon style
        ctx.beginPath();
        ctx.moveTo(centerX + cardWidth + 20, arrowY);
        ctx.lineTo(centerX + cardWidth + 40, arrowY - 10);
        ctx.lineTo(centerX + cardWidth + 50, arrowY);
        ctx.lineTo(centerX + cardWidth + 40, arrowY + 10);
        ctx.closePath();
        
        // Create gradient fill for arrow
        const rightGradient = ctx.createLinearGradient(
            centerX + cardWidth + 20, arrowY,
            centerX + cardWidth + 50, arrowY
        );
        rightGradient.addColorStop(0, `rgba(0, 200, 255, ${pulseOpacity})`);
        rightGradient.addColorStop(1, `rgba(0, 100, 255, ${pulseOpacity})`);
        ctx.fillStyle = rightGradient;
        ctx.fill();
        
        // Add tech accent lines
        ctx.beginPath();
        ctx.moveTo(centerX + cardWidth + 30, arrowY - 20);
        ctx.lineTo(centerX + cardWidth + 60, arrowY - 20);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(centerX + cardWidth + 30, arrowY + 20);
        ctx.lineTo(centerX + cardWidth + 60, arrowY + 20);
        ctx.stroke();
        
        ctx.restore();
        
        // Prev/next ship names with tech frame
        const prevShip = ships[(selectedShipMenuItem - 1 + ships.length) % ships.length];
        const nextShip = ships[(selectedShipMenuItem + 1) % ships.length];
        
        // Left ship name with tech frame
        const nameBoxWidth = 100;
        const nameBoxHeight = 25;
        const nameBoxY = arrowY + 30;
        
        // Left name box
        ctx.fillStyle = "rgba(0, 40, 80, 0.6)";
        ctx.fillRect(centerX - cardWidth - 60 - nameBoxWidth/2, nameBoxY, nameBoxWidth, nameBoxHeight);
        
        // Tech corner accents
        ctx.strokeStyle = "rgba(0, 150, 255, 0.7)";
        ctx.lineWidth = 1;
        
        // Top-left
        ctx.beginPath();
        ctx.moveTo(centerX - cardWidth - 60 - nameBoxWidth/2, nameBoxY);
        ctx.lineTo(centerX - cardWidth - 60 - nameBoxWidth/2 + 10, nameBoxY);
        ctx.moveTo(centerX - cardWidth - 60 - nameBoxWidth/2, nameBoxY);
        ctx.lineTo(centerX - cardWidth - 60 - nameBoxWidth/2, nameBoxY + 10);
        ctx.stroke();
        
        // Bottom-right
        ctx.beginPath();
        ctx.moveTo(centerX - cardWidth - 60 + nameBoxWidth/2, nameBoxY + nameBoxHeight);
        ctx.lineTo(centerX - cardWidth - 60 + nameBoxWidth/2 - 10, nameBoxY + nameBoxHeight);
        ctx.moveTo(centerX - cardWidth - 60 + nameBoxWidth/2, nameBoxY + nameBoxHeight);
        ctx.lineTo(centerX - cardWidth - 60 + nameBoxWidth/2, nameBoxY + nameBoxHeight - 10);
        ctx.stroke();
        
        // Left name text
        ctx.font = "12px monospace";
        ctx.fillStyle = "rgba(170, 220, 255, 0.9)";
        ctx.textAlign = "center";
        ctx.fillText("< " + prevShip.name, centerX - cardWidth - 60, nameBoxY + 17);
        
        // Right name box
        ctx.fillStyle = "rgba(0, 40, 80, 0.6)";
        ctx.fillRect(centerX + cardWidth + 60 - nameBoxWidth/2, nameBoxY, nameBoxWidth, nameBoxHeight);
        
        // Tech corner accents
        // Top-right
        ctx.beginPath();
        ctx.moveTo(centerX + cardWidth + 60 + nameBoxWidth/2, nameBoxY);
        ctx.lineTo(centerX + cardWidth + 60 + nameBoxWidth/2 - 10, nameBoxY);
        ctx.moveTo(centerX + cardWidth + 60 + nameBoxWidth/2, nameBoxY);
        ctx.lineTo(centerX + cardWidth + 60 + nameBoxWidth/2, nameBoxY + 10);
        ctx.stroke();
        
        // Bottom-left
        ctx.beginPath();
        ctx.moveTo(centerX + cardWidth + 60 - nameBoxWidth/2, nameBoxY + nameBoxHeight);
        ctx.lineTo(centerX + cardWidth + 60 - nameBoxWidth/2 + 10, nameBoxY + nameBoxHeight);
        ctx.moveTo(centerX + cardWidth + 60 - nameBoxWidth/2, nameBoxY + nameBoxHeight);
        ctx.lineTo(centerX + cardWidth + 60 - nameBoxWidth/2, nameBoxY + nameBoxHeight - 10);
        ctx.stroke();
        
        // Right name text
        ctx.fillStyle = "rgba(170, 220, 255, 0.9)";
        ctx.textAlign = "center";
        ctx.fillText(nextShip.name + " >", centerX + cardWidth + 60, nameBoxY + 17);
        
        // 80s-style tech indicators for pages
        ctx.textAlign = "center";
        const indicatorY = cardY + cardHeight + 15;
        const spacing = 30;
        const indicWidth = 20;
        const indicHeight = 6;
        
        // Background bar
        ctx.fillStyle = "rgba(0, 40, 80, 0.5)";
        ctx.fillRect(centerX - spacing * 2, indicatorY, spacing * 4, indicHeight);
        
        // Draw indicator for each ship
        for (let i = 0; i < ships.length; i++) {
            const x = centerX + (i - 1) * spacing;
            
            if (i === selectedShipMenuItem) {
                // Selected indicator with tech glow
                ctx.save();
                ctx.shadowColor = "rgba(0, 255, 255, 0.9)";
                ctx.shadowBlur = 8;
                ctx.fillStyle = "rgb(0, 240, 255)";
                ctx.fillRect(x - indicWidth/2, indicatorY, indicWidth, indicHeight);
                
                // Scanning animation
                const scanPos = (performance.now() / 20) % indicWidth;
                ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
                ctx.fillRect(x - indicWidth/2 + scanPos, indicatorY, 2, indicHeight);
                ctx.restore();
            } else {
                // Unselected indicators
                ctx.fillStyle = "rgba(30, 90, 150, 0.5)";
                ctx.fillRect(x - indicWidth/2, indicatorY, indicWidth, indicHeight);
                
                // Tech line
                ctx.strokeStyle = "rgba(100, 180, 255, 0.6)";
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, indicatorY);
                ctx.lineTo(x, indicatorY + indicHeight);
                ctx.stroke();
            }
        }
        
        ctx.restore();
        
        // Instructions with subtle backdrop
        const instructY = cardY + cardHeight + 40;
        
        // Draw semi-transparent backdrop for instructions
        ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
        ctx.fillRect(centerX - 250, instructY - 15, 500, 80);
        
        // Navigation instructions
        ctx.fillStyle = "rgba(200, 200, 220, 0.9)";
        ctx.font = "18px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("◄ ► : Navigate between ships", centerX, instructY + 15);
        ctx.fillText("ENTER: Select ship and start game", centerX, instructY + 45);
        ctx.fillText("ESC: Return to difficulty selection", centerX, instructY + 75);
      }
      
      // Draw the Settings screen
      function drawSettings() {
        ctx.fillStyle = "white";
        ctx.font = "36px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Settings", canvas.width / 2, canvas.height / 4);
        
        const settingsY = canvas.height / 2 - 60;
        const settingsSpacing = 60;
        const buttonWidth = 350;  // Width for "Sound Effects"
        const buttonHeight = 40;
        
        const settings = [
          { 
            text: "Music", 
            status: musicEnabled ? "ON" : "OFF" 
          },
          { 
            text: "Sound Effects", 
            status: soundEnabled ? "ON" : "OFF" 
          }
        ];
        
        for (let i = 0; i < settings.length; i++) {
          const setting = settings[i];
          const y = settingsY + i * settingsSpacing;
          
          // Button background
          const cornerRadius = 8;
          
          // Create button path with rounded corners
          ctx.beginPath();
          ctx.moveTo(canvas.width/2 - buttonWidth/2 + cornerRadius, y);
          ctx.lineTo(canvas.width/2 + buttonWidth/2 - cornerRadius, y);
          ctx.quadraticCurveTo(canvas.width/2 + buttonWidth/2, y, canvas.width/2 + buttonWidth/2, y + cornerRadius);
          ctx.lineTo(canvas.width/2 + buttonWidth/2, y + buttonHeight - cornerRadius);
          ctx.quadraticCurveTo(canvas.width/2 + buttonWidth/2, y + buttonHeight, canvas.width/2 + buttonWidth/2 - cornerRadius, y + buttonHeight);
          ctx.lineTo(canvas.width/2 - buttonWidth/2 + cornerRadius, y + buttonHeight);
          ctx.quadraticCurveTo(canvas.width/2 - buttonWidth/2, y + buttonHeight, canvas.width/2 - buttonWidth/2, y + buttonHeight - cornerRadius);
          ctx.lineTo(canvas.width/2 - buttonWidth/2, y + cornerRadius);
          ctx.quadraticCurveTo(canvas.width/2 - buttonWidth/2, y, canvas.width/2 - buttonWidth/2 + cornerRadius, y);
          ctx.closePath();
          
          // Fill with different colors based on selection
          if (i === selectedSettingsItem) {
            ctx.fillStyle = "rgba(0, 150, 255, 0.4)";    // Brighter blue when selected
            ctx.strokeStyle = "rgba(0, 191, 255, 0.8)";  // Bright blue border
            ctx.lineWidth = 2;
          } else {
            ctx.fillStyle = "rgba(0, 100, 255, 0.2)";    // Darker blue when not selected
            ctx.strokeStyle = "rgba(0, 150, 255, 0.4)";  // Darker blue border
            ctx.lineWidth = 1;
          }
          ctx.fill();
          ctx.stroke();
          
          // Setting text and status with better contrast
          ctx.fillStyle = "white";  // Always white text for better visibility
          ctx.font = "20px sans-serif";
          ctx.textAlign = "right";
          ctx.fillText(setting.text, canvas.width/2 - 20, y + 25);
          
          // ON/OFF text
          ctx.textAlign = "left";
          ctx.fillText(setting.status, canvas.width/2 + 20, y + 25);
        }
        
        // Instructions
        const instructY = settingsY + settings.length * settingsSpacing + 30;
        ctx.fillStyle = "rgba(200, 200, 220, 0.9)";
        ctx.font = "18px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("↑/↓: Select option   ENTER: Toggle setting", canvas.width/2, instructY + 10);
        ctx.fillText("ESC: Return to main menu", canvas.width/2, instructY + 40);
      }
      
      // Draw the How to Play screen
      function drawHowToPlay() {
        ctx.fillStyle = "white";
        ctx.font = "36px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("How to Play", canvas.width / 2, canvas.height / 6);
        
        const instructionsY = canvas.height / 4;
        const lineHeight = 30;
        
        // Game instructions
        ctx.font = "18px sans-serif";
        ctx.textAlign = "left";
        const instructions = [
          "Controls:",
          "• Arrow Keys: Move your spaceship",
          "• Space: Quick brake",
          "",
          "Objectives:",
          "• Destroy comets by shooting them",
          "• Avoid collisions with comets",
          "• Collect power-ups to enhance your ship",
          "",
          "Power-ups:",
          "• Red (HP): Restores health",
          "• Blue (3X): Triple shot - fires 3x bullets",
          "  (Triple shot power-ups appear before big comets)",
          "",
          "Enemy Types:",
          "• Regular Comets: Break into smaller pieces",
          "• Big Comets: Require multiple hits to destroy"
        ];
        
        ctx.fillStyle = "#CCC";
        for (let i = 0; i < instructions.length; i++) {
          const line = instructions[i];
          const x = canvas.width / 2 - 200;
          const y = instructionsY + i * lineHeight;
          
          if (line === "") continue; // Skip empty lines
          
          if (line.endsWith(":")) {
            // Section headers
            ctx.fillStyle = "#FFD700"; // Gold
            ctx.font = "bold 20px sans-serif";
          } else {
            // Regular instructions
            ctx.fillStyle = "#CCC";
            ctx.font = "18px sans-serif";
          }
          
          ctx.fillText(line, x, y);
        }
        
        // Instructions with subtle backdrop at bottom
        const instructY = canvas.height - 70;
        const instructHeight = 50;
        
        // Draw semi-transparent backdrop for instructions
        ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
        ctx.fillRect(0, instructY, canvas.width, instructHeight);
        
        // Return instruction
        ctx.fillStyle = "rgba(200, 200, 220, 0.9)";
        ctx.textAlign = "center";
        ctx.font = "18px sans-serif";
        ctx.fillText("ESC: Return to main menu", canvas.width / 2, instructY + 30);
      }
      
      // For future scoreboard implementation
      // (currently using simplified placeholder)
      
      // Draw the Scoreboard screen with high scores from Firebase
      function drawHighScores() {
        // Title
        ctx.fillStyle = "white";
        ctx.font = "36px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("High Scores", canvas.width/2, 80);

        // Table layout constants
        const startY = 150;
        const rowHeight = 40;
        const colWidth = 160;
        const tableWidth = colWidth * 5; // 5 columns: Player + 4 difficulties
        const tableX = (canvas.width - tableWidth) / 2;

        // Draw table headers
        ctx.font = "bold 20px sans-serif";
        ctx.fillStyle = "#00BFFF"; // Deep sky blue for headers
        
        // Define and draw column headers
        const columns = [
            { title: "Player", x: tableX },
            { title: "Easy", x: tableX + colWidth },
            { title: "Medium", x: tableX + colWidth * 2 },
            { title: "Hard", x: tableX + colWidth * 3 },
            { title: "Infinity", x: tableX + colWidth * 4 }
        ];

        // Draw header background
        ctx.fillStyle = "rgba(0, 30, 60, 0.8)";
        ctx.fillRect(tableX - 10, startY - 30, tableWidth + 20, 40);

        // Draw column titles
        ctx.fillStyle = "#00BFFF";
        columns.forEach(col => {
            ctx.textAlign = "center";
            ctx.fillText(col.title, col.x + colWidth/2, startY);
        });

        // Fetch and display scores using getAllPlayerScores function
        getAllPlayerScores()
            .then(playerScores => {
                let y = startY + rowHeight;
                let rowCount = 0;

                // Draw each row
                playerScores.forEach((player, index) => {
                    // Alternate row backgrounds
                    if (index % 2 === 0) {
                        ctx.fillStyle = "rgba(0, 40, 80, 0.4)";
                    } else {
                        ctx.fillStyle = "rgba(0, 60, 120, 0.4)";
                    }
                    ctx.fillRect(tableX - 10, y - 25, tableWidth + 20, rowHeight);

                    // Draw user data
                    ctx.textAlign = "center";
                    ctx.font = "18px sans-serif";

                    // Username
                    ctx.fillStyle = "white";
                    ctx.fillText(player.username, tableX + colWidth/2, y);

                    // Scores for each difficulty
                    ["easy", "medium", "hard", "infinity"].forEach((diff, i) => {
                        const score = player.scores[diff] || "---";
                        ctx.fillStyle = score === 0 || score === "---" ? "#666" : "#FFD700";
                        ctx.fillText(score, tableX + colWidth * (i + 1.5), y);
                    });

                    y += rowHeight;
                    rowCount++;
                });

                // If no scores found
                if (rowCount === 0) {
                    ctx.fillStyle = "white";
                    ctx.font = "20px sans-serif";
                    ctx.textAlign = "center";
                    ctx.fillText("No scores recorded yet!", canvas.width/2, startY + rowHeight);
                }
            })
            .catch(error => {
                console.error("Error fetching scores:", error);
                ctx.fillStyle = "red";
                ctx.textAlign = "center";
                ctx.fillText("Error loading scores", canvas.width/2, startY + rowHeight);
            });

        // Instructions at bottom
        ctx.fillStyle = "rgba(200, 200, 220, 0.9)";
        ctx.font = "18px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Press ESC to return to main menu", canvas.width/2, canvas.height - 40);
      }
      
      // Main draw function
      function draw() {
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // If in loading state, don't render game elements
        if (isLoading || gameState === "loading") {
          return;
        }

        // For menu screens, use the dedicated menu background
        const isMenuScreen = 
          gameState === GAME_STATE.MAIN_MENU || 
          gameState === GAME_STATE.DIFFICULTY_SELECT ||
          gameState === GAME_STATE.SETTINGS ||
          gameState === GAME_STATE.HOW_TO_PLAY ||
          gameState === GAME_STATE.HIGH_SCORES;
          
        if (isMenuScreen) {
          // Use the menu background instead of the game background
          renderMenuBackground();
        } else {
          // For gameplay and other screens, use the regular background
          drawStarfield(ctx);
          drawPulsar(ctx);
          drawCronos(ctx);
        }
        
        // Draw the appropriate screen based on game state
        switch(gameState) {
          case GAME_STATE.MAIN_MENU:
            drawMainMenu();
            return;
          case GAME_STATE.DIFFICULTY_SELECT:
            drawDifficultySelect();
            return;
          case GAME_STATE.SHIP_SELECT:
            drawShipSelect();
            return;
          case GAME_STATE.SETTINGS:
            drawSettings();
            return;
          case GAME_STATE.HOW_TO_PLAY:
            drawHowToPlay();
            return;
          case GAME_STATE.HIGH_SCORES:
            drawHighScores();
            return;
          case GAME_STATE.PAUSE_MENU:
            drawPauseMenu();
            return;
        }
        if (gameState === GAME_STATE.WIN) {
          // draw any leftover explosion particles
          for (let p of smallExplosionParticles) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fillStyle = p.color;
            ctx.fill();
          }
          ctx.fillStyle = "lime";
          ctx.font = "48px sans-serif";
          ctx.textAlign = "center";
          ctx.fillText("VICTORY!", canvas.width / 2, canvas.height / 2 - 50);
          
          // Show difficulty
          let difficultyName = "";
          switch(currentDifficulty) {
            case DIFFICULTY.EASY: difficultyName = "Easy"; break;
            case DIFFICULTY.MEDIUM: difficultyName = "Medium"; break;
            case DIFFICULTY.HARD: difficultyName = "Hard"; break;
          }
          
          ctx.font = "24px sans-serif";
          ctx.fillText(`Mode: ${difficultyName}`, canvas.width / 2, canvas.height / 2);
          ctx.fillText("Press ENTER to return to menu", canvas.width / 2, canvas.height / 2 + 40);
          
          // Display score and high score
          ctx.fillText(`Score: ${score}`, canvas.width / 2, 40);
          
          // Get high score for current difficulty
          const currentHighScore = highScores[currentDifficulty.toLowerCase()] || 0;
          
          // Add message if player achieved a new high score
          if (score > currentHighScore) {
            ctx.fillStyle = "#FFD700"; // Gold color
            ctx.fillText("NEW HIGH SCORE!", canvas.width / 2, 70);
          } else {
            ctx.font = "18px sans-serif";
            ctx.fillStyle = "white";
            ctx.fillText(`High Score: ${currentHighScore}`, canvas.width / 2, 70);
          }
          return;
        }
        if (gameState === GAME_STATE.GAME_OVER) {
          for (let p of smallExplosionParticles) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fillStyle = p.color;
            ctx.fill();
          }
          ctx.fillStyle = "red";
          ctx.font = "48px sans-serif";
          ctx.textAlign = "center";
          ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2 - 50);
          
          // Show difficulty and time survived
          let difficultyName = "";
          switch(currentDifficulty) {
            case DIFFICULTY.EASY: difficultyName = "Easy"; break;
            case DIFFICULTY.MEDIUM: difficultyName = "Medium"; break;
            case DIFFICULTY.HARD: difficultyName = "Hard"; break;
            case DIFFICULTY.INFINITY: difficultyName = "Infinity"; break;
          }
          
          ctx.font = "24px sans-serif";
          ctx.fillText(`Mode: ${difficultyName}`, canvas.width / 2, canvas.height / 2);
          
          // For Infinity mode, show how long the player survived
          if (currentDifficulty === DIFFICULTY.INFINITY) {
            const minutes = Math.floor(gameTime / 60);
            const seconds = Math.floor(gameTime % 60);
            ctx.fillText(`Survived: ${minutes}m ${seconds}s`, canvas.width / 2, canvas.height / 2 + 30);
          }
          
          ctx.fillText("Press ENTER to restart", canvas.width / 2, canvas.height / 2 + 70);
          
          // Display score and high score
          ctx.fillText(`Score: ${score}`, canvas.width / 2, 40);
          
          // Get high score for current difficulty
          const currentHighScore = highScores[currentDifficulty.toLowerCase()] || 0;
          
          // Add message if player achieved a new high score
          if (score > currentHighScore) {
            ctx.fillStyle = "#FFD700"; // Gold color
            ctx.fillText("NEW HIGH SCORE!", canvas.width / 2, 70);
          } else {
            ctx.font = "18px sans-serif";
            ctx.fillStyle = "white";
            ctx.fillText(`High Score: ${currentHighScore}`, canvas.width / 2, 70);
          }
          return;
        }

        // Draw top HUD panel background
        const hudHeight = 50;
        const hudPadding = 10;
        ctx.fillStyle = "rgba(10, 20, 50, 0.5)";
        ctx.strokeStyle = "rgba(80, 160, 255, 0.4)";
        ctx.lineWidth = 1;
        ctx.fillRect(0, 0, canvas.width, hudHeight);
        ctx.strokeRect(0, 0, canvas.width, hudHeight);
        
        // Divide HUD into sections
        const leftSection = {x: hudPadding, width: canvas.width * 0.25, center: hudPadding + (canvas.width * 0.25)/2};
        const centerSection = {x: canvas.width * 0.25 + hudPadding, width: canvas.width * 0.5, center: canvas.width/2};
        const rightSection = {x: canvas.width * 0.75 + hudPadding, width: canvas.width * 0.25 - hudPadding*2, center: canvas.width * 0.75 + hudPadding + (canvas.width * 0.25 - hudPadding*2)/2};
        
        // LEFT SECTION: Music icon and difficulty
        drawMusicIcon(); // Already positioned at top-left
        
        // Show difficulty
        let difficultyName = "";
        switch(currentDifficulty) {
          case DIFFICULTY.EASY: difficultyName = "Easy"; break;
          case DIFFICULTY.MEDIUM: difficultyName = "Medium"; break;
          case DIFFICULTY.HARD: difficultyName = "Hard"; break;
          case DIFFICULTY.INFINITY: difficultyName = "Infinity"; break;
        }
        
        ctx.fillStyle = "white";
        ctx.font = "16px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Difficulty: " + difficultyName, leftSection.center + 30, hudHeight/2 + 6);
        
        // CENTER SECTION: Score and high score
        // Current score
        ctx.font = "20px sans-serif";
        ctx.fillStyle = "white";
        ctx.fillText("Score: " + score, centerSection.center, hudHeight/2 - 7);
        
        // High score
        const currentHighScore = highScores[currentDifficulty.toLowerCase()] || 0;
        ctx.font = "16px sans-serif";
        ctx.fillStyle = "#FFD700"; // Gold color
        ctx.fillText("High Score: " + currentHighScore, centerSection.center, hudHeight/2 + 14);
        
        // RIGHT SECTION: Health and timer
        // Draw timer closer to the center (about 1/4 from right to left)
        ctx.font = "16px sans-serif";
        ctx.fillStyle = "white";
        ctx.textAlign = "center";
        
        // Calculate a position that's about 1/4 from the right
        const timerX = canvas.width * 0.75;
        
        if (currentDifficulty === DIFFICULTY.INFINITY) {
          const minutes = Math.floor(gameTime / 60);
          const seconds = Math.floor(gameTime % 60);
          ctx.fillText(`Time: ${minutes}m ${seconds.toString().padStart(2, '0')}s`, timerX, hudHeight/2 - 7);
          
          // Show spawn rate in infinity mode
          if (infinityModeSpawnMultiplier > 1.0) {
            ctx.fillStyle = "yellow";
            ctx.fillText(`Spawn: ${(infinityModeSpawnMultiplier * 100).toFixed(0)}%`, timerX, hudHeight/2 + 14);
          }
        } else {
          // Show time remaining for timed modes
          const timeRemaining = Math.max(0, GAME_DURATION[currentDifficulty] - gameTime);
          const minutes = Math.floor(timeRemaining / 60);
          const seconds = Math.floor(timeRemaining % 60);
          ctx.fillText(`Time: ${minutes}:${seconds.toString().padStart(2, '0')}`, timerX, hudHeight/2 + 6);
        }
        
        // Draw health bar centered at the top
        drawHealthBar();

        // Power-ups
        for (let pu of powerUps) {
          ctx.save();
          ctx.translate(pu.x, pu.y);
          
          // Different colors for different power-up types
          let coreColor, glowColor, particleColor, iconText;
          
          if (pu.type === "tripleShot") {
            coreColor = "#3080ff"; // Bright blue core
            glowColor = "#80c0ff"; // Light blue glow
            particleColor = "#00ccff"; // Cyan particles
            iconText = pu.enhanced ? "6X" : "3X";
          } else if (pu.type === "missileBarrage") {
            coreColor = "#ffdd00"; // Bright yellow core
            glowColor = "#ffe680"; // Light yellow glow
            particleColor = "#ffcc00"; // Golden particles
            iconText = "MB"; // Missile Barrage
          } else {
            // Default health power-up
            coreColor = "#ff3030"; // Bright red core
            glowColor = "#ff8080"; // Light red glow
            particleColor = "#ff0000"; // Red particles
            iconText = "HP";
          }
          
          // Calculate animation values
          // Pulse effect for the glow
          const pulseAmount = 0.3 + 0.3 * Math.sin(gameTime * POWERUP_PULSE_SPEED);
          // Rotation angle for orbiting particles
          const rotationAngle = gameTime * POWERUP_ROTATION_SPEED;
          
          // Warning effect for power-ups with short lifetime
          let warningEffect = 1;
          if (pu.lifetime < 5) {
            warningEffect = 0.5 + 0.5 * Math.sin(gameTime * 10); // Faster blinking when about to expire
          }
          
          // 1. Draw the outer glow
          const outerGlowRadius = POWERUP_SIZE * (1.5 + pulseAmount);
          const glowGradient = ctx.createRadialGradient(
            0, 0, POWERUP_SIZE * 0.5,
            0, 0, outerGlowRadius
          );
          
          glowGradient.addColorStop(0, `${glowColor}80`); // 50% opacity
          glowGradient.addColorStop(1, `${glowColor}00`); // 0% opacity
          
          ctx.beginPath();
          ctx.arc(0, 0, outerGlowRadius, 0, Math.PI * 2);
          ctx.fillStyle = glowGradient;
          ctx.fill();
          
          // 2. Draw orbiting particles
          const numParticles = 6;
          const orbitRadius = POWERUP_SIZE * (1.2 + pulseAmount * 0.5);
          ctx.fillStyle = `rgba(${hexToRgb(particleColor)}, ${0.8 * warningEffect})`;
          
          for (let i = 0; i < numParticles; i++) {
            const angle = rotationAngle + (i / numParticles) * Math.PI * 2;
            const pX = Math.cos(angle) * orbitRadius;
            const pY = Math.sin(angle) * orbitRadius;
            const pSize = POWERUP_SIZE * 0.15 * (1 + 0.5 * Math.sin(gameTime * 3 + i));
            
            ctx.beginPath();
            ctx.arc(pX, pY, pSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Add small trails to particles
            const trailLength = pSize * 2;
            const trailWidth = pSize * 0.7;
            
            // Create a trail gradient
            const trailGradient = ctx.createLinearGradient(
              pX, pY,
              pX - Math.cos(angle) * trailLength,
              pY - Math.sin(angle) * trailLength
            );
            
            trailGradient.addColorStop(0, `rgba(${hexToRgb(particleColor)}, ${0.6 * warningEffect})`);
            trailGradient.addColorStop(1, `rgba(${hexToRgb(particleColor)}, 0)`);
            
            ctx.beginPath();
            ctx.moveTo(pX, pY);
            ctx.lineTo(
              pX - Math.cos(angle) * trailLength,
              pY - Math.sin(angle) * trailLength - trailWidth/2
            );
            ctx.lineTo(
              pX - Math.cos(angle) * trailLength,
              pY - Math.sin(angle) * trailLength + trailWidth/2
            );
            ctx.closePath();
            ctx.fillStyle = trailGradient;
            ctx.fill();
          }
          
          // 3. Draw the core with a soft glow
          const coreSize = POWERUP_SIZE * (0.8 + pulseAmount * 0.2);
          const coreGradient = ctx.createRadialGradient(
            0, 0, 0,
            0, 0, coreSize
          );
          
          coreGradient.addColorStop(0, `rgba(255, 255, 255, ${0.9 * warningEffect})`); // White center
          coreGradient.addColorStop(0.6, `rgba(${hexToRgb(coreColor)}, ${0.8 * warningEffect})`);
          coreGradient.addColorStop(1, `rgba(${hexToRgb(coreColor)}, ${0.6 * warningEffect})`);
          
          ctx.beginPath();
          ctx.arc(0, 0, coreSize, 0, Math.PI * 2);
          ctx.fillStyle = coreGradient;
          ctx.shadowBlur = 10;
          ctx.shadowColor = glowColor;
          ctx.fill();
          
          // 4. Draw the icon text
          // Add blinking effect based on power-up type
          let textOpacity = warningEffect;
          if (pu.type === "tripleShot") {
            textOpacity *= 0.6 + 0.4 * Math.sin(gameTime * POWERUP_BLINK_SPEED);
          }
          
          ctx.font = `bold ${POWERUP_SIZE * 0.5}px Arial`;
          ctx.fillStyle = `rgba(255, 255, 255, ${textOpacity})`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.shadowBlur = 5;
          ctx.shadowColor = "rgba(0, 0, 0, 0.5)";
          ctx.fillText(iconText, 0, 0);
          
          ctx.restore();
        }
        
        // Helper function to convert hex to rgb
        function hexToRgb(hex) {
          // Remove the hash if it exists
          hex = hex.replace(/^#/, '');
          
          // Parse the hex values
          const bigint = parseInt(hex, 16);
          const r = (bigint >> 16) & 255;
          const g = (bigint >> 8) & 255;
          const b = bigint & 255;
          
          return `${r}, ${g}, ${b}`;
        }
        
        // Display triple shot timer if active
        if (spaceship.tripleShot) {
          const timerWidth = 80;
          const timerHeight = 6;
          const timeLeft = spaceship.tripleShotTimer / TRIPLE_SHOT_DURATION;
          
          ctx.save();
          // Position below health bar
          const x = canvas.width - 120;
          const y = 45;
          
          // Timer background
          ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
          ctx.fillRect(x, y, timerWidth, timerHeight);
          
          // Timer fill
          ctx.fillStyle = TRIPLE_SHOT_POWERUP_COLOR;
          ctx.fillRect(x, y, timerWidth * timeLeft, timerHeight);
          
          // Timer text - show 6X for enhanced shots in infinity mode
          const shotText = (currentDifficulty === DIFFICULTY.INFINITY && 
                           infinityModeSpawnMultiplier >= 1.5) ? "6X Shot" : "3X Shot";
          ctx.font = "12px Arial";
          ctx.fillStyle = "white";
          ctx.textAlign = "center";
          ctx.fillText(shotText, x + timerWidth/2, y - 5);
          
          ctx.restore();
        }
        
        // Display missile barrage timer if active
        if (spaceship.missileBarrageActive) {
          const timerWidth = 80;
          const timerHeight = 6;
          const timeLeft = spaceship.missileBarrageTimer / MISSILE_BARRAGE_DURATION;
          
          ctx.save();
          // Position below triple shot timer (if showing)
          const x = canvas.width - 120;
          const y = spaceship.tripleShot ? 65 : 45;
          
          // Timer background
          ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
          ctx.fillRect(x, y, timerWidth, timerHeight);
          
          // Timer fill
          ctx.fillStyle = MISSILE_BARRAGE_POWERUP_COLOR;
          ctx.fillRect(x, y, timerWidth * timeLeft, timerHeight);
          
          // Timer text
          ctx.font = "12px Arial";
          ctx.fillStyle = "white";
          ctx.textAlign = "center";
          ctx.fillText("MISSILES", x + timerWidth/2, y - 5);
          
          ctx.restore();
        }
        
        // Display laser cooldown for laser ship
        if (spaceship.type === SHIP_TYPE.LASER && (spaceship.laserCooldown || spaceship.laserActive)) {
          const timerWidth = 80;
          const timerHeight = 6;
          
          let timerLabel, timeLeft, timerColor;
          
          if (spaceship.laserActive) {
            // Laser is active - show active time left
            timerLabel = "LASER";
            timeLeft = 1 - (spaceship.laserTimer / 6); // 6 seconds duration (increased from 3)
            timerColor = "rgba(0, 220, 255, 0.8)";
          } else {
            // Laser is cooling down
            timerLabel = "RECHARGING";
            timeLeft = 1 - (spaceship.laserCooldownTimer / 10); // 10 seconds cooldown
            timerColor = "rgba(255, 100, 100, 0.8)";
          }
          
          ctx.save();
          // Position below other timers if needed
          const x = canvas.width - 120;
          let y = 45;
          if (spaceship.tripleShot) y += 20;
          if (spaceship.missileBarrageActive) y += 20;
          
          // Timer background
          ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
          ctx.fillRect(x, y, timerWidth, timerHeight);
          
          // Timer fill
          ctx.fillStyle = timerColor;
          ctx.fillRect(x, y, timerWidth * timeLeft, timerHeight);
          
          // Timer text
          ctx.font = "12px Arial";
          ctx.fillStyle = "white";
          ctx.textAlign = "center";
          ctx.fillText(timerLabel, x + timerWidth/2, y - 5);
          
          ctx.restore();
        }
        
        // No longer showing the missile barrage timer since it's now a pickup

        // Spaceship
        drawSpaceship();
        
        // Draw EMP effect if active
        if (spaceship.type === SHIP_TYPE.DEFAULT && spaceship.empActive) {
          drawEMPEffect();
        }

        // Sparks
        const noseX = spaceship.x + Math.cos(spaceship.angle) * spaceship.size;
        const noseY = spaceship.y + Math.sin(spaceship.angle) * spaceship.size;
        ctx.save();
        ctx.strokeStyle = "yellow";
        ctx.lineWidth = 1;
        for (let spark of sparks) {
          ctx.beginPath();
          ctx.moveTo(noseX, noseY);
          ctx.lineTo(
            noseX + Math.cos(spark.angle) * spark.length,
            noseY + Math.sin(spark.angle) * spark.length
          );
          ctx.stroke();
        }
        ctx.restore();

        // Bullets
        for (let b of bullets) {
          if (b.isMissile) {
            // Draw missile with special styling
            ctx.save();
            ctx.translate(b.x, b.y);
            ctx.rotate(Math.atan2(b.vy, b.vx));
            
            // Age-based color effects (missiles change color as they travel)
            const age = gameTime - (b.creation || 0);
            const colorPhase = Math.sin(age * 10) * 0.5 + 0.5; // Oscillate between 0-1
            
            // Color shifts based on missile power
            let missileColor, trailLength, glowIntensity;
            
            if (b.isPowerfulMissile) {
              // Vary colors slightly based on missile sequence number for more variety
              const sequenceNum = b.sequenceNumber || 0;
              
              if (sequenceNum === 0) {
                // First missile (center) - gold to orange
                if (colorPhase < 0.33) {
                  missileColor = "rgba(255, 220, 50, 1.0)"; // Bright gold
                } else if (colorPhase < 0.66) {
                  missileColor = "rgba(255, 150, 20, 1.0)"; // Deep orange
                } else {
                  missileColor = "rgba(255, 80, 10, 1.0)"; // Reddish orange
                }
              } else if (sequenceNum === 1) {
                // Second missile (left) - blue to purple
                if (colorPhase < 0.33) {
                  missileColor = "rgba(50, 180, 255, 1.0)"; // Bright blue
                } else if (colorPhase < 0.66) {
                  missileColor = "rgba(100, 120, 255, 1.0)"; // Blue-purple
                } else {
                  missileColor = "rgba(150, 80, 255, 1.0)"; // Purple
                }
              } else {
                // Third missile (right) - green to teal
                if (colorPhase < 0.33) {
                  missileColor = "rgba(50, 255, 120, 1.0)"; // Bright green
                } else if (colorPhase < 0.66) {
                  missileColor = "rgba(20, 220, 150, 1.0)"; // Teal-green
                } else {
                  missileColor = "rgba(10, 200, 180, 1.0)"; // Teal
                }
              }
              trailLength = 12; // Longer trail
              glowIntensity = 20; // Stronger glow
            } else {
              // Regular missile colors
              if (colorPhase < 0.33) {
                missileColor = "rgba(255, 255, 0, 0.9)"; // Yellow
              } else if (colorPhase < 0.66) {
                missileColor = "rgba(255, 200, 0, 0.9)"; // Orange-yellow
              } else {
                missileColor = "rgba(255, 150, 0, 0.9)"; // Orange
              }
              trailLength = 8; // Standard trail
              glowIntensity = 10; // Standard glow
            }
            
            // Missile body shape
            ctx.fillStyle = missileColor;
            
            // Add glow effect
            ctx.shadowColor = missileColor;
            ctx.shadowBlur = glowIntensity;
            
            // Modified shape - more rocket-like
            ctx.beginPath();
            
            if (b.isPowerfulMissile) {
              // Bullet shape for powerful missiles
              ctx.arc(0, 0, b.radius * 1.5, 0, Math.PI * 2);
            } else {
              // Standard missile shape - simple circle
              ctx.arc(0, 0, b.radius, 0, Math.PI * 2);
            }
            
            ctx.fill();
            
            // Missile trail - simpler reversion to original structure
            ctx.shadowBlur = glowIntensity + 5; // More pronounced glow for trail
            ctx.beginPath();
            ctx.moveTo(-b.radius * 0.7, 0);
            ctx.lineTo(-b.radius * trailLength, 0);
            
            // Trail gradient varies based on missile power and sequence
            const sequenceNum = b.sequenceNumber || 0;
            const trailGradient = ctx.createLinearGradient(-b.radius, 0, -b.radius * trailLength, 0);
            
            if (b.isPowerfulMissile) {
              // Color based on which missile in sequence
              if (sequenceNum === 0) {
                // Orange/red trail for center missile
                trailGradient.addColorStop(0, missileColor);
                trailGradient.addColorStop(0.2, "rgba(255, 200, 50, 0.9)");
                trailGradient.addColorStop(0.5, "rgba(255, 100, 50, 0.7)");
                trailGradient.addColorStop(0.8, "rgba(255, 50, 0, 0.4)");
                trailGradient.addColorStop(1, "rgba(255, 0, 0, 0)");
              } else if (sequenceNum === 1) {
                // Blue/purple trail for left missile
                trailGradient.addColorStop(0, missileColor);
                trailGradient.addColorStop(0.2, "rgba(50, 150, 255, 0.9)");
                trailGradient.addColorStop(0.5, "rgba(80, 100, 255, 0.7)");
                trailGradient.addColorStop(0.8, "rgba(100, 50, 220, 0.4)");
                trailGradient.addColorStop(1, "rgba(80, 20, 180, 0)");
              } else {
                // Green/teal trail for right missile
                trailGradient.addColorStop(0, missileColor);
                trailGradient.addColorStop(0.2, "rgba(50, 220, 120, 0.9)");
                trailGradient.addColorStop(0.5, "rgba(30, 200, 150, 0.7)");
                trailGradient.addColorStop(0.8, "rgba(20, 180, 180, 0.4)");
                trailGradient.addColorStop(1, "rgba(10, 150, 150, 0)");
              }
            } else {
              // Standard trail
              trailGradient.addColorStop(0, missileColor);
              trailGradient.addColorStop(0.3, "rgba(255, 200, 100, 0.7)");
              trailGradient.addColorStop(0.7, "rgba(255, 100, 50, 0.3)");
              trailGradient.addColorStop(1, "rgba(255, 50, 0, 0)");
            }
            
            ctx.strokeStyle = trailGradient;
            
            // Pulsing trail width
            const pulseRate = b.isPowerfulMissile ? 20 : 15; // Faster pulse for powerful missiles
            const pulseAmplitude = b.isPowerfulMissile ? 0.4 : 0.3; // Higher amplitude for powerful missiles
            ctx.lineWidth = b.radius * (1.5 + Math.sin(age * pulseRate) * pulseAmplitude);
            ctx.stroke();
            
            // Add fire particles to powerful missile trail
            if (b.isPowerfulMissile) {
              // Add more particles for a fire-like effect
              const numParticles = 4; // Number of particles to add per frame
              
              for (let i = 0; i < numParticles; i++) {
                // Calculate random position along trail
                const sparkDistance = Math.random() * (trailLength * b.radius * 0.8);
                // More spread at the end of the trail
                const spreadFactor = sparkDistance / (trailLength * b.radius);
                const sparkOffsetY = (Math.random() - 0.5) * b.radius * 3 * spreadFactor;
                
                // Particle size smaller toward end of trail
                const particleSize = Math.random() * b.radius * 0.8 * (1 - spreadFactor * 0.8);
                
                // Choose particle color based on sequence and position
                let particleColor;
                
                if (sequenceNum === 0) {
                  // Orange/yellow sparks
                  particleColor = Math.random() < 0.5 ? 
                    "rgba(255, 220, 100, 0.8)" : 
                    "rgba(255, 160, 50, 0.8)";
                } else if (sequenceNum === 1) {
                  // Blue/white sparks
                  particleColor = Math.random() < 0.5 ? 
                    "rgba(180, 220, 255, 0.8)" : 
                    "rgba(100, 180, 255, 0.8)";
                } else {
                  // Green/white sparks
                  particleColor = Math.random() < 0.5 ? 
                    "rgba(180, 255, 220, 0.8)" : 
                    "rgba(100, 255, 180, 0.8)";
                }
                
                // Draw the spark particle
                ctx.beginPath();
                ctx.arc(-b.radius - sparkDistance, sparkOffsetY, particleSize, 0, Math.PI * 2);
                ctx.fillStyle = particleColor;
                ctx.fill();
              }
            }
            
            ctx.restore();
          } else {
            // Normal bullet
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
            ctx.fill();
          }
        }

        // Normal Comets
        drawNormalComets();

        // Big Comets
        drawBigComets(ctx);

        // Explosion Particles
        for (let p of smallExplosionParticles) {
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fillStyle = p.color;
          ctx.fill();
        }
      }

      // Game Loop
      let lastLoopTime = performance.now();
      function gameLoop(now) {
        const dt = (now - lastLoopTime) / 1000;
        lastLoopTime = now;
        
        // Update menu background if in menu screens
        const isMenuScreen = 
          gameState === GAME_STATE.MAIN_MENU || 
          gameState === GAME_STATE.DIFFICULTY_SELECT ||
          gameState === GAME_STATE.SETTINGS ||
          gameState === GAME_STATE.HOW_TO_PLAY ||
          gameState === GAME_STATE.HIGH_SCORES;
        
        if (isMenuScreen) {
          updateMenuBackground(dt);
        }
        
        updateExplosionParticles(dt);
        update(dt);
        draw();
        requestAnimationFrame(gameLoop);
      }
      requestAnimationFrame(gameLoop);

      // The main update function
      function update(dt) {
        // always update starfield
        updateStarfield(dt);
        
        // Update the window.gameState to be accessible from auth.js
        // This ensures auth.js knows the correct state
        if (gameState === GAME_STATE.PLAYING) {
          window.gameState = "playing";
          
          // Make sure the auth button is disabled while playing
          const authButton = document.getElementById('auth-button');
          if (authButton) {
            authButton.disabled = true;
            authButton.style.opacity = "0.5";
            authButton.style.cursor = "not-allowed";
          }
          
          // Update ship type-specific mechanics
          updateShipMechanics(dt);
        } else {
          window.gameState = String(gameState);
          
          // Re-enable auth button when not playing
          const authButton = document.getElementById('auth-button');
          if (authButton) {
            authButton.disabled = false;
            authButton.style.opacity = "1";
            authButton.style.cursor = "pointer";
          }
        }
        
        // Function to update ship type-specific mechanics
        function updateShipMechanics(dt) {
          // Update missile cooldown timer
          if (spaceship.missileSpecialCooldown > 0) {
            spaceship.missileSpecialCooldown -= dt;
            if (spaceship.missileSpecialCooldown < 0) spaceship.missileSpecialCooldown = 0;
          }
          
          // Handle sequential missile firing
          if (missileSequenceState.isActive) {
            // Check if it's time to fire the next missile in the sequence
            if (gameTime - missileSequenceState.lastFiredTime >= missileSequenceState.missileDelay) {
              fireNextMissileInSequence();
            }
          }
          
          // Update shield flash timer
          if (spaceship.shieldFlashTimer > 0) {
            spaceship.shieldFlashTimer -= dt;
            if (spaceship.shieldFlashTimer < 0) spaceship.shieldFlashTimer = 0;
          }
          
          // Update laser ship mechanics
          if (spaceship.type === SHIP_TYPE.LASER) {
            if (spaceship.laserCooldown) {
              // Handle cooldown
              spaceship.laserCooldownTimer -= dt;
              if (spaceship.laserCooldownTimer <= 0) {
                spaceship.laserCooldown = false;
                spaceship.laserCooldownTimer = 0;
              }
            } else if (spaceship.laserActive) {
              // Update active laser beam
              spaceship.laserTimer += dt;
              
              // Periodic sound effects for sustained laser
              if (Math.floor(spaceship.laserTimer * 3) % 1 === 0 && soundEnabled) {
                bulletSoundPool[nextBulletSoundIndex].currentTime = 0;
                bulletSoundPool[nextBulletSoundIndex].volume = 0.2;
                bulletSoundPool[nextBulletSoundIndex].play();
                nextBulletSoundIndex = (nextBulletSoundIndex + 1) % BULLET_SOUND_POOL_SIZE;
              }
              
              // Laser stays active for 6 seconds then goes on cooldown (increased from 3)
              if (spaceship.laserTimer >= 6) {
                spaceship.laserActive = false;
                spaceship.laserTimer = 0;
                spaceship.laserCooldown = true;
                spaceship.laserCooldownTimer = 10; // 10 second cooldown
                // Reset laser beam endpoint variables
                spaceship.laserBeamEndX = null;
                spaceship.laserBeamEndY = null;
              }
              
              // Process laser beam collisions
              processLaserCollisions();
            }
          }
        }
        
        // Check collisions between laser beam and comets/bigComets
        function processLaserCollisions() {
          if (!spaceship.laserActive || spaceship.type !== SHIP_TYPE.LASER) return;
          
          // Calculate laser beam endpoint (very long to cover screen)
          const laserLength = 2000;
          let beamEndX = spaceship.x + Math.cos(spaceship.angle) * laserLength;
          let beamEndY = spaceship.y + Math.sin(spaceship.angle) * laserLength;
          
          // Initialize variables to track closest intersection
          let closestIntersection = null;
          let closestDist = Infinity;
          let closestComet = null;
          let isNormalComet = true;
          
          // Check normal comets
          for (let i = comets.length - 1; i >= 0; i--) {
            const comet = comets[i];
            
            // Skip if comet is indestructible
            if (comet.indestructableTimer > 0) continue;
            
            // Check if laser intersects comet
            if (lineCircleIntersect(
                spaceship.x, spaceship.y, 
                beamEndX, beamEndY,
                comet.x, comet.y, comet.radius)) {
              
              // Calculate distance to this comet
              const dist = Math.hypot(comet.x - spaceship.x, comet.y - spaceship.y);
              
              // If this is closer than previous hits, remember it
              if (dist < closestDist) {
                closestDist = dist;
                closestComet = comet;
                isNormalComet = true;
              }
            }
          }
          
          // Check big comets
          for (let i = bigComets.length - 1; i >= 0; i--) {
            const bigComet = bigComets[i];
            
            // Check if laser intersects big comet
            if (lineCircleIntersect(
                spaceship.x, spaceship.y, 
                beamEndX, beamEndY,
                bigComet.x, bigComet.y, bigComet.radius)) {
              
              // Calculate distance to this comet
              const dist = Math.hypot(bigComet.x - spaceship.x, bigComet.y - spaceship.y);
              
              // If this is closer than previous hits, remember it
              if (dist < closestDist) {
                closestDist = dist;
                closestComet = bigComet;
                isNormalComet = false;
              }
            }
          }
          
          // If we found a comet intersection, update beam endpoint
          if (closestComet) {
            // Calculate beam endpoint at the comet's edge
            const angle = Math.atan2(closestComet.y - spaceship.y, closestComet.x - spaceship.x);
            const radius = isNormalComet ? closestComet.radius : closestComet.radius;
            
            // Set endpoint to be at the comet's edge
            beamEndX = closestComet.x - Math.cos(angle) * radius;
            beamEndY = closestComet.y - Math.sin(angle) * radius;
            
            // Apply damage to the closest comet only
            if (isNormalComet) {
              // It's a normal comet
              closestComet.hitPoints -= 20.0 * dt; // Greatly increased laser damage (from 2.5 to 10.0 per second)
              closestComet.hitEffectTimer = 10;
              
              // Create hit effect
              if (Math.random() < 0.2) { // Throttle particles
                createBulletImpact(beamEndX, beamEndY, 0.5, "cyan");
              }
              
              // Check if comet is destroyed
              if (closestComet.hitPoints <= 0) {
                createSmallExplosion(closestComet.x, closestComet.y);
                
                // Split into smaller comets if bigger than tier 1
                if (closestComet.tier > 1) {
                  const newTier = closestComet.tier - 1;
                  const baseSpeed = Math.hypot(closestComet.vx, closestComet.vy);
                  let splits = Math.floor(randomRange(2, 6));
                  const offset = 50;
                  for (let k = 0; k < splits; k++) {
                    let newAngle = Math.random() * 2 * Math.PI;
                    let factor = randomRange(0.7, 0.8);
                    let extraFactor = randomRange(1.2, 1.5);
                    let newSpeed = baseSpeed * factor * extraFactor;
                    spawnComet(
                      newTier,
                      closestComet.x + Math.cos(newAngle) * offset,
                      closestComet.y + Math.sin(newAngle) * offset,
                      Math.cos(newAngle) * newSpeed,
                      Math.sin(newAngle) * newSpeed
                    );
                    // Short indestructible period so they don't instantly collide
                    comets[comets.length - 1].indestructableTimer = 0.01;
                  }
                }
                score += 10;
                // Find and remove the comet
                const index = comets.indexOf(closestComet);
                if (index > -1) {
                  comets.splice(index, 1);
                }
              }
            } else {
              // It's a big comet
              closestComet.hitPoints -= 20 * dt; // Much higher damage per second
              closestComet.hitCount++; // Increment hit counter
              closestComet.hitFlashTimer = 0.1;
              
              // Add visual effects
              if (Math.random() < 0.3) { // Throttle particles
                createBulletImpact(
                  beamEndX,
                  beamEndY,
                  0.7, "cyan"
                );
              }
              
              // Shake effect
              closestComet.shakeAmount = 3 + (closestComet.hitCount / BIG_COMET_HEALTH) * 8;
              closestComet.shakeTimer = 0.2 + (closestComet.hitCount / BIG_COMET_HEALTH) * 0.4;
            }
          }
          
          // Store beam endpoint for drawing
          spaceship.laserBeamEndX = beamEndX;
          spaceship.laserBeamEndY = beamEndY;
        }
        
        // Helper function to check if a line intersects a circle
        function lineCircleIntersect(x1, y1, x2, y2, cx, cy, r) {
          // Calculate the closest point on the line to the circle center
          const dx = x2 - x1;
          const dy = y2 - y1;
          const len = Math.sqrt(dx*dx + dy*dy);
          
          // Normalize direction vector
          const nx = dx / len;
          const ny = dy / len;
          
          // Vector from line start to circle center
          const lcx = cx - x1;
          const lcy = cy - y1;
          
          // Project circle center onto line
          const projection = lcx * nx + lcy * ny;
          const projectionX = x1 + nx * Math.max(0, Math.min(len, projection));
          const projectionY = y1 + ny * Math.max(0, Math.min(len, projection));
          
          // Distance from closest point to circle center
          const distance = Math.sqrt(
            Math.pow(projectionX - cx, 2) + 
            Math.pow(projectionY - cy, 2)
          );
          
          // Intersects if distance is less than circle radius
          return distance <= r;
        }
        

        // Update ship hit flash timer
        if (spaceship.hitFlashTimer > 0) {
          spaceship.hitFlashTimer -= dt;
          if (spaceship.hitFlashTimer < 0) spaceship.hitFlashTimer = 0;
        }
        
        // Update triple shot timer
        if (spaceship.tripleShot) {
          spaceship.tripleShotTimer -= dt;
          if (spaceship.tripleShotTimer <= 0) {
            spaceship.tripleShot = false;
          }
        }
        
        // Update EMP effect if active
        if (spaceship.empActive) {
          spaceship.empEffectTimer += dt;
          const expansionRate = 1000 - 700 * (spaceship.empEffectTimer / 5.0);
          spaceship.empWaveRadius += expansionRate * dt;
          
          // Slow down comets in range of the EMP wave
          for (let comet of comets) {
            const dx = comet.x - spaceship.x;
            const dy = comet.y - spaceship.y;
            const distance = Math.sqrt(dx*dx + dy*dy);
            
            // If comet is within EMP wave radius, slow it down
            if (distance <= spaceship.empWaveRadius) {
              comet.vx *= 0.8;
              comet.vy *= 0.8;
            }
          }
          
          // Also slow down big comets
          for (let bc of bigComets) {
            const dx = bc.x - spaceship.x;
            const dy = bc.y - spaceship.y;
            const distance = Math.sqrt(dx*dx + dy*dy);
            
            if (distance <= spaceship.empWaveRadius) {
              bc.vx *= 0.8;
              bc.vy *= 0.8;
            }
          }
          
          // End the EMP effect after 5 seconds
          if (spaceship.empEffectTimer >= 5.0) {
            spaceship.empActive = false;
            spaceship.empCooldown = true;
            spaceship.empCooldownTimer = 12.0;
          }
        }
        
        // Update EMP cooldown
        if (spaceship.empCooldown) {
          spaceship.empCooldownTimer -= dt;
          if (spaceship.empCooldownTimer <= 0) {
            spaceship.empCooldown = false;
          }
        }


        // if not in playing state, do minimal
        if (gameState !== GAME_STATE.PLAYING) {
          return;
        }

        // Increase global time so comet morph can happen
        gameTime += dt;

        // Triple shot timer is now updated earlier in the update cycle
        
        // Update missile barrage system
        updateMissileBarrage(dt);
        
        // Check if we should spawn a triple shot power-up before big comets
        if (!tripleShootPowerUpSpawned && bigComets.length === 0 && !powerUpTypeExists("tripleShot")) {
          tripleShootPowerUpTimer += dt;
          // Spawn triple shot power-up TRIPLE_SHOT_SPAWN_TIME seconds before next big comet
          if (BIG_COMET_SPAWN_INTERVAL - bigCometSpawnTimer <= TRIPLE_SHOT_SPAWN_TIME && tripleShootPowerUpTimer >= 2) {
            powerUps.push(spawnTripleShotPowerUp());
            tripleShootPowerUpSpawned = true;
            tripleShootPowerUpTimer = 0;
          }
        } else if (bigComets.length > 0) {
          // Reset flag when big comets are present
          tripleShootPowerUpSpawned = false;
        }
        
        // Reset the missileBarrageSpawnTimer to eliminate automatic spawning
        // All missile barrage power-ups will now come from random pickups

        // Regular power-ups
        powerUpSpawnTimer += dt;
        if (powerUpSpawnTimer >= POWERUP_SPAWN_INTERVAL) {
          powerUps.push(spawnPowerUp());
          powerUpSpawnTimer = 0;
        }
        for (let i = powerUps.length - 1; i >= 0; i--) {
          let pu = powerUps[i];
          pu.lifetime -= dt;
          pu.x += pu.vx * dt;
          pu.y += pu.vy * dt;
          bounce(pu, POWERUP_RADIUS);
          if (pu.lifetime <= 0) {
            powerUps.splice(i, 1);
            continue;
          }
          // Check if spaceship picks it up
          const dx = spaceship.x - pu.x;
          const dy = spaceship.y - pu.y;
          if (Math.hypot(dx, dy) < (spaceship.size / 2 + pu.radius)) {
            // Apply power-up effect based on type
            if (pu.type === "health") {
              // Refill HP based on ship type
              const maxHP = spaceship.type === SHIP_TYPE.LASER ? 7 :
                           spaceship.type === SHIP_TYPE.MISSILE ? 4 : 5;
              
              // Restore 3 HP or full if less than 3 remaining
              spaceship.hitPoints = Math.min(maxHP, spaceship.hitPoints + 3);
              
              // Also restore shield for laser ship
              if (spaceship.type === SHIP_TYPE.LASER && spaceship.hasShield) {
                // Always restore shield to full
                spaceship.shieldHealth = 3;
                // Flash shield to show it's recharged
                spaceship.shieldFlashTimer = 0.6;
              }
            } else if (pu.type === "tripleShot") {
              // Activate triple shot or enhanced shot in infinity mode
              spaceship.tripleShot = true;
              spaceship.tripleShotTimer = TRIPLE_SHOT_DURATION;
            } else if (pu.type === "missileBarrage") {
              // Activate missile barrage (Infinity mode only)
              startMissileBarrage();
            }
            
            // Play power-up sound
            powerUpSound.volume = 0.3;
            powerUpSound.play().catch(err => console.error("Error playing powerup sound:", err));
            powerUps.splice(i, 1); // Remove the power-up after collection
            continue;



          }
        }

        // Win condition based on current difficulty
        const gameDuration = GAME_DURATION[currentDifficulty];
        let spawnAllowed = gameTime < gameDuration;
        
        // In infinity mode, always allow spawning
        if (currentDifficulty === DIFFICULTY.INFINITY) {
          spawnAllowed = true;
          
          // Only update infinity mode while actually playing the game
          if (gameState === GAME_STATE.PLAYING) {
            // Update infinity mode timer
            infinityModeTime += dt;
            
            // Every 2 minutes (120 seconds), increase spawn rate by 5%
            const twoMinutesPassed = Math.floor(infinityModeTime / 120);
            const newMultiplier = 1.0 + (twoMinutesPassed * 0.05);
            
            // Only update if it's changed to avoid constant reassignment
            if (newMultiplier !== infinityModeSpawnMultiplier) {
              infinityModeSpawnMultiplier = newMultiplier;
              console.log(`Infinity mode: Spawn rate now ${(infinityModeSpawnMultiplier * 100).toFixed(0)}% of base`);
            }
          }
        }
        
        // Victory condition for timed modes
        if (currentDifficulty !== DIFFICULTY.INFINITY && 
            gameTime >= gameDuration && !winTriggered) {
          // Make all comets explode
          for (let i = comets.length - 1; i >= 0; i--) {
            createSmallExplosion(comets[i].x, comets[i].y);
            score += 10; // Award score for each comet
          }
          comets = []; // Clear all comets
          
          // Make all big comets explode too
          for (let i = bigComets.length - 1; i >= 0; i--) {
            createHugeExplosion(bigComets[i].x, bigComets[i].y);
            score += 100; // Award score for each big comet
          }
          bigComets = []; // Clear all big comets
          
          // Create a celebratory explosion at the player's ship
          createHugeExplosion(spaceship.x, spaceship.y);
          
          winTriggered = true;
          gameState = GAME_STATE.WIN;
          bgMusic.pause(); // Stop the gameplay music
          victorySound.play().catch(err => console.error("Error playing victory sound:", err));
          
          // Check and update high score in Firebase
          updateHighScore(score, currentDifficulty)
            .then(result => {
              console.log("High score check complete:", result);
              if (result.isNewHighScore) {
                console.log("NEW HIGH SCORE!");
              }
            });
        }

        // Movement/Collisions
        // Spaceship vs comets
        for (let i = 0; i < comets.length; i++) {
          const c = comets[i];
          const dx = spaceship.x - c.x;
          const dy = spaceship.y - c.y;
          const dist = Math.hypot(dx, dy);
          if (dist < spaceship.size + c.radius) {
            let nx = dx / dist;
            let ny = dy / dist;
            let overlap = (spaceship.size + c.radius) - dist;
            let shieldAbsorbed = false;
            
            // Different collision behavior based on ship type
            if (spaceship.type === SHIP_TYPE.LASER) {
              // Heavy cruiser has more mass - pushes comets more and is pushed less
              // Ship moves less during collision (12.5% of normal movement)
              spaceship.x += nx * (overlap / 8);
              spaceship.y += ny * (overlap / 8);
              // Comet moves more (175% of normal movement)
              c.x -= nx * (overlap * 0.875);
              c.y -= ny * (overlap * 0.875);
              
              // Heavy cruiser bounces less and affects comets more
              spaceship.vx = -spaceship.vx * 0.2; // 60% less bounce than other ships
              spaceship.vy = -spaceship.vy * 0.2;
              c.vx = -c.vx * 0.3 - nx * 50; // Additional force applied to comets
              c.vy = -c.vy * 0.3 - ny * 50;
              
              // Check if shield is active and can handle the collision
              if (spaceship.hasShield && spaceship.shieldHealth > 0) {
                // Calculate angle of impact to check if it's in the front arc for frontal shield
                const impactAngle = Math.atan2(ny, nx);
                const angleRelativeToShip = ((impactAngle - spaceship.angle) + Math.PI * 2) % (Math.PI * 2);
                
                // For frontal shield, check if the impact is in the front 120° arc (-π/3 to π/3)
                const isInFrontArc = (angleRelativeToShip < Math.PI / 3 || angleRelativeToShip > Math.PI * 5 / 3);
                
                if (!spaceship.frontArcOnly || (spaceship.frontArcOnly && isInFrontArc)) {
                  // Shield absorbed the hit!
                  shieldAbsorbed = true;
                  spaceship.shieldHealth--;
                  spaceship.shieldFlashTimer = 0.3;
                  
                  // Play shield hit sound
                  if (soundEnabled) {
                    hitSoundPool[nextHitSoundIndex].currentTime = 0;
                    hitSoundPool[nextHitSoundIndex].volume = 0.3;
                    hitSoundPool[nextHitSoundIndex].play();
                    nextHitSoundIndex = (nextHitSoundIndex + 1) % HIT_SOUND_POOL_SIZE;
                  }
                  
                  // Create shield impact effect at the collision point
                  // Calculate collision point
                  const impactX = spaceship.x - nx * spaceship.size;
                  const impactY = spaceship.y - ny * spaceship.size;
                  
                  // Visual effect at impact point
                  createBulletImpact(
                    impactX, 
                    impactY, 
                    1.0, // Scale
                    spaceship.shieldHealth > 1 ? "#00AAFF" : "#FFAA00" // Blue or orange based on shield health
                  );
                }
              }
            } else {
              // Normal collision dynamics for other ships
              // separate them
              spaceship.x += nx * (overlap / 2);
              spaceship.y += ny * (overlap / 2);
              c.x -= nx * (overlap / 2);
              c.y -= ny * (overlap / 2);
              
              // bounce velocities
              spaceship.vx = -spaceship.vx * 0.5;
              spaceship.vy = -spaceship.vy * 0.5;
              c.vx = -c.vx * 0.3;
              c.vy = -c.vy * 0.3;
            }
            
            // If shield didn't absorb, damage spaceship
            if (!shieldAbsorbed) {
              // Save previous health before reducing and trigger shake effect
              spaceship.previousHitPoints = spaceship.hitPoints;
              spaceship.hitPoints--;
              spaceship.hitFlashTimer = 0.3;
              spaceship.healthShakeTimer = 0.5; // Half a second of shake
              spaceship.healthScaleTimer = 0.3; // Scale animation for 0.3 seconds
              
              // Create impact effect
              if (soundEnabled) {
                hitSoundPool[nextHitSoundIndex].currentTime = 0;
                hitSoundPool[nextHitSoundIndex].volume = 0.4; // Louder for direct hit
                hitSoundPool[nextHitSoundIndex].play();
                nextHitSoundIndex = (nextHitSoundIndex + 1) % HIT_SOUND_POOL_SIZE;
              }
              
              if (spaceship.hitPoints <= 0) {
                comets = [];
                bigComets = [];
                bullets = [];
                sparks = [];
                createHugeExplosion(spaceship.x, spaceship.y);
                gameState = GAME_STATE.GAME_OVER;
                bgMusic.pause(); // Stop the gameplay music
                defeatSound.play().catch(err => console.error("Error playing defeat sound:", err));
                
                // Check and update high score in Firebase
                updateHighScore(score, currentDifficulty)
                  .then(result => {
                    console.log("High score check complete:", result);
                    if (result.isNewHighScore) {
                      console.log("NEW HIGH SCORE!");
                    }
                  });
                
                return;
              }
            }
          }
        }

        // Spaceship vs bigComets
        for (let i = 0; i < bigComets.length; i++) {
          const bc = bigComets[i];
          const dx = spaceship.x - bc.x;
          const dy = spaceship.y - bc.y;
          const dist = Math.hypot(dx, dy);
          if (dist < spaceship.size * 1.2 + bc.radius) {
            let nx = dx / dist;
            let ny = dy / dist;
            let overlap = (spaceship.size + bc.radius) - dist;
            let shieldAbsorbed = false;
            
            // Different collision behavior based on ship type
            if (spaceship.type === SHIP_TYPE.LASER) {
              // Heavy cruiser has more mass - is pushed less by big comets
              spaceship.x += nx * (overlap / 6); // Only move 1/6 of normal distance
              spaceship.y += ny * (overlap / 6);
              
              // Heavy cruiser bounces significantly less from big comets
              spaceship.vx = -spaceship.vx * 0.15; // 70% less bounce
              spaceship.vy = -spaceship.vy * 0.15;
              
              // Add some backward thrust to counter the impact
              spaceship.vx -= nx * 100;
              spaceship.vy -= ny * 100;
              
              // Check if the shield can absorb the hit from the big comet
              if (spaceship.hasShield && spaceship.shieldHealth > 0) {
                // Calculate angle of impact to check if it's in the front arc for frontal shield
                const impactAngle = Math.atan2(ny, nx);
                const angleRelativeToShip = ((impactAngle - spaceship.angle) + Math.PI * 2) % (Math.PI * 2);
                
                // For frontal shield, check if the impact is in the front 120° arc (-π/3 to π/3)
                const isInFrontArc = (angleRelativeToShip < Math.PI / 3 || angleRelativeToShip > Math.PI * 5 / 3);
                
                // Big comets are more powerful - they require 2 shield hit points to fully absorb
                if (!spaceship.frontArcOnly || (spaceship.frontArcOnly && isInFrontArc)) {
                  // Shield absorbed the hit!
                  shieldAbsorbed = true;
                  
                  // Big comets deplete 2 shield points if possible
                  if (spaceship.shieldHealth >= 2) {
                    spaceship.shieldHealth -= 2;
                  } else {
                    // If only 1 shield point left, use it and take partial damage
                    spaceship.shieldHealth = 0;
                    // Still take damage, but only 1 point instead of full damage
                    // Save previous health before reducing and trigger shake effect
                    spaceship.previousHitPoints = spaceship.hitPoints;
                    spaceship.hitPoints--;
                    spaceship.healthShakeTimer = 0.5; // Half a second of shake
                    spaceship.healthScaleTimer = 0.3; // Scale animation for 0.3 seconds
                  }
                  
                  spaceship.shieldFlashTimer = 0.6; // Longer flash for big impact
                  
                  // Play shield hit sound (louder for big comet)
                  if (soundEnabled) {
                    hitSoundPool[nextHitSoundIndex].currentTime = 0;
                    hitSoundPool[nextHitSoundIndex].volume = 0.5; // Louder for big impact
                    hitSoundPool[nextHitSoundIndex].play();
                    nextHitSoundIndex = (nextHitSoundIndex + 1) % HIT_SOUND_POOL_SIZE;
                  }
                  
                  // Create bigger shield impact effect at the collision point
                  // Calculate collision point
                  const impactX = spaceship.x - nx * spaceship.size;
                  const impactY = spaceship.y - ny * spaceship.size;
                  
                  // Visual effect at impact point
                  createBulletImpact(
                    impactX, 
                    impactY, 
                    2.0, // Larger scale for big comet
                    spaceship.shieldHealth > 0 ? "#00AAFF" : "#FF6600" // Blue or orange based on shield health
                  );
                }
              }
            } else {
              // Normal collision dynamics for other ships
              spaceship.x += nx * (overlap / 2);
              spaceship.y += ny * (overlap / 2);
              spaceship.vx = -spaceship.vx * 0.5;
              spaceship.vy = -spaceship.vy * 0.5;
            }
            
            // If shield didn't fully absorb, damage spaceship
            if (!shieldAbsorbed) {
              // Save previous health before reducing and trigger shake effect
              spaceship.previousHitPoints = spaceship.hitPoints;
              spaceship.hitPoints--;
              spaceship.hitFlashTimer = 0.3;
              spaceship.healthShakeTimer = 0.5; // Half a second of shake
              spaceship.healthScaleTimer = 0.3; // Scale animation for 0.3 seconds
              
              // Create impact effect
              if (soundEnabled) {
                hitSoundPool[nextHitSoundIndex].currentTime = 0;
                hitSoundPool[nextHitSoundIndex].volume = 0.6; // Louder for big comet impact
                hitSoundPool[nextHitSoundIndex].play();
                nextHitSoundIndex = (nextHitSoundIndex + 1) % HIT_SOUND_POOL_SIZE;
              }
            }
            
            // Check if the ship was destroyed
            if (spaceship.hitPoints <= 0) {
              comets = [];
              bigComets = [];
              bullets = [];
              sparks = [];
              createHugeExplosion(spaceship.x, spaceship.y);
              gameState = GAME_STATE.GAME_OVER;
              bgMusic.pause(); // Stop the gameplay music
              defeatSound.play().catch(err => console.error("Error playing defeat sound:", err));
              
              // Check and update high score in Firebase
              updateHighScore(score, currentDifficulty)
                .then(result => {
                  console.log("High score check complete:", result);
                  if (result.isNewHighScore) {
                    console.log("NEW HIGH SCORE!");
                  }
                });
              
              return;
            }
          }
        }

        // Movement controls
        if (keys["ArrowUp"]) {
          spaceship.vx += Math.cos(spaceship.angle) * SHIP_ACCEL * spaceship.speedModifier * dt;
          spaceship.vy += Math.sin(spaceship.angle) * SHIP_ACCEL * spaceship.speedModifier * dt;
        }
        if (keys["ArrowDown"]) {
          spaceship.vx -= Math.cos(spaceship.angle) * SHIP_REVERSE * spaceship.speedModifier * dt;
          spaceship.vy -= Math.sin(spaceship.angle) * SHIP_REVERSE * spaceship.speedModifier * dt;
        }
        
        // Change EMP key from E to F and add cooldown check
        // For the DEFAULT ship type (Nova Striker)
        if (spaceship.type === SHIP_TYPE.DEFAULT) {
          // Disable E key for EMP
          if (keys["KeyE"] || keys["e"] || keys["E"]) {
            // Do nothing - we've changed to F key
          }
          
          // Enable F key for EMP with cooldown
          if ((keys["KeyF"] || keys["f"] || keys["F"]) && 
              !spaceship.empActive && !spaceship.empCooldown) {
            // Only activate if EMP is not already active or in cooldown
            activateEMPBlast(); // Use existing function for consistency
          }
        }
        if (keys["Space"]) {
          // Quick brake
          let speed = Math.sqrt(spaceship.vx ** 2 + spaceship.vy ** 2);
          if (speed > 0) {
            let deceleration = SHIP_REVERSE * dt;
            let newSpeed = Math.max(0, speed - deceleration);
            spaceship.vx = (spaceship.vx / speed) * newSpeed;
            spaceship.vy = (spaceship.vy / speed) * newSpeed;
          }
        }
        if (keys["ArrowLeft"]) {
          // Apply rotation speed reduction when laser is active
          if (spaceship.type === SHIP_TYPE.LASER && spaceship.laserActive) {
            // Significantly slower rotation when laser is active (85% reduction)
            spaceship.angle -= SHIP_ROT_SPEED * dt * 0.75;
          } else {
            spaceship.angle -= SHIP_ROT_SPEED * dt;
          }
        }
        if (keys["ArrowRight"]) {
          // Apply rotation speed reduction when laser is active
          if (spaceship.type === SHIP_TYPE.LASER && spaceship.laserActive) {
            // Significantly slower rotation when laser is active (85% reduction)
            spaceship.angle += SHIP_ROT_SPEED * dt * 0.75;
          } else {
            spaceship.angle += SHIP_ROT_SPEED * dt;
          }
        }

        // Spaceship movement
        spaceship.x += spaceship.vx * dt;
        spaceship.y += spaceship.vy * dt;
        spaceship.vx *= FRICTION;
        spaceship.vy *= FRICTION;
        
        // Apply different bounce behavior based on ship type
        if (spaceship.type === SHIP_TYPE.LASER) {
          // Heavy cruiser bounces much less (only 10% of velocity retained on bounce)
          bounce(spaceship, spaceship.size, 0.1);
        } else {
          // Default bounce for other ships (30% of velocity retained)
          bounce(spaceship, spaceship.size, 0.3);
        }

        // Shooting
        lastBulletTime += dt * 1000;
        if (lastBulletTime > BULLET_INTERVAL) {
          // Fire bullets from different gun positions
          const noseX = spaceship.x + Math.cos(spaceship.angle) * spaceship.size;
          const noseY = spaceship.y + Math.sin(spaceship.angle) * spaceship.size;
          const perpX = Math.cos(spaceship.angle + Math.PI / 2);
          const perpY = Math.sin(spaceship.angle + Math.PI / 2);
          
          // Positions for each gun
          const topGunX = spaceship.x + Math.cos(spaceship.angle) * (spaceship.size * 0.8) + perpX * (spaceship.size * 0.4);
          const topGunY = spaceship.y + Math.sin(spaceship.angle) * (spaceship.size * 0.8) + perpY * (spaceship.size * 0.4);
          
          const bottomGunX = spaceship.x + Math.cos(spaceship.angle) * (spaceship.size * 0.8) - perpX * (spaceship.size * 0.4);
          const bottomGunY = spaceship.y + Math.sin(spaceship.angle) * (spaceship.size * 0.8) - perpY * (spaceship.size * 0.4);

          // Bullet spawn positions from each gun
          const spawnPositions = [
            { x: topGunX, y: topGunY },        // Top gun
            { x: noseX, y: noseY },            // Center gun 
            { x: bottomGunX, y: bottomGunY }   // Bottom gun
          ];
          
          // Determine how many bullets to fire based on power-up
          let bulletsPerGun = 1;
          
          if (spaceship.tripleShot) {
            // In infinity mode with high spawn rate, use enhanced shot
            if (currentDifficulty === DIFFICULTY.INFINITY && 
                infinityModeSpawnMultiplier >= 1.5) {
              bulletsPerGun = ENHANCED_SHOT_MULTIPLIER;
            } else {
              bulletsPerGun = 3; // Normal triple shot
            }
          }
          
          // Fire from each gun position
          for (let gunIndex = 0; gunIndex < spawnPositions.length; gunIndex++) {
            const pos = spawnPositions[gunIndex];
            
            // Fire multiple bullets from each gun if triple shot is active
            for (let bulletIndex = 0; bulletIndex < bulletsPerGun; bulletIndex++) {
              // Compute angle with variation
              let angleVariation;
              
              if (bulletsPerGun === 1) {
                // Normal mode - slight random variation
                angleVariation = (gunIndex === 1) ? 
                  randomRange(-0.03, 0.03) : // Center gun - less variation
                  randomRange(-0.05, 0.05);  // Side guns - more variation
              } else {
                // Triple shot mode - spread pattern
                // Calculate spread based on bullet index (-0.12, 0, 0.12 radians)
                const spreadFactor = 0.12; // About 7 degrees
                angleVariation = (bulletIndex - 1) * spreadFactor;
                // Add a tiny random variation for natural feel
                angleVariation += randomRange(-0.01, 0.01);
              }
              
              // Final bullet angle
              const angle = spaceship.angle + angleVariation;
              
              // Create and add the bullet
              const bullet = {
                x: pos.x,
                y: pos.y,
                vx: Math.cos(angle) * BULLET_SPEED + spaceship.vx,
                vy: Math.sin(angle) * BULLET_SPEED + spaceship.vy,
                radius: BULLET_RADIUS,
                isMissile: false
              };
              bullets.push(bullet);
            }
          }
          bulletSoundPool[nextBulletSoundIndex].currentTime = 0;
          bulletSoundPool[nextBulletSoundIndex].play();
          nextBulletSoundIndex = (nextBulletSoundIndex + 1) % BULLET_SOUND_POOL_SIZE;
          lastBulletTime = 0;
          // Sparks
          const numSparks = Math.floor(randomRange(1, 3));
          for (let i = 0; i < numSparks; i++) {
            const baseSparkOffset = Math.PI / 8;
            const sparkAngle = spaceship.angle + (Math.random() < 0.5 ? baseSparkOffset : -baseSparkOffset) + randomRange(-0.05, 0.05);
            sparks.push({
              angle: sparkAngle,
              length: randomRange(2, 5),
              lifetime: 0.2
            });
          }
        }

        // Update sparks
        for (let i = sparks.length - 1; i >= 0; i--) {
          sparks[i].lifetime -= dt;
          if (sparks[i].lifetime <= 0) {
            sparks.splice(i, 1);
          }
        }

        // Update bullets
        for (let i = bullets.length - 1; i >= 0; i--) {
          let b = bullets[i];
          b.x += b.vx * dt;
          b.y += b.vy * dt;
          // off screen => remove
          if (b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) {
            bullets.splice(i, 1);
          }
        }

        // Update comets
        for (let c of comets) {
          if (c.slowEffectTimer > 0) {
            c.slowEffectTimer -= dt;
            if (c.slowEffectTimer < 0) c.slowEffectTimer = 0;
          }
          if (c.indestructableTimer > 0) {
            c.indestructableTimer -= dt;
            if (c.indestructableTimer < 0) c.indestructableTimer = 0;
          }
          if (c.hitEffectTimer > 0) {
            c.hitEffectTimer -= dt;
            if (c.hitEffectTimer < 0) c.hitEffectTimer = 0;
          }
          c.x += c.vx * dt;
          c.y += c.vy * dt;
          c.vx *= COMET_FRICTION;
          c.vy *= COMET_FRICTION;
          // never drop below COMET_MIN_SPEED
          let speed = Math.hypot(c.vx, c.vy);
          if (speed < COMET_MIN_SPEED && speed > 0) {
            let factor = COMET_MIN_SPEED / speed;
            c.vx *= factor;
            c.vy *= factor;
          }
          bounce(c, c.radius);

          c.trailTimer += dt;
          if (c.trailTimer >= 0.05) { // TRAIL_INTERVAL
            c.trailTimer -= 0.05;
            c.trail.push({ x: c.x, y: c.y });
            if (c.trail.length > 5) {
              c.trail.shift();
            }
          }
        }

        // update big comets
        updateBigComets(dt);
        updateTimers(dt);

        // Bullets vs Comets
        for (let i = bullets.length - 1; i >= 0; i--) {
          let b = bullets[i];
          let bulletHit = false;
          for (let j = comets.length - 1; j >= 0; j--) {
            let c = comets[j];
            if (c.indestructableTimer > 0) continue;
            let dx = b.x - c.x;
            let dy = b.y - c.y;
            if (Math.hypot(dx, dy) < c.radius) {
              bulletHit = true;
              // Throttled bullet hit sound
              if (soundEnabled) {
                const now = performance.now();
                // Only play sound if enough time has passed since last hit sound
                // and last bullet in HP (more satisfying on final hit)
                if ((now - lastHitSoundTime > HIT_SOUND_THROTTLE) || (c.hitPoints === 1)) {
                  hitSoundPool[nextHitSoundIndex].currentTime = 0;
                  hitSoundPool[nextHitSoundIndex].play();
                  nextHitSoundIndex = (nextHitSoundIndex + 1) % HIT_SOUND_POOL_SIZE;
                  lastHitSoundTime = now;
                }
              }
              
              // Apply damage based on bullet type
              if (b.isMissile) {
                if (b.isPowerfulMissile) {
                  // Super missiles do massive damage (20x normal bullet)
                  c.hitPoints -= b.missilePower || 20;
                  // Create even larger impact effect with orange color
                  createBulletImpact(b.x, b.y, 2.5, "orange");
                  // Create additional explosion effect
                  createSmallExplosion(b.x, b.y);
                } else {
                  // Regular missiles do moderate damage
                  c.hitPoints -= MISSILE_DAMAGE;
                  // Create larger impact effect with yellow color
                  createBulletImpact(b.x, b.y, 1.5, "yellow");
                }
              } else {
                // Normal bullet damage
                c.hitPoints--;
                // Create regular impact effect
                createBulletImpact(b.x, b.y);
              }
              
              // slow effect if tier 3
              if (c.tier === 3 && c.slowEffectTimer === 0) {
                c.vx *= 0.66;
                c.vy *= 0.66;
                c.slowEffectTimer = 0.5;
              }
              c.hitEffectTimer = 0.5;
              // destroyed
              if (c.hitPoints <= 0) {
                createSmallExplosion(c.x, c.y);
                // if bigger than tier1 => split
                if (c.tier > 1) {
                  const newTier = c.tier - 1;
                  const baseSpeed = Math.hypot(c.vx, c.vy);
                  let splits = Math.floor(randomRange(2, 6));
                  const offset = 50;
                  for (let k = 0; k < splits; k++) {
                    let newAngle = Math.random() * 2 * Math.PI;
                    let factor = randomRange(0.7, 0.8);
                    let extraFactor = randomRange(1.2, 1.5);
                    let newSpeed = baseSpeed * factor * extraFactor;
                    spawnComet(
                      newTier,
                      c.x + Math.cos(newAngle) * offset,
                      c.y + Math.sin(newAngle) * offset,
                      Math.cos(newAngle) * newSpeed,
                      Math.sin(newAngle) * newSpeed
                    );
                    // short indestructable so they don't instantly collide
                    comets[comets.length - 1].indestructableTimer = 0.01;
                  }
                }
                score += 10;
                comets.splice(j, 1);
              }
              break;
            }
          }
          // if not hit normal comet, check big comet
          if (!bulletHit) {
            for (let j = bigComets.length - 1; j >= 0; j--) {
              let bc = bigComets[j];
              let dx = b.x - bc.x;
              let dy = b.y - bc.y;
              if (Math.hypot(dx, dy) < bc.radius) {
                bulletHit = true;
                
                // Reduce hit points
                bc.hitPoints--;
                bc.hitCount++;
                
                // Set flash timer for visual feedback
                bc.hitFlashTimer = 0.1;
                
                // Create bullet impact visual effect at the bullet's position
                createBulletImpact(b.x, b.y);
                
                // Increase shake frequency but reduce distance based on damage
                // Smaller shake amplitude but higher frequency as damage increases
                bc.shakeAmount = 3 + (bc.hitCount / BIG_COMET_HEALTH) * 8;
                bc.shakeTimer = 0.2 + (bc.hitCount / BIG_COMET_HEALTH) * 0.4; // Longer shake duration with damage
                
                // Play hit sound
                if (soundEnabled) {
                  const now = performance.now();
                  // Only play sound occasionally or on milestone hits
                  if ((now - lastHitSoundTime > HIT_SOUND_THROTTLE * 2) || 
                      (bc.hitPoints % 500 === 0) || // Every 500 hits
                      (bc.hitPoints <= 200)) {      // Last 200 hits
                    hitSoundPool[nextHitSoundIndex].currentTime = 0;
                    hitSoundPool[nextHitSoundIndex].play();
                    nextHitSoundIndex = (nextHitSoundIndex + 1) % HIT_SOUND_POOL_SIZE;
                    lastHitSoundTime = now;
                  }
                }
                
                break;
              }
            }
          }
          if (bulletHit) {
            bullets.splice(i, 1);
          }
        }

        // check collisions among comets
        checkCometCollisions();

        checkBigCometCollisions();

        // spawn new comets over time based on difficulty
        if (spawnAllowed) {
          cometSpawnTimer += dt;
          
          // Get base spawn interval
          let spawnInterval = randomRange(COMET_SPAWN_MIN, COMET_SPAWN_MAX);
          
          // Apply difficulty multiplier (higher multiplier = lower rate)
          let difficultyMultiplier;
          if (currentDifficulty === DIFFICULTY.INFINITY) {
            // For infinity mode, use the dynamic multiplier
            difficultyMultiplier = 1 / infinityModeSpawnMultiplier;
          } else {
            // For other modes, use the fixed multiplier
            difficultyMultiplier = 1 / SPAWN_RATE_MULTIPLIER[currentDifficulty];
          }
          
          // Apply the multiplier to spawn interval
          spawnInterval *= difficultyMultiplier;
          
          if (cometSpawnTimer > spawnInterval) {
            // Scale spawn count based on area
            let area = canvas.width * canvas.height;
            let scaleFactor = area / 480000;
            scaleFactor = Math.max(0.5, Math.min(2, scaleFactor));
            
            // Determine base spawn count
            let baseSpawnCount = COMET_SPAWN_BATCH_MIN + 
              Math.floor(Math.random() * (COMET_SPAWN_BATCH_MAX - COMET_SPAWN_BATCH_MIN + 1));
            
            // Apply difficulty modifier to spawn count
            let spawnCount = Math.floor(baseSpawnCount * scaleFactor);
            
            // Spawn the comets
            for (let i = 0; i < spawnCount; i++) {
              spawnComet();
            }
            
            cometSpawnTimer = 0;
          }
        }
      }

    })();
  </script>
</body>

</html>