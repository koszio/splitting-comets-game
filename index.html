<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Splitting Comets Game – With Comet Trails and Transparent Comets</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      background: black;
      overflow: hidden;
    }

    canvas {
      display: block;
      background: black;
    }
  </style>
</head>

<body>
  <canvas id="gameCanvas" tabindex="1"></canvas>
  <script>
    (function () {
      /*
        ---- SOUND EFFECTS ----
        bulletSound: 0.2s wood tap
        hitSound: 0.2s flick (each hit plays fully at lower volume)
        explosionSound: using local file "small-explosion-94980.mp3"
      */
      // Use your local file for explosion sounds.
      const explosionSoundURL = "expl-sfx.mp3";
      const bulletSoundSrc = "";
      const hitSoundSrc = "";
      const powerUpSound = new Audio("mixkit-video-game-health-recharge-2837.wav");
      const victorySound = new Audio("mixkit-cheering-crowd-loud-whistle.wav");
      const defeatSound = new Audio("mixkit-arcade-retro-game-over.wav");
      victorySound.volume = 0.4;
      defeatSound.volume = 0.3;

      // Initialize sound system
      let currentMusicTrack = "";
      const bgMusic = new Audio();
      bgMusic.loop = true;
      bgMusic.volume = 0.1;
      let musicEnabled = true; // Track music state
      let soundEnabled = true; // Track sound effects state

      // Function to toggle music on/off
      function toggleMusic() {
        musicEnabled = !musicEnabled;
        soundEnabled = musicEnabled; // Link sound effects to music toggle
        
        if (musicEnabled) {
          // Resume music based on current game state
          if (gameState === "menu" || gameState === "settings") {
            startMenuMusic();
          } else if (gameState === "playing") {
            startGameplayMusic();
          }
          
          // Unmute all sound effects
          powerUpSound.muted = false;
          victorySound.muted = false;
          defeatSound.muted = false;
          
          // Unmute sound pools
          for (let sound of bulletSoundPool) {
            sound.muted = false;
          }
          for (let sound of hitSoundPool) {
            sound.muted = false;
          }
        } else {
          // Pause music
          bgMusic.pause();
          
          // Mute all sound effects
          powerUpSound.muted = true;
          victorySound.muted = true;
          defeatSound.muted = true;
          
          // Mute sound pools
          for (let sound of bulletSoundPool) {
            sound.muted = true;
          }
          for (let sound of hitSoundPool) {
            sound.muted = true;
          }
        }
      }
      
      // Function to toggle all sounds (music and effects)
      function toggleAllSounds() {
        soundEnabled = !soundEnabled;
        
        if (!soundEnabled) {
          // Turn off music
          musicEnabled = false;
          bgMusic.pause();
          
          // Mute all sound effects
          powerUpSound.muted = true;
          victorySound.muted = true;
          defeatSound.muted = true;
          
          // Mute sound pools
          for (let sound of bulletSoundPool) {
            sound.muted = true;
          }
          for (let sound of hitSoundPool) {
            sound.muted = true;
          }
        } else {
          // Unmute all sound effects
          powerUpSound.muted = false;
          victorySound.muted = false;
          defeatSound.muted = false;
          
          // Unmute sound pools
          for (let sound of bulletSoundPool) {
            sound.muted = false;
          }
          for (let sound of hitSoundPool) {
            sound.muted = false;
          }
          
          // Note: music remains off until toggled separately
        }
      }

      // Function to start menu music
      function startMenuMusic() {
        if (currentMusicTrack !== "menu") {
          bgMusic.pause();
          bgMusic.src = "menu_music.mp3"; 
          bgMusic.load();
          if (musicEnabled) {
            bgMusic.play().catch(err => console.error("Error playing menu music:", err));
          }
          currentMusicTrack = "menu";
        } else if (musicEnabled && bgMusic.paused) {
          bgMusic.play().catch(err => console.error("Error resuming menu music:", err));
        }
      }

      // Function to start gameplay music with delay
      function startGameplayMusic() {
        if (currentMusicTrack !== "gameplay") {
          bgMusic.pause();
          bgMusic.src = "ingame_music.mp3";
          bgMusic.load();
          if (musicEnabled) {
            setTimeout(() => {
              bgMusic.play().catch(err => console.error("Error playing gameplay music:", err));
            }, 1300); // 1300ms delay
          }
          currentMusicTrack = "gameplay";
        } else if (musicEnabled && bgMusic.paused) {
          bgMusic.play().catch(err => console.error("Error resuming gameplay music:", err));
        }
      }

      // Add error handling for music loading
      bgMusic.onerror = function() {
        console.error("Error loading music file:", bgMusic.src);
      };

      let gameState = "menu";
      
      // Auto-start menu music when the page loads
      document.addEventListener('DOMContentLoaded', function() {
        // Initialize sound pools before trying to use them
        createSoundPools();
        startMenuMusic();
      });
      
      // Create sound pools
      function createSoundPools() {
        // This function is called early to ensure pools exist before they're used in toggleAllSounds
        if (!bulletSoundPool) bulletSoundPool = [];
        if (!hitSoundPool) hitSoundPool = [];
      }

      // Create a pool for bullet sounds (pool size 3)
      const BULLET_SOUND_POOL_SIZE = 3;
      const bulletSoundPool = [];
      for (let i = 0; i < BULLET_SOUND_POOL_SIZE; i++) {
        let a = new Audio(bulletSoundSrc);
        a.volume = 0.25;
        bulletSoundPool.push(a);
      }
      let nextBulletSoundIndex = 0;

      // Create a pool for hit sounds (pool size 5) at lower volume
      const HIT_SOUND_POOL_SIZE = 500;
      const hitSoundPool = [];
      for (let i = 0; i < HIT_SOUND_POOL_SIZE; i++) {
        let a = new Audio(hitSoundSrc);
        a.volume = 0.2;
        hitSoundPool.push(a);
      }
      let nextHitSoundIndex = 0;

      // ----- BACKGROUND MUSIC -----
      // Background music is now started automatically on page load

      // ----- Setup Canvas -----
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      resizeCanvas();
      window.addEventListener("resize", () => {
        resizeCanvas();
        initStarfield();
      });
      canvas.focus();

      // ----- Global Constants -----
      const SHIP_ROT_SPEED = 6;       // radians/sec
      const SHIP_REVERSE = 400;     // pixels/sec² (braking)
      const BULLET_SPEED = 600;     // pixels/sec
      const BULLET_RADIUS = 4;
      const BULLET_INTERVAL = 30;      // ms between shots
      const FRICTION = 0.99;

      const SHIP_SIZE = 30;      // spaceship size (pixels)
      const SHIP_ACCEL = 800;     // pixels/sec²

      // Normal Comets – speeds: 400 to 700
      const COMET_SPEED_MIN = 400;
      const COMET_SPEED_MAX = 700;
      const COMET_FRICTION = 0.998;
      const MAX_COMET_TIER = 3;
      const BASE_COMET_RADIUS = 30;
      const COMET_SPAWN_MIN = 2;
      const COMET_SPAWN_MAX = 3;
      const COMET_SPAWN_BATCH_MIN = 1;
      const COMET_SPAWN_BATCH_MAX = 3;
      const COMET_MIN_SPEED = 250;

      // Big Comets
      let bigComets = [];
      let bigCometSpawnTimer = 0;
      const BIG_COMET_SPAWN_INTERVAL = 25;
      const BIG_COMET_SPAWN_MAX = 1;
      const DIAGONAL_ANGLES = [Math.PI / 4, 3 * Math.PI / 4, 5 * Math.PI / 4, 7 * Math.PI / 4];
      const BIG_COMET_SPEED_MIN = 150;
      const BIG_COMET_SPEED_MAX = 200;
      const BIG_COMET_COLOR = "#cd7f32";
      const BIG_COMET_SCALE = 5.5;

      // Power‑Up Constants
      const POWERUP_SPAWN_INTERVAL = 15;
      const POWERUP_LIFETIME = 15;
      const POWERUP_BOX_SIZE = 60;
      const POWERUP_RADIUS = POWERUP_BOX_SIZE / 2;

      let powerUps = [];
      let powerUpSpawnTimer = 0;

      // ----- Game State & Timer -----
      let score = 0;
      let gameTime = 0;
      let winTriggered = false;

      // Spaceship
      let spaceship = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        vx: 0,
        vy: 0,
        angle: 0,
        size: SHIP_SIZE,
        hitPoints: 5,
        hitFlashTimer: 0
      };

      let bullets = [];
      let sparks = [];
      let smallExplosionParticles = [];
      let comets = [];

      // ----- Starfield -----
      const NUM_STARS = 500;
      let stars = [];
      function initStarfield() {
        stars = [];
        for (let i = 0; i < NUM_STARS; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const baseSize = Math.random() * 2 + 0.5;
          const flicker = Math.random() < 0.7;
          const sizeVariation = flicker ? (Math.random() * 1 + 0.2) : 0;
          const sizeSpeed = flicker ? (Math.random() * 0.5 + 0.2) : 0;
          const sizeTime = flicker ? Math.random() * Math.PI * 2 : 0;
          stars.push({ x, y, baseSize, sizeVariation, sizeSpeed, sizeTime, flicker });
        }
      }
      initStarfield();
      function updateStarfield(dt) {
        for (let star of stars) {
          if (star.flicker) {
            star.sizeTime += dt * star.sizeSpeed;
          }
        }
      }
      function drawStarfield(ctx) {
        ctx.save();
        for (let star of stars) {
          let currentSize = star.baseSize;
          if (star.flicker) {
            currentSize += star.sizeVariation * Math.sin(star.sizeTime);
            if (currentSize < 0) currentSize = 0;
          }
          let gradient = ctx.createRadialGradient(
            star.x, star.y, currentSize * 0.2,
            star.x, star.y, currentSize
          );
          gradient.addColorStop(0, "rgba(255,255,255,1)");
          gradient.addColorStop(1, "rgba(255,255,255,0)");
          ctx.fillStyle = gradient;
          ctx.shadowBlur = 5;
          ctx.shadowColor = "white";
          ctx.beginPath();
          ctx.arc(star.x, star.y, currentSize, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }

      function generateStonePattern() {
        const baseColors = [
        "#8B4513", // Saddle Brown
          "#A0522D", // Sienna
          "#6B4423", // Deep Brown
          "#8B5742", // Light Brown
          "#654321", // Dark Brown
          "#704214", // Rustic Brown
          "#5C4033", // Rich Brown
          "#4A3728", // Dark Chocolate
          "#6F4E37", // Coffee
          "#7B3F00"  // Chocolate
        ];
        // Pick a random base color
        const baseColor = baseColors[Math.floor(Math.random() * baseColors.length)];

        let patternCanvas = document.createElement("canvas");
        patternCanvas.width = 50;
        patternCanvas.height = 50;
        let pctx = patternCanvas.getContext("2d");

        // Use the chosen base color
        pctx.fillStyle = baseColor;
        pctx.fillRect(0, 0, patternCanvas.width, patternCanvas.height);

        // Add random speckles for texture
        for (let i = 0; i < 20; i++) {
          let x = Math.random() * patternCanvas.width;
          let y = Math.random() * patternCanvas.height;
          let radius = Math.random() * 3;
          // Use random gray values for the speckles
          let gray = Math.floor(100 + Math.random() * 50);
          pctx.fillStyle = `rgb(${gray}, ${gray}, ${gray})`;
          pctx.beginPath();
          pctx.arc(x, y, radius, 0, 2 * Math.PI);
          pctx.fill();
        }

        return ctx.createPattern(patternCanvas, "repeat");
      }

      // ----- Cronos Planet -----
      function drawCronos(ctx) {
        // Planet position & size
        const x = canvas.width * 0.75;
        const y = canvas.height * 0.5;
        const radius = 200; // Planet radius

        // ---------- Planet Gradient ----------
        const grad = ctx.createRadialGradient(x, y, radius * 0.2, x, y, radius);
        grad.addColorStop(0.2, "#c9b8a3"); // center
        grad.addColorStop(0.8, "#b09b83");
        grad.addColorStop(0.6, "#97856f");
        grad.addColorStop(1, "#7f6f5a"); // outer edge

        // ---------- Ring Geometry ----------
        const ringOuter = radius * 1.9;   // Outer ellipse radius
        const ringInner = radius * 1.25;  // Inner ellipse radius
        const ringFlatten = 0.45;         // How "flat" the ring ellipse is

        // ---------- Ring Pattern with Dust ----------
        const ringCanvas = document.createElement("canvas");
        ringCanvas.width = 80;
        ringCanvas.height = 40;
        const ringCtx = ringCanvas.getContext("2d");

        // Semi‑transparent dark fill
        ringCtx.fillStyle = "rgba(60,50,40,0.4)";
        ringCtx.fillRect(0, 0, ringCanvas.width, ringCanvas.height);

        // Scatter small black dots for dust
        for (let i = 0; i < 30; i++) {
          const rx = Math.random() * ringCanvas.width;
          const ry = Math.random() * ringCanvas.height;
          ringCtx.fillStyle = "rgba(0,0,0,0.6)";
          ringCtx.beginPath();
          ringCtx.arc(rx, ry, 1, 0, 2 * Math.PI);
          ringCtx.fill();
        }

        const ringPattern = ctx.createPattern(ringCanvas, "repeat");

        // Helper function: draw half of a donut arc from angleStart to angleEnd
        // Using "evenodd" so the inner ellipse carves out a hole.
        function drawDonutArc(angleStart, angleEnd) {
          ctx.beginPath();
          // Outer ellipse arc
          ctx.ellipse(0, 0, ringOuter, ringOuter * ringFlatten, 0, angleStart, angleEnd, true);
          // Inner ellipse arc (reverse)
          ctx.ellipse(0, 0, ringInner, ringInner * ringFlatten, 0, angleEnd, angleStart, false);
          ctx.fillStyle = ringPattern;
          ctx.fill("evenodd");
        }

        // ---------- DRAW THE RING BACK HALF ----------
        // (the portion behind the planet)
        ctx.save();
        // Move to planet center & tilt the ring
        ctx.translate(x, y);
        ctx.rotate(-Math.PI / 6);
        // e.g. 0..Math.PI is the "back half" after rotation
        drawDonutArc(0, Math.PI);
        ctx.restore();

        // ---------- DRAW THE PLANET ----------
        ctx.save();
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI);
        ctx.fill();
        ctx.restore();

        // ---------- DRAW THE RING FRONT HALF ----------
        // (the portion in front of the planet)
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(-Math.PI / 6);
        // front half is Math.PI..2*Math.PI
        drawDonutArc(Math.PI, 2 * Math.PI);
        ctx.restore();
      }


      function drawMusicIcon() {
        const iconSize = 40;
        const margin = 20;
        const x = margin;
        const y = margin;
        
        ctx.save();
        ctx.fillStyle = "white";
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        
        // Draw speaker base
        ctx.beginPath();
        ctx.moveTo(x, y + iconSize/2);
        ctx.lineTo(x + iconSize/3, y + iconSize/2);
        ctx.lineTo(x + iconSize*2/3, y);
        ctx.lineTo(x + iconSize*2/3, y + iconSize);
        ctx.lineTo(x + iconSize/3, y + iconSize/2);
        ctx.closePath();
        ctx.fill();
        
        // Draw sound waves if sound is enabled (tied to music enabled)
        if (soundEnabled) {
          // First wave
          ctx.beginPath();
          ctx.arc(x + iconSize*2/3, y + iconSize/2, iconSize/3, -Math.PI/4, Math.PI/4);
          ctx.stroke();
          
          // Second wave
          ctx.beginPath();
          ctx.arc(x + iconSize*2/3, y + iconSize/2, iconSize*2/3, -Math.PI/4, Math.PI/4);
          ctx.stroke();
        } else {
          // Draw X over the speaker when sound is off
          ctx.beginPath();
          ctx.moveTo(x + iconSize/3, y + iconSize/4);
          ctx.lineTo(x + iconSize, y + iconSize*3/4);
          ctx.stroke();
          
          ctx.beginPath();
          ctx.moveTo(x + iconSize, y + iconSize/4);
          ctx.lineTo(x + iconSize/3, y + iconSize*3/4);
          ctx.stroke();
        }
        
        ctx.restore();
      }

      function drawHealthBar() {
        const barWidth = 100;
        const barHeight = 15;
        const margin = 20;
        const x = canvas.width - margin - barWidth;
        const y = margin;
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, barWidth, barHeight);
        let hpFraction = spaceship.hitPoints / 5;
        ctx.fillStyle = "red";
        ctx.fillRect(x, y, barWidth * hpFraction, barHeight);
      }

      function spawnPowerUp() {
        let loc = getSpawnLocation();
        return {
          x: loc.x,
          y: loc.y,
          vx: randomRange(-50, 50),
          vy: randomRange(-50, 50),
          lifetime: 10,
          radius: POWERUP_RADIUS
        };
      }

      // Timers
      let lastBulletTime = 0;
      let cometSpawnTimer = 0;

      // Big Comet logic
      function updateBigComets(dt) {
        for (let i = bigComets.length - 1; i >= 0; i--) {
          let bc = bigComets[i];
          bc.x += bc.vx * dt;
          bc.y += bc.vy * dt;
          if (bc.x < -bc.radius || bc.x > canvas.width + bc.radius ||
            bc.y < -bc.radius || bc.y > canvas.height + bc.radius) {
            bigComets.splice(i, 1);
          }
        }
      }

      function updateTimers(dt) {
        bigCometSpawnTimer += dt;
        if (bigCometSpawnTimer >= BIG_COMET_SPAWN_INTERVAL) {
          for (let i = 0; i < BIG_COMET_SPAWN_MAX; i++) {
            spawnBigComet();
          }
          bigCometSpawnTimer = 0;
        }
      }

      // INPUT HANDLING
      const keys = {};
      window.addEventListener("keydown", (e) => {
        // Music toggle with 'M' key (in any game state)
        if (e.key.toLowerCase() === "m" || e.code === "KeyM") {
          toggleMusic();
        }
        
        // Open settings with Escape key during gameplay
        if (gameState === "playing" && (e.key === "Escape" || e.keyCode === 27)) {
          gameState = "settings";
        }
        
        if (gameState === "menu") {
          startMenuMusic();
          
          if (e.key === "Enter" || e.code === "Enter" || e.keyCode === 13) {
            gameState = "playing";
            score = 0;
            gameTime = 0;
            winTriggered = false;
            startGameplayMusic();
          } else if (e.key.toLowerCase() === "s" || e.code === "KeyS") {
            gameState = "settings";
          }
        } else if (gameState === "settings" && (e.key === "Escape" || e.keyCode === 27)) {
          gameState = "menu";
          startMenuMusic();
        } else if ((gameState === "gameover" || gameState === "win") &&
          (e.key === "Enter" || e.code === "Enter" || e.keyCode === 13)) {
          // Stop victory/defeat sounds before restarting
          victorySound.pause();
          victorySound.currentTime = 0;
          defeatSound.pause();
          defeatSound.currentTime = 0;
          
          restartGame();
          gameState = "menu";
          startMenuMusic();
        }
        
        keys[e.key] = true;
        e.preventDefault();
      });
      window.addEventListener("keyup", (e) => {
        keys[e.key] = false;
        e.preventDefault();
      });


      let touchStartX = null, touchStartY = null;
      canvas.addEventListener("touchstart", function (e) {
        e.preventDefault();
        let touch = e.touches[0];
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
      }, false);
      canvas.addEventListener("touchmove", function (e) {
        e.preventDefault();
        let touch = e.touches[0];
        let deltaX = touch.clientX - touchStartX;
        let deltaY = touch.clientY - touchStartY;
        if (deltaX > 20) {
          keys["ArrowRight"] = true;
          keys["ArrowLeft"] = false;
        } else if (deltaX < -20) {
          keys["ArrowLeft"] = true;
          keys["ArrowRight"] = false;
        } else {
          keys["ArrowLeft"] = false;
          keys["ArrowRight"] = false;
        }
        if (deltaY < -20) {
          keys["ArrowUp"] = true;
          keys["ArrowDown"] = false;
        } else if (deltaY > 20) {
          keys["ArrowDown"] = true;
          keys["ArrowUp"] = false;
        } else {
          keys["ArrowUp"] = false;
          keys["ArrowDown"] = false;
        }
      }, false);
      canvas.addEventListener("touchend", function (e) {
        e.preventDefault();
        keys["ArrowUp"] = false;
        keys["ArrowDown"] = false;
        keys["ArrowLeft"] = false;
        keys["ArrowRight"] = false;
        touchStartX = null;
        touchStartY = null;
      }, false);

      // Utility
      function randomRange(min, max) {
        return Math.random() * (max - min) + min;
      }
      function randomColor() {


        const hue = Math.floor(Math.random() * 360);
        return "hsl(" + hue + ", 70%, 30%)";
      }
      function bounce(obj, radius, damping = 1) {
        if (obj.x - radius < 0) {
          obj.x = radius;
          obj.vx = -obj.vx * damping;
        }
        if (obj.x + radius > canvas.width) {
          obj.x = canvas.width - radius;
          obj.vx = -obj.vx * damping;
        }
        if (obj.y - radius < 0) {
          obj.y = radius;
          obj.vy = -obj.vy * damping;
        }
        if (obj.y + radius > canvas.height) {
          obj.y = canvas.height - radius;
          obj.vy = -obj.vy * damping;
        }
      }
      function roundRect(ctx, x, y, width, height, radius) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      }

      // 1) Generate Comet Shape with freq/phase:
      function generateCometShape(segments) {
        let shape = [];
        for (let i = 0; i < segments; i++) {
          let angle = i * 2 * Math.PI / segments;
          // Make comets more round by reducing the factor variation (0.6 -> 0.3)
          let factor = 1 + (Math.random() * 0.3 - 0.15);
          // Increase frequency to make them rotate faster (multiply by 2)
          let frequency = (Math.random() * 2 + 1) * 2; // ~2..6
          let phase = Math.random() * 2 * Math.PI;
          shape.push({ angle, factor, frequency, phase });
        }
        return shape;
      }


      function randomRockColor() {
        const colors = [
          "#4B4B4B", // Dark gray
       
        ];
        return colors[Math.floor(Math.random() * colors.length)];
      }



      // 2) Spawn Comet with optional morph
      function spawnComet(tier = MAX_COMET_TIER, x, y, vx, vy) {
        if (x === undefined || y === undefined) {
          let loc = getSpawnLocation();
          x = loc.x;
          y = loc.y;
        }
        if (vx === undefined || vy === undefined) {
          const angle = Math.random() * Math.PI * 2;
          const speed = randomRange(COMET_SPEED_MIN, COMET_SPEED_MAX);
          vx = Math.cos(angle) * speed;
          vy = Math.sin(angle) * speed;
        }
        const radius = BASE_COMET_RADIUS * Math.pow(0.6, MAX_COMET_TIER - tier);
        let hp;
        if (tier === 3) hp = 5;
        else if (tier === 2) hp = 4;
        else hp = 3;

        // Add more segments to make comets rounder (8 -> 12)
        const segments = 12;
        
        const comet = {
          x, y, vx, vy,
          radius,
          tier,
          color: randomRockColor(),
          hitPoints: hp,
          hitEffectTimer: 0,
          slowEffectTimer: 0,
          indestructableTimer: 0,
          oldVX: vx,
          oldVY: vy,
          trail: [],
          trailTimer: 0,
          shape: generateCometShape(segments),
          pattern: generateStonePattern(),
          morph: true,
          // Add rotation speed
          rotationSpeed: randomRange(1, 3)
        };
        comets.push(comet);
      }

      // Additional helper for spawn location
      function getQuadrant(x, y) {
        const midX = canvas.width / 2;
        const midY = canvas.height / 2;
        if (x < midX && y < midY) return "top-left";
        if (x >= midX && y < midY) return "top-right";
        if (x < midX && y >= midY) return "bottom-left";
        return "bottom-right";
      }
      function isInSameQuadrant(x1, y1, x2, y2) {
        return getQuadrant(x1, y1) === getQuadrant(x2, y2);
      }
      function getSpawnLocation() {
        let loc, attempt = 0;
        do {
          if (Math.random() < 0.5) {
            loc = { x: randomRange(0, canvas.width), y: 0 };
          } else {
            loc = { x: randomRange(0, canvas.width), y: canvas.height };
          }
          attempt++;
          if (attempt > 10) break;
        } while (isInSameQuadrant(loc.x, loc.y, spaceship.x, spaceship.y));
        return loc;
      }

      // -------------- PLACEHOLDERS FILLED BELOW -------------- //

      // Explosion Effects
      function createSmallExplosion(x, y) {
        if (soundEnabled) {
          let exp = new Audio(explosionSoundURL);
          exp.volume = 0.125;
          exp.play().catch(err => console.error("Explosion play error:", err));
        }
        const count = 10;
        for (let i = 0; i < count; i++) {
          let angle = Math.random() * Math.PI * 2;
          let speed = randomRange(50, 150);
          smallExplosionParticles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            lifetime: randomRange(0.3, 0.7),
            size: randomRange(2, 4),
            color: "orange"
          });
        }
      }

      function createHugeExplosion(x, y) {
        if (soundEnabled) {
          let exp = new Audio(explosionSoundURL);
          exp.volume = 1.0;
          exp.play().catch(err => console.error("Huge explosion play error:", err));
        }
        const count = 50;
        for (let i = 0; i < count; i++) {
          let angle = Math.random() * Math.PI * 2;
          let speed = randomRange(100, 300);
          smallExplosionParticles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            lifetime: randomRange(0.8, 1.5),
            size: randomRange(5, 10),
            color: "orange"
          });
        }
      }

      function updateExplosionParticles(dt) {
        for (let i = smallExplosionParticles.length - 1; i >= 0; i--) {
          const p = smallExplosionParticles[i];
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.lifetime -= dt;
          p.size *= 0.98;
          if (p.lifetime <= 0) {
            smallExplosionParticles.splice(i, 1);
          }
        }
      }

      function checkCometCollisions() {
        let indicesToRemove = new Set();
        for (let i = 0; i < comets.length; i++) {
          for (let j = i + 1; j < comets.length; j++) {
            let c1 = comets[i];
            let c2 = comets[j];
            let dx = c2.x - c1.x;
            let dy = c2.y - c1.y;
            let dist = Math.hypot(dx, dy);
            let minDist = c1.radius + c2.radius;
            // Colliding
            if (dist < minDist && dist > 0) {
              // If either is < MAX tier, we remove it
              if (c1.tier < MAX_COMET_TIER) {
                indicesToRemove.add(i);
                createSmallExplosion(c1.x, c1.y);
                score += 5;
              }
              if (c2.tier < MAX_COMET_TIER) {
                indicesToRemove.add(j);
                createSmallExplosion(c2.x, c2.y);
                score += 5;
              }
              // If both are MAX tier, bounce
              if (c1.tier === MAX_COMET_TIER && c2.tier === MAX_COMET_TIER) {
                let nx = dx / dist;
                let ny = dy / dist;
                let dvx = c1.vx - c2.vx;
                let dvy = c1.vy - c2.vy;
                let dot = dvx * nx + dvy * ny;
                if (dot <= 0) {
                  let impulse = dot;
                  c1.vx -= impulse * nx;
                  c1.vy -= impulse * ny;
                  c2.vx += impulse * nx;
                  c2.vy += impulse * ny;
                  let overlap = minDist - dist;
                  c1.x -= nx * overlap / 2;
                  c1.y -= ny * overlap / 2;
                  c2.x += nx * overlap / 2;
                  c2.y += ny * overlap / 2;
                }
              }
            }
          }
        }
        // Remove comets that were marked
        comets = comets.filter((_, index) => !indicesToRemove.has(index));
      }


      function checkBigCometCollisions() {
        // Big Comets vs. Big Comets
        for (let i = 0; i < bigComets.length; i++) {
          for (let j = i + 1; j < bigComets.length; j++) {
            let bc1 = bigComets[i];
            let bc2 = bigComets[j];
            let dx = bc2.x - bc1.x;
            let dy = bc2.y - bc1.y;
            let dist = Math.hypot(dx, dy);
            let minDist = bc1.radius + bc2.radius;
            if (dist < minDist && dist > 0) {
              let nx = dx / dist;
              let ny = dy / dist;
              let overlap = minDist - dist;
              // Bounce them apart equally
              bc1.x -= nx * (overlap / 2);
              bc1.y -= ny * (overlap / 2);
              bc2.x += nx * (overlap / 2);
              bc2.y += ny * (overlap / 2);
              // Adjust velocities (optional, to simulate a bounce)
              let impulse = (bc1.vx - bc2.vx) * nx + (bc1.vy - bc2.vy) * ny;
              if (impulse < 0) {
                bc1.vx -= impulse * nx;
                bc1.vy -= impulse * ny;
                bc2.vx += impulse * nx;
                bc2.vy += impulse * ny;
              }
            }
          }
        }

        // Big Comets vs. Normal Comets
        for (let i = 0; i < bigComets.length; i++) {
          for (let j = 0; j < comets.length; j++) {
            let bc = bigComets[i];
            let c = comets[j];
            let dx = c.x - bc.x;
            let dy = c.y - bc.y;
            let dist = Math.hypot(dx, dy);
            let minDist = bc.radius + c.radius;
            if (dist < minDist && dist > 0) {
              let nx = dx / dist;
              let ny = dy / dist;
              let overlap = minDist - dist;
              // Adjust positions so they bounce apart
              c.x += nx * (overlap / 2);
              c.y += ny * (overlap / 2);
              bc.x -= nx * (overlap / 2);
              bc.y -= ny * (overlap / 2);
              // Bounce the normal comet more strongly (big comets remain mostly unaffected)
              c.vx = -c.vx * 0.5;
              c.vy = -c.vy * 0.5;
            }
          }
        }
      }


      function restartGame() {
        gameState = "menu";
        startMenuMusic();
        spaceship.x = canvas.width / 2;
        spaceship.y = canvas.height / 2;
        spaceship.vx = 0;
        spaceship.vy = 0;
        spaceship.angle = 0;
        spaceship.hitPoints = 5;
        spaceship.hitFlashTimer = 0;
        bullets = [];
        sparks = [];
        comets = [];
        bigComets = [];
        smallExplosionParticles = [];
        lastBulletTime = 0;
        cometSpawnTimer = 0;
        bigCometSpawnTimer = 0;
        powerUps = [];
        powerUpSpawnTimer = 0;
        score = 0;
        gameTime = 0;
        winTriggered = false;
        // Spawn an initial comet
        spawnComet();
        initStarfield();
      }

      // Spaceship
      function drawSpaceship() {
        ctx.save();
        ctx.translate(spaceship.x, spaceship.y);
        ctx.rotate(spaceship.angle);
        ctx.shadowBlur = 20;
        ctx.shadowColor = "cyan";

        let shipFill = "gray";
        if (spaceship.hitFlashTimer > 0) {
          shipFill = "red";
        } else if (spaceship.hitPoints <= 2) {
          shipFill = (Math.floor(gameTime * 10) % 2 === 0) ? "red" : "gray";
        }

        let shipGrad = ctx.createLinearGradient(spaceship.size, 0, -spaceship.size, 0);
        shipGrad.addColorStop(0, shipFill);
        shipGrad.addColorStop(1, "#111");

        // Body - keeping the original shape
        ctx.beginPath();
        ctx.moveTo(spaceship.size, 0);
        ctx.lineTo(spaceship.size * 0.2, spaceship.size * 0.7);
        ctx.quadraticCurveTo(-spaceship.size * 0.7, spaceship.size * 0.5, -spaceship.size * 0.6, 0);
        ctx.quadraticCurveTo(-spaceship.size * 0.7, -spaceship.size * 0.5, spaceship.size * 0.2, -spaceship.size * 0.7);
        ctx.closePath();
        ctx.fillStyle = shipGrad;
        ctx.fill();
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Add side gun 1 (top)
        ctx.beginPath();
        ctx.moveTo(spaceship.size * 0.5, -spaceship.size * 0.4);
        ctx.lineTo(spaceship.size * 0.9, -spaceship.size * 0.4);
        ctx.lineTo(spaceship.size * 0.9, -spaceship.size * 0.6);
        ctx.lineTo(spaceship.size * 0.5, -spaceship.size * 0.5);
        ctx.closePath();
        ctx.fillStyle = "#555";
        ctx.fill();
        ctx.strokeStyle = "#ccc";
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Add side gun 2 (bottom)
        ctx.beginPath();
        ctx.moveTo(spaceship.size * 0.5, spaceship.size * 0.4);
        ctx.lineTo(spaceship.size * 0.9, spaceship.size * 0.4);
        ctx.lineTo(spaceship.size * 0.9, spaceship.size * 0.6);
        ctx.lineTo(spaceship.size * 0.5, spaceship.size * 0.5);
        ctx.closePath();
        ctx.fillStyle = "#555";
        ctx.fill();
        ctx.strokeStyle = "#ccc";
        ctx.lineWidth = 2;
        ctx.stroke();

        // Flame
        ctx.save();
        ctx.globalAlpha = 0.7;
        let flameLength = spaceship.size * 0.8;
        let flameWidth = spaceship.size * 0.3;
        let flameGrad = ctx.createLinearGradient(-spaceship.size * 0.6, 0, -spaceship.size * 0.6 - flameLength, 0);
        flameGrad.addColorStop(0, "yellow");
        flameGrad.addColorStop(1, "red");
        ctx.fillStyle = flameGrad;
        ctx.beginPath();
        ctx.moveTo(-spaceship.size * 0.6, flameWidth / 2);
        ctx.lineTo(-spaceship.size * 0.6 - flameLength, 0);
        ctx.lineTo(-spaceship.size * 0.6, -flameWidth / 2);
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        // Cockpit
        let cockpitRadius = spaceship.size * 0.3;
        let cockpitGrad = ctx.createRadialGradient(
          spaceship.size * 0.3, 0,
          cockpitRadius * 0.3,
          spaceship.size * 0.3, 0,
          cockpitRadius 
        );
        cockpitGrad.addColorStop(0, "lightblue");
        cockpitGrad.addColorStop(1, "blue");
        ctx.beginPath();
        ctx.arc(spaceship.size * 0.3, 0, cockpitRadius, 0, Math.PI * 2);
        ctx.fillStyle = cockpitGrad;
        ctx.fill();
        ctx.strokeStyle = "white";
        ctx.stroke();

        ctx.restore();
      }

      // 3) Draw normal comets with morph
      function drawNormalComets() {
        for (let c of comets) {
          // Draw comet trail
          if (c.trail && c.trail.length > 0) {
            ctx.save();
            let maxAlpha = 0.1;
            for (let i = 0; i < c.trail.length; i++) {
              let pos = c.trail[i];
              let alpha = ((i + 1) / c.trail.length) * maxAlpha;
              ctx.globalAlpha = alpha;
              ctx.beginPath();
              ctx.arc(pos.x, pos.y, c.radius, 0, 2 * Math.PI);
              ctx.fillStyle = "lightblue";
              ctx.fill();
            }
            ctx.restore();
          }

          // Draw comet body
          ctx.save();
          ctx.globalAlpha = 0.8;
          ctx.beginPath();
          if (c.shape && c.shape.length > 0) {
            // First vertex
            let v0 = c.shape[0];
            let factor0 = v0.factor;
            if (c.morph) {
              // Apply rotation speed if available (for new comets)
              const rotSpeed = c.rotationSpeed || 1;
              factor0 += 0.1 * Math.sin(gameTime * v0.frequency * rotSpeed + v0.phase);
            }
            ctx.moveTo(
              c.x + c.radius * factor0 * Math.cos(v0.angle),
              c.y + c.radius * factor0 * Math.sin(v0.angle)
            );

            // Remaining vertices
            for (let i = 1; i < c.shape.length; i++) {
              let v = c.shape[i];
              let f = v.factor;
              if (c.morph) {
                // Apply rotation speed if available (for new comets)
                const rotSpeed = c.rotationSpeed || 1;
                f += 0.1 * Math.sin(gameTime * v.frequency * rotSpeed + v.phase);
              }
              ctx.lineTo(
                c.x + c.radius * f * Math.cos(v.angle),
                c.y + c.radius * f * Math.sin(v.angle)
              );
            }
            ctx.closePath();
          } else {
            ctx.arc(c.x, c.y, c.radius, 0, 2 * Math.PI);
          }
          ctx.fillStyle = c.pattern;
          ctx.fill();
          // Use the comet's color for its outline, with some opacity
          ctx.strokeStyle = c.color;
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.restore();
        }
      }

      // New rocky pattern for big comets with a darker base color
      function generateRockPattern() {
        let patternCanvas = document.createElement("canvas");
        patternCanvas.width = 50;
        patternCanvas.height = 50;
        let pctx = patternCanvas.getContext("2d");
        // Use a deep, dark brown for the background:
        pctx.fillStyle = "#4a2c2a";
        pctx.fillRect(0, 0, patternCanvas.width, patternCanvas.height);
        // Add random speckles to simulate rock:
        // Reduced number of speckles for a smoother, more uniform look
        for (let i = 0; i < 20; i++) {
          let rx = Math.random() * patternCanvas.width;
          let ry = Math.random() * patternCanvas.height;
          let r = Math.random() * 1.5 + 0.5; // Smaller variations in speckle size
          pctx.fillStyle = "rgba(30,15,15,0.5)"; // More transparent speckles
          pctx.beginPath();
          pctx.arc(rx, ry, r, 0, 2 * Math.PI);
          pctx.fill();
        }
        return pctx.createPattern(patternCanvas, "repeat");
      }


      // Cache the new rock pattern
      const cachedRockPattern = generateRockPattern();

      function spawnBigComet() {
        // Choose starting position that will cross closer to center screen
        // Use either top/bottom or left/right edges
        let x, y, angle;
        
        if (Math.random() < 0.5) {
          // Spawn from left or right edge
          x = Math.random() < 0.5 ? -BASE_COMET_RADIUS * BIG_COMET_SCALE : canvas.width + BASE_COMET_RADIUS * BIG_COMET_SCALE;
          
          // Calculate y to aim toward center-ish area (with some variation)
          const targetY = canvas.height * (0.3 + Math.random() * 0.4); // Target 30-70% of screen height
          y = randomRange(0, canvas.height);
          
          // Calculate angle toward target point near center
          angle = Math.atan2(targetY - y, (canvas.width/2) - x);
        } else {
          // Spawn from top or bottom edge
          y = Math.random() < 0.5 ? -BASE_COMET_RADIUS * BIG_COMET_SCALE : canvas.height + BASE_COMET_RADIUS * BIG_COMET_SCALE;
          
          // Calculate x to aim toward center-ish area (with some variation)
          const targetX = canvas.width * (0.3 + Math.random() * 0.4); // Target 30-70% of screen width
          x = randomRange(0, canvas.width);
          
          // Calculate angle toward target point near center
          angle = Math.atan2((canvas.height/2) - y, targetX - x);
        }
        
        // Slow down big comets for longer screen time
        const speed = randomRange(BIG_COMET_SPEED_MIN * 0.7, BIG_COMET_SPEED_MAX * 0.7);
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;
        let radius = BASE_COMET_RADIUS * BIG_COMET_SCALE;
        
        // Use more segments for a smoother, rounder shape (12 -> 18)
        let shape = generateCometShape(18);
        
        // Make big comets much more round with minimal variation
        shape.forEach(v => {
          // Minimal variation for near-perfect roundness (0.2 -> 0.05)
          v.factor = 1 + (v.factor - 1) * 0.05;
          // Greatly reduce frequency for slower rotation
          v.frequency = v.frequency * 0.3;
        });
        
        let big = {
          x, y, vx, vy,
          radius,
          color: BIG_COMET_COLOR,
          hitPoints: Infinity,
          indestructible: true,
          shape: shape,
          // Generate a unique rock pattern for each comet
          pattern: generateRockPattern(),
          trail: [],
          trailTimer: 0,
          morph: true,
          // Slow rotation for big comets
          rotationSpeed: randomRange(0.3, 0.5)
        };
        bigComets.push(big);
      }



      function drawBigComets(ctx) {
        for (let bc of bigComets) {
          ctx.save();
          ctx.globalAlpha = 1.0;
          ctx.beginPath();
          if (bc.shape && bc.shape.length > 0) {
            let v0 = bc.shape[0];
            let factor0 = v0.factor;
            if (bc.morph) {
              // Apply rotation speed to big comets too
              const rotSpeed = bc.rotationSpeed || 1.5;
              factor0 += 0.1 * Math.sin(gameTime * v0.frequency * rotSpeed + v0.phase);
            }
            ctx.moveTo(
              bc.x + bc.radius * factor0 * Math.cos(v0.angle),
              bc.y + bc.radius * factor0 * Math.sin(v0.angle)
            );
            for (let i = 1; i < bc.shape.length; i++) {
              let v = bc.shape[i];
              let f = v.factor;
              if (bc.morph) {
                // Apply rotation speed to big comets too
                const rotSpeed = bc.rotationSpeed || 1.5;
                f += 0.1 * Math.sin(gameTime * v.frequency * rotSpeed + v.phase);
              }
              ctx.lineTo(
                bc.x + bc.radius * f * Math.cos(v.angle),
                bc.y + bc.radius * f * Math.sin(v.angle)
              );
            }
            ctx.closePath();
          } else {
            ctx.arc(bc.x, bc.y, bc.radius, 0, Math.PI * 2);
          }
          ctx.fillStyle = bc.pattern;  // Use the rocky pattern here
          ctx.fill();
          // Use a subtle, semi-transparent darker outline
          ctx.strokeStyle = "rgba(50,30,20,0.3)";
          ctx.lineWidth = 1.5;
          ctx.stroke();
          ctx.restore();
        }
      }


      // Main Draw
      function draw() {
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        drawStarfield(ctx);
        drawCronos(ctx);

        if (gameState === "menu") {
          ctx.fillStyle = "white";
          ctx.font = "48px sans-serif";
          ctx.textAlign = "center";
          ctx.fillText("Splitting Comets", canvas.width / 2, canvas.height / 2 - 50);
          ctx.font = "24px sans-serif";
          ctx.fillText("Press ENTER to start", canvas.width / 2, canvas.height / 2);
          ctx.fillText("Press S for settings", canvas.width / 2, canvas.height / 2 + 40);
          ctx.fillText("Press M to toggle sound", canvas.width / 2, canvas.height / 2 + 80);
          ctx.fillText("Score: " + score, canvas.width / 2, 40);
          
          // Show sound status
          const soundStatus = soundEnabled ? "ON" : "OFF";
          ctx.font = "18px sans-serif";
          ctx.fillText("Sound: " + soundStatus, canvas.width / 2, canvas.height / 2 + 120);
          
          // Draw speaker icon on menu screen too
          drawMusicIcon();
          return;
        }
        if (gameState === "settings") {
          ctx.fillStyle = "white";
          ctx.font = "48px sans-serif";
          ctx.textAlign = "center";
          ctx.fillText("Settings", canvas.width / 2, canvas.height / 2 - 50);
          ctx.font = "24px sans-serif";
          ctx.fillText("Press ESC to return", canvas.width / 2, canvas.height / 2);
          
          // Sound toggle option
          ctx.fillText("Press M to toggle all sounds: " + (soundEnabled ? "ON" : "OFF"), canvas.width / 2, canvas.height / 2 + 40);
          
          // Draw speaker icon on settings screen too
          drawMusicIcon();
          return;
        }
        if (gameState === "win") {
          // draw any leftover explosion particles
          for (let p of smallExplosionParticles) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fillStyle = p.color;
            ctx.fill();
          }
          ctx.fillStyle = "lime";
          ctx.font = "48px sans-serif";
          ctx.textAlign = "center";
          ctx.fillText("WIN!", canvas.width / 2, canvas.height / 2);
          ctx.font = "24px sans-serif";
          ctx.fillText("Score: " + score, canvas.width / 2, 40);
          return;
        }
        if (gameState === "gameover") {
          for (let p of smallExplosionParticles) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fillStyle = p.color;
            ctx.fill();
          }
          ctx.fillStyle = "red";
          ctx.font = "48px sans-serif";
          ctx.textAlign = "center";
          ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2);
          ctx.font = "24px sans-serif";
          ctx.fillText("Press ENTER to restart", canvas.width / 2, canvas.height / 2 + 40);
          ctx.fillText("Score: " + score, canvas.width / 2, 40);
          return;
        }

        ctx.fillStyle = "white";
        ctx.font = "24px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Score: " + score, canvas.width / 2, 40);
        drawHealthBar();
        drawMusicIcon();

        // Power-ups
        for (let pu of powerUps) {
          ctx.save();
          ctx.translate(pu.x, pu.y);
          let size = POWERUP_BOX_SIZE;
          ctx.shadowBlur = 10;
          ctx.shadowColor = "#800000";
          ctx.fillStyle = "#800000";
          ctx.lineWidth = 4;
          ctx.strokeStyle = "white";
          roundRect(ctx, -size / 2, -size / 2, size, size, 6);
          ctx.beginPath();
          ctx.moveTo(-size / 2, -size / 2);
          ctx.lineTo(0, -size);
          ctx.lineTo(size / 2, -size / 2);
          ctx.closePath();
          ctx.fillStyle = "white";
          ctx.fill();
          ctx.font = "bold 14px Arial";
          ctx.fillStyle = "#000";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("PuP", 0, 0);
          ctx.restore();
        }

        // Spaceship
        drawSpaceship();

        // Sparks
        const noseX = spaceship.x + Math.cos(spaceship.angle) * spaceship.size;
        const noseY = spaceship.y + Math.sin(spaceship.angle) * spaceship.size;
        ctx.save();
        ctx.strokeStyle = "yellow";
        ctx.lineWidth = 1;
        for (let spark of sparks) {
          ctx.beginPath();
          ctx.moveTo(noseX, noseY);
          ctx.lineTo(
            noseX + Math.cos(spark.angle) * spark.length,
            noseY + Math.sin(spark.angle) * spark.length
          );
          ctx.stroke();
        }
        ctx.restore();

        // Bullets
        ctx.fillStyle = "white";
        for (let b of bullets) {
          ctx.beginPath();
          ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
          ctx.fill();
        }

        // Normal Comets
        drawNormalComets();

        // Big Comets
        drawBigComets(ctx);

        // Explosion Particles
        for (let p of smallExplosionParticles) {
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fillStyle = p.color;
          ctx.fill();
        }
      }

      // Game Loop
      let lastLoopTime = performance.now();
      function gameLoop(now) {
        const dt = (now - lastLoopTime) / 1000;
        lastLoopTime = now;
        updateExplosionParticles(dt);
        update(dt);
        draw();
        requestAnimationFrame(gameLoop);
      }
      requestAnimationFrame(gameLoop);

      // The main update function
      function update(dt) {
        // always update starfield
        updateStarfield(dt);
        

        // Update ship hit flash timer
        if (spaceship.hitFlashTimer > 0) {
          spaceship.hitFlashTimer -= dt;
          if (spaceship.hitFlashTimer < 0) spaceship.hitFlashTimer = 0;
        }


        // if in menu/settings/gameover/win, do minimal
        if (gameState === "menu" || gameState === "settings" ||
          gameState === "gameover" || gameState === "win") {
          return;
        }

        // Increase global time so comet morph can happen
        gameTime += dt;

        // Power-ups
        powerUpSpawnTimer += dt;
        if (powerUpSpawnTimer >= POWERUP_SPAWN_INTERVAL) {
          powerUps.push(spawnPowerUp());
          powerUpSpawnTimer = 0;
        }
        for (let i = powerUps.length - 1; i >= 0; i--) {
          let pu = powerUps[i];
          pu.lifetime -= dt;
          pu.x += pu.vx * dt;
          pu.y += pu.vy * dt;
          bounce(pu, POWERUP_RADIUS);
          if (pu.lifetime <= 0) {
            powerUps.splice(i, 1);
            continue;
          }
          // Check if spaceship picks it up
          const dx = spaceship.x - pu.x;
          const dy = spaceship.y - pu.y;
          if (Math.hypot(dx, dy) < (spaceship.size / 2 + pu.radius)) {
            // Refill HP
            spaceship.hitPoints = Math.min(5, spaceship.hitPoints + 3);
            powerUpSound.volume = 0.3;

            powerUpSound.play().catch(err => console.error("Error playing powerup sound:", err));
            powerUps.splice(i, 1); // Remove the power-up after collection
            continue;



          }
        }

        // Win condition if survive 90s and no comets left
        let spawnAllowed = gameTime < 90;
        if (gameTime >= 60 && comets.length === 0 && !winTriggered) {
          createHugeExplosion(spaceship.x, spaceship.y);
          winTriggered = true;
          gameState = "win";
          bgMusic.pause(); // Stop the gameplay music
          victorySound.play().catch(err => console.error("Error playing victory sound:", err));
        }

        // Movement/Collisions
        // Spaceship vs comets
        for (let i = 0; i < comets.length; i++) {
          const c = comets[i];
          const dx = spaceship.x - c.x;
          const dy = spaceship.y - c.y;
          const dist = Math.hypot(dx, dy);
          if (dist < spaceship.size + c.radius) {
            let nx = dx / dist;
            let ny = dy / dist;
            let overlap = (spaceship.size + c.radius) - dist;
            // separate them
            spaceship.x += nx * (overlap / 2);
            spaceship.y += ny * (overlap / 2);
            c.x -= nx * (overlap / 2);
            c.y -= ny * (overlap / 2);
            // bounce velocities
            spaceship.vx = -spaceship.vx * 0.5;
            spaceship.vy = -spaceship.vy * 0.5;
            c.vx = -c.vx * 0.3;
            c.vy = -c.vy * 0.3;
            // damage spaceship
            spaceship.hitPoints--;
            spaceship.hitFlashTimer = 0.3;
            if (spaceship.hitPoints <= 0) {
              comets = [];
              bigComets = [];
              bullets = [];
              sparks = [];
              createHugeExplosion(spaceship.x, spaceship.y);
              gameState = "gameover";
              bgMusic.pause(); // Stop the gameplay music
              defeatSound.play().catch(err => console.error("Error playing defeat sound:", err));
              return;
            }
          }
        }

        // Spaceship vs bigComets
        for (let i = 0; i < bigComets.length; i++) {
          const bc = bigComets[i];
          const dx = spaceship.x - bc.x;
          const dy = spaceship.y - bc.y;
          const dist = Math.hypot(dx, dy);
          if (dist < spaceship.size * 1.2 + bc.radius) {
            let nx = dx / dist;
            let ny = dy / dist;
            let overlap = (spaceship.size + bc.radius) - dist;
            spaceship.x += nx * (overlap / 2);
            spaceship.y += ny * (overlap / 2);
            spaceship.vx = -spaceship.vx * 0.5;
            spaceship.vy = -spaceship.vy * 0.5;
            spaceship.hitPoints--;
            spaceship.hitFlashTimer = 0.3;
            if (spaceship.hitPoints <= 0) {
              comets = [];
              bigComets = [];
              bullets = [];
              sparks = [];
              createHugeExplosion(spaceship.x, spaceship.y);
              gameState = "gameover";
              bgMusic.pause(); // Stop the gameplay music
              defeatSound.play().catch(err => console.error("Error playing defeat sound:", err));
              return;
            }
          }
        }

        // Movement controls
        if (keys["ArrowUp"]) {
          spaceship.vx += Math.cos(spaceship.angle) * SHIP_ACCEL * dt;
          spaceship.vy += Math.sin(spaceship.angle) * SHIP_ACCEL * dt;
        }
        if (keys["ArrowDown"]) {
          spaceship.vx -= Math.cos(spaceship.angle) * SHIP_REVERSE * dt;
          spaceship.vy -= Math.sin(spaceship.angle) * SHIP_REVERSE * dt;
        }
        if (keys["Space"]) {
          // Quick brake
          let speed = Math.sqrt(spaceship.vx ** 2 + spaceship.vy ** 2);
          if (speed > 0) {
            let deceleration = SHIP_REVERSE * dt;
            let newSpeed = Math.max(0, speed - deceleration);
            spaceship.vx = (spaceship.vx / speed) * newSpeed;
            spaceship.vy = (spaceship.vy / speed) * newSpeed;
          }
        }
        if (keys["ArrowLeft"]) {
          spaceship.angle -= SHIP_ROT_SPEED * dt;
        }
        if (keys["ArrowRight"]) {
          spaceship.angle += SHIP_ROT_SPEED * dt;
        }

        // Spaceship movement
        spaceship.x += spaceship.vx * dt;
        spaceship.y += spaceship.vy * dt;
        spaceship.vx *= FRICTION;
        spaceship.vy *= FRICTION;
        bounce(spaceship, spaceship.size, 0.3);

        // Shooting
        lastBulletTime += dt * 1000;
        if (lastBulletTime > BULLET_INTERVAL) {
          // Fire triple bullets from different gun positions
          const noseX = spaceship.x + Math.cos(spaceship.angle) * spaceship.size;
          const noseY = spaceship.y + Math.sin(spaceship.angle) * spaceship.size;
          const perpX = Math.cos(spaceship.angle + Math.PI / 2);
          const perpY = Math.sin(spaceship.angle + Math.PI / 2);
          
          // Positions for each gun
          const topGunX = spaceship.x + Math.cos(spaceship.angle) * (spaceship.size * 0.8) + perpX * (spaceship.size * 0.4);
          const topGunY = spaceship.y + Math.sin(spaceship.angle) * (spaceship.size * 0.8) + perpY * (spaceship.size * 0.4);
          
          const bottomGunX = spaceship.x + Math.cos(spaceship.angle) * (spaceship.size * 0.8) - perpX * (spaceship.size * 0.4);
          const bottomGunY = spaceship.y + Math.sin(spaceship.angle) * (spaceship.size * 0.8) - perpY * (spaceship.size * 0.4);

          // Slight angle variation for more natural shot
          const topAngle = spaceship.angle + randomRange(-0.05, 0.05);
          const centerAngle = spaceship.angle + randomRange(-0.03, 0.03);
          const bottomAngle = spaceship.angle + randomRange(-0.05, 0.05);

          // Bullet spawn positions from each gun
          const spawnPositions = [
            { x: topGunX, y: topGunY },        // Top gun
            { x: noseX, y: noseY },            // Center gun 
            { x: bottomGunX, y: bottomGunY }   // Bottom gun
          ];
          const bulletAngles = [topAngle, centerAngle, bottomAngle];
          for (let i = 0; i < 3; i++) {
            const pos = spawnPositions[i];
            const angle = bulletAngles[i];
            const bullet = {
              x: pos.x,
              y: pos.y,
              vx: Math.cos(angle) * BULLET_SPEED + spaceship.vx,
              vy: Math.sin(angle) * BULLET_SPEED + spaceship.vy,
              radius: BULLET_RADIUS
            };
            bullets.push(bullet);
          }
          bulletSoundPool[nextBulletSoundIndex].currentTime = 0;
          bulletSoundPool[nextBulletSoundIndex].play();
          nextBulletSoundIndex = (nextBulletSoundIndex + 1) % BULLET_SOUND_POOL_SIZE;
          lastBulletTime = 0;
          // Sparks
          const numSparks = Math.floor(randomRange(1, 3));
          for (let i = 0; i < numSparks; i++) {
            const baseSparkOffset = Math.PI / 8;
            const sparkAngle = spaceship.angle + (Math.random() < 0.5 ? baseSparkOffset : -baseSparkOffset) + randomRange(-0.05, 0.05);
            sparks.push({
              angle: sparkAngle,
              length: randomRange(2, 5),
              lifetime: 0.2
            });
          }
        }

        // Update sparks
        for (let i = sparks.length - 1; i >= 0; i--) {
          sparks[i].lifetime -= dt;
          if (sparks[i].lifetime <= 0) {
            sparks.splice(i, 1);
          }
        }

        // Update bullets
        for (let i = bullets.length - 1; i >= 0; i--) {
          let b = bullets[i];
          b.x += b.vx * dt;
          b.y += b.vy * dt;
          // off screen => remove
          if (b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) {
            bullets.splice(i, 1);
          }
        }

        // Update comets
        for (let c of comets) {
          if (c.slowEffectTimer > 0) {
            c.slowEffectTimer -= dt;
            if (c.slowEffectTimer < 0) c.slowEffectTimer = 0;
          }
          if (c.indestructableTimer > 0) {
            c.indestructableTimer -= dt;
            if (c.indestructableTimer < 0) c.indestructableTimer = 0;
          }
          if (c.hitEffectTimer > 0) {
            c.hitEffectTimer -= dt;
            if (c.hitEffectTimer < 0) c.hitEffectTimer = 0;
          }
          c.x += c.vx * dt;
          c.y += c.vy * dt;
          c.vx *= COMET_FRICTION;
          c.vy *= COMET_FRICTION;
          // never drop below COMET_MIN_SPEED
          let speed = Math.hypot(c.vx, c.vy);
          if (speed < COMET_MIN_SPEED && speed > 0) {
            let factor = COMET_MIN_SPEED / speed;
            c.vx *= factor;
            c.vy *= factor;
          }
          bounce(c, c.radius);

          c.trailTimer += dt;
          if (c.trailTimer >= 0.05) { // TRAIL_INTERVAL
            c.trailTimer -= 0.05;
            c.trail.push({ x: c.x, y: c.y });
            if (c.trail.length > 5) {
              c.trail.shift();
            }
          }
        }

        // update big comets
        updateBigComets(dt);
        updateTimers(dt);

        // Bullets vs Comets
        for (let i = bullets.length - 1; i >= 0; i--) {
          let b = bullets[i];
          let bulletHit = false;
          for (let j = comets.length - 1; j >= 0; j--) {
            let c = comets[j];
            if (c.indestructableTimer > 0) continue;
            let dx = b.x - c.x;
            let dy = b.y - c.y;
            if (Math.hypot(dx, dy) < c.radius) {
              bulletHit = true;
              // bullet sound
              if (soundEnabled) {
                hitSoundPool[nextHitSoundIndex].currentTime = 0;
                hitSoundPool[nextHitSoundIndex].play();
                nextHitSoundIndex = (nextHitSoundIndex + 1) % HIT_SOUND_POOL_SIZE;
              }
              c.hitPoints--;
              // slow effect if tier 3
              if (c.tier === 3 && c.slowEffectTimer === 0) {
                c.vx *= 0.66;
                c.vy *= 0.66;
                c.slowEffectTimer = 0.5;
              }
              c.hitEffectTimer = 0.5;
              // destroyed
              if (c.hitPoints <= 0) {
                createSmallExplosion(c.x, c.y);
                // if bigger than tier1 => split
                if (c.tier > 1) {
                  const newTier = c.tier - 1;
                  const baseSpeed = Math.hypot(c.vx, c.vy);
                  let splits = Math.floor(randomRange(2, 6));
                  const offset = 50;
                  for (let k = 0; k < splits; k++) {
                    let newAngle = Math.random() * 2 * Math.PI;
                    let factor = randomRange(0.7, 0.8);
                    let extraFactor = randomRange(1.2, 1.5);
                    let newSpeed = baseSpeed * factor * extraFactor;
                    spawnComet(
                      newTier,
                      c.x + Math.cos(newAngle) * offset,
                      c.y + Math.sin(newAngle) * offset,
                      Math.cos(newAngle) * newSpeed,
                      Math.sin(newAngle) * newSpeed
                    );
                    // short indestructable so they don't instantly collide
                    comets[comets.length - 1].indestructableTimer = 0.01;
                  }
                }
                score += 10;
                comets.splice(j, 1);
              }
              break;
            }
          }
          // if not hit normal comet, check big comet
          if (!bulletHit) {
            for (let j = bigComets.length - 1; j >= 0; j--) {
              let bc = bigComets[j];
              let dx = b.x - bc.x;
              let dy = b.y - bc.y;
              if (Math.hypot(dx, dy) < bc.radius) {
                bulletHit = true;
                // big comets are indestructible
                break;
              }
            }
          }
          if (bulletHit) {
            bullets.splice(i, 1);
          }
        }

        // check collisions among comets
        checkCometCollisions();

        checkBigCometCollisions();

        // spawn new comets over time if < 90s
        if (spawnAllowed) {
          cometSpawnTimer += dt;
          if (cometSpawnTimer > randomRange(COMET_SPAWN_MIN, COMET_SPAWN_MAX)) {
            // scale spawn count based on area
            let area = canvas.width * canvas.height;
            let scaleFactor = area / 480000;
            scaleFactor = Math.max(0.5, Math.min(2, scaleFactor));
            let spawnCount = Math.floor(
              (COMET_SPAWN_BATCH_MIN + Math.floor(Math.random() * (COMET_SPAWN_BATCH_MAX - COMET_SPAWN_BATCH_MIN + 1))) *
              scaleFactor
            );
            for (let i = 0; i < spawnCount; i++) {
              spawnComet();
            }
            cometSpawnTimer = 0;
          }
        }
      }

    })();
  </script>
</body>

</html>