<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Splitting Comets Game – With Comet Trails and Transparent Comets</title>
    <style>
      html, body {
        margin: 0; 
        padding: 0;
        background: black;
        overflow: hidden;
      }
      canvas {
        display: block;
        background: black;
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas" tabindex="1"></canvas>
    <script>
      (function() {
        /* 
          ---- SOUND EFFECTS ----
          bulletSound: 0.2s wood tap
          hitSound: 0.2s flick
          explosionSound: 0.3s faint thunk (for comet explosions)
        */
        const bulletSound = new Audio("https://actions.google.com/sounds/v1/wood/wood_plank_flicks.ogg");
        const hitSound = new Audio("https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg");
        const explosionSoundURL = "https://actions.google.com/sounds/v1/impacts/wood_fence_hit.ogg";

        // ----- Setup Canvas -----
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        function resizeCanvas() {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener("resize", () => {
          resizeCanvas();
          initStarfield();
        });
        canvas.focus();

        // ----- Global Constants -----
        const SHIP_ROT_SPEED   = 6;       // rotation speed (radians/sec)
        const SHIP_REVERSE     = 400;     // braking deceleration (pixels/sec²)
        const BULLET_SPEED     = 600;     // bullet speed (pixels/sec)
        const BULLET_RADIUS    = 4;
        const BULLET_INTERVAL  = 30;      // ms between shots
        const FRICTION         = 0.99;
        const SHIP_SIZE        = 30;      // spaceship size (pixels)
        const SHIP_ACCEL       = 800;     // forward acceleration (pixels/sec²)

        // Comets
        const COMET_SPEED_MIN  = 300;
        const COMET_SPEED_MAX  = 500;
        const COMET_FRICTION   = 0.999;
        const MAX_COMET_TIER   = 3;
        const BASE_COMET_RADIUS= 30;
        const COMET_SPAWN_MIN  = 3;       // seconds
        const COMET_SPAWN_MAX  = 5;       // seconds
        const COMET_SPAWN_BATCH_MIN = 3;
        const COMET_SPAWN_BATCH_MAX = 5;

        // Game state & timer
        let gameState = "menu";  
        let score = 0;
        let gameTime = 0;        
        let winTriggered = false;

        // Spaceship object
        let spaceship = {
          x: canvas.width / 2,
          y: canvas.height / 2,
          vx: 0,
          vy: 0,
          angle: 0,
          size: SHIP_SIZE,
          hitPoints: 5,
          invulnerableTimer: 0
        };

        let bullets = [];
        let sparks = [];
        let smallExplosionParticles = [];
        let comets = [];

        // ----- Starfield (Enhanced Glowing Stars) -----
        const NUM_STARS = 200;
        let stars = [];
        function initStarfield() {
          stars = [];
          for (let i = 0; i < NUM_STARS; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const baseSize = Math.random() * 2 + 0.5;
            const flicker = Math.random() < 0.7;
            const sizeVariation = flicker ? (Math.random() * 1 + 0.2) : 0;
            const sizeSpeed = flicker ? (Math.random() * 0.5 + 0.2) : 0;
            const sizeTime = flicker ? Math.random() * Math.PI * 2 : 0;
            stars.push({ x, y, baseSize, sizeVariation, sizeSpeed, sizeTime, flicker });
          }
        }
        initStarfield();

        function updateStarfield(dt) {
          for (let star of stars) {
            if (star.flicker) {
              star.sizeTime += dt * star.sizeSpeed;
            }
          }
        }

        function drawStarfield(ctx) {
          ctx.save();
          for (let star of stars) {
            let currentSize = star.baseSize;
            if (star.flicker) {
              currentSize += star.sizeVariation * Math.sin(star.sizeTime);
              if (currentSize < 0) currentSize = 0;
            }
            let gradient = ctx.createRadialGradient(
              star.x, star.y, currentSize * 0.2,
              star.x, star.y, currentSize
            );
            gradient.addColorStop(0, "rgba(255,255,255,1)");
            gradient.addColorStop(1, "rgba(255,255,255,0)");
            ctx.fillStyle = gradient;
            ctx.shadowBlur = 5;
            ctx.shadowColor = "white";
            ctx.beginPath();
            ctx.arc(star.x, star.y, currentSize, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();
        }

        let lastBulletTime = 0;
        let cometSpawnTimer = 0;
        let nextCometSpawn = randomRange(COMET_SPAWN_MIN, COMET_SPAWN_MAX);

        // ----- Input Handling -----
        const keys = {};
        window.addEventListener("keydown", (e) => {
          if (gameState === "menu" && e.code === "Enter") {
            gameState = "playing";
            score = 0;
            gameTime = 0;
            winTriggered = false;
            return;
          }
          if (gameState === "menu" && e.code === "KeyS") {
            gameState = "settings";
            return;
          }
          if (gameState === "settings" && e.code === "Escape") {
            gameState = "menu";
            return;
          }
          if ((gameState === "gameover" || gameState === "win") && e.code === "Enter") {
            restartGame();
            gameState = "playing";
            return;
          }
          keys[e.code] = true;
          e.preventDefault();
        });
        window.addEventListener("keyup", (e) => {
          keys[e.code] = false;
          e.preventDefault();
        });

        // ----- Touch Support -----
        let touchStartX = null, touchStartY = null;
        canvas.addEventListener("touchstart", function(e) {
          e.preventDefault();
          let touch = e.touches[0];
          touchStartX = touch.clientX;
          touchStartY = touch.clientY;
        }, false);
        canvas.addEventListener("touchmove", function(e) {
          e.preventDefault();
          let touch = e.touches[0];
          let deltaX = touch.clientX - touchStartX;
          let deltaY = touch.clientY - touchStartY;
          if (deltaX > 20) {
            keys["ArrowRight"] = true;
            keys["ArrowLeft"] = false;
          } else if (deltaX < -20) {
            keys["ArrowLeft"] = true;
            keys["ArrowRight"] = false;
          } else {
            keys["ArrowLeft"] = false;
            keys["ArrowRight"] = false;
          }
          if (deltaY < -20) {
            keys["ArrowUp"] = true;
            keys["ArrowDown"] = false;
          } else if (deltaY > 20) {
            keys["ArrowDown"] = true;
            keys["ArrowUp"] = false;
          } else {
            keys["ArrowUp"] = false;
            keys["ArrowDown"] = false;
          }
        }, false);
        canvas.addEventListener("touchend", function(e) {
          e.preventDefault();
          keys["ArrowUp"] = false;
          keys["ArrowDown"] = false;
          keys["ArrowLeft"] = false;
          keys["ArrowRight"] = false;
          touchStartX = null;
          touchStartY = null;
        }, false);

        // ----- Utility Functions -----
        function randomRange(min, max) {
          return Math.random() * (max - min) + min;
        }
        // Returns a darker color (70% saturation, 30% lightness)
        function randomColor() {
          const hue = Math.floor(Math.random() * 360);
          return "hsl(" + hue + ", 70%, 30%)";
        }
        function bounce(obj, radius, damping = 1) {
          if (obj.x - radius < 0) {
            obj.x = radius;
            obj.vx = -obj.vx * damping;
          }
          if (obj.x + radius > canvas.width) {
            obj.x = canvas.width - radius;
            obj.vx = -obj.vx * damping;
          }
          if (obj.y - radius < 0) {
            obj.y = radius;
            obj.vy = -obj.vy * damping;
          }
          if (obj.y + radius > canvas.height) {
            obj.y = canvas.height - radius;
            obj.vy = -obj.vy * damping;
          }
        }

        // ----- Comet Trails -----
        const TRAIL_INTERVAL = 0.05; // seconds
        function spawnComet(tier = MAX_COMET_TIER, x, y, vx, vy) {
          if (x === undefined || y === undefined) {
            if (Math.random() < 0.5) {
              x = randomRange(0, canvas.width);
              y = 0;
            } else {
              x = randomRange(0, canvas.width);
              y = canvas.height;
            }
          }
          if (vx === undefined || vy === undefined) {
            const angle = Math.random() * Math.PI * 2;
            const speed = randomRange(COMET_SPEED_MIN, COMET_SPEED_MAX);
            vx = Math.cos(angle) * speed;
            vy = Math.sin(angle) * speed;
          }
          const radius = BASE_COMET_RADIUS * Math.pow(0.6, MAX_COMET_TIER - tier);
          let hp;
          if (tier === 3) {
            hp = 5;
          } else if (tier === 2) {
            hp = 4;
          } else {
            hp = 3;
          }
          const comet = {
            x, y, vx, vy,
            radius,
            tier,
            color: randomColor(),
            hitPoints: hp,
            hitEffectTimer: 0,
            slowEffectTimer: 0,
            indestructableTimer: 0,
            oldVX: vx,
            oldVY: vy,
            trail: [],
            trailTimer: 0
          };
          comets.push(comet);
        }

        // ----- Explosion Effects -----
        function createSmallExplosion(x, y) {
          let exp = new Audio(explosionSoundURL);
          exp.volume = 0.5;
          exp.play();
          const count = 10;
          for (let i = 0; i < count; i++) {
            let angle = Math.random() * Math.PI * 2;
            let speed = randomRange(50, 150);
            smallExplosionParticles.push({
              x: x,
              y: y,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed,
              lifetime: randomRange(0.3, 0.7),
              size: randomRange(2, 4),
              color: "orange"
            });
          }
        }
        function createHugeExplosion(x, y) {
          let exp = new Audio(explosionSoundURL);
          exp.volume = 0.5;
          exp.play();
          const count = 50;
          for (let i = 0; i < count; i++) {
            let angle = Math.random() * Math.PI * 2;
            let speed = randomRange(100, 300);
            smallExplosionParticles.push({
              x: x,
              y: y,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed,
              lifetime: randomRange(0.8, 1.5),
              size: randomRange(5, 10),
              color: "orange"
            });
          }
        }

        function updateExplosionParticles(dt) {
          for (let i = smallExplosionParticles.length - 1; i >= 0; i--) {
            const p = smallExplosionParticles[i];
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.lifetime -= dt;
            p.size *= 0.98;
            if (p.lifetime <= 0) {
              smallExplosionParticles.splice(i, 1);
            }
          }
        }

        function checkCometCollisions() {
          let indicesToRemove = new Set();
          for (let i = 0; i < comets.length; i++) {
            for (let j = i + 1; j < comets.length; j++) {
              let c1 = comets[i];
              let c2 = comets[j];
              let dx = c2.x - c1.x;
              let dy = c2.y - c1.y;
              let dist = Math.hypot(dx, dy);
              let minDist = c1.radius + c2.radius;
              if (dist < minDist && dist > 0) {
                if (c1.tier < MAX_COMET_TIER) {
                  indicesToRemove.add(i);
                  createSmallExplosion(c1.x, c1.y);
                  score += 5;
                }
                if (c2.tier < MAX_COMET_TIER) {
                  indicesToRemove.add(j);
                  createSmallExplosion(c2.x, c2.y);
                  score += 5;
                }
                if (c1.tier === MAX_COMET_TIER && c2.tier === MAX_COMET_TIER) {
                  let nx = dx / dist;
                  let ny = dy / dist;
                  let dvx = c1.vx - c2.vx;
                  let dvy = c1.vy - c2.vy;
                  let dot = dvx * nx + dvy * ny;
                  if (dot <= 0) {
                    let bounceFactor = 1;
                    let impulse = bounceFactor * dot;
                    c1.vx -= impulse * nx;
                    c1.vy -= impulse * ny;
                    c2.vx += impulse * nx;
                    c2.vy += impulse * ny;
                    let overlap = minDist - dist;
                    c1.x -= nx * overlap / 2;
                    c1.y -= ny * overlap / 2;
                    c2.x += nx * overlap / 2;
                    c2.y += ny * overlap / 2;
                  }
                }
              }
            }
          }
          comets = comets.filter((_, index) => !indicesToRemove.has(index));
        }

        function restartGame() {
          gameState = "menu";
          spaceship.x = canvas.width / 2;
          spaceship.y = canvas.height / 2;
          spaceship.vx = 0;
          spaceship.vy = 0;
          spaceship.angle = 0;
          spaceship.hitPoints = 5;
          spaceship.invulnerableTimer = 0;
          bullets = [];
          comets = [];
          sparks = [];
          smallExplosionParticles = [];
          lastBulletTime = 0;
          cometSpawnTimer = 0;
          nextCometSpawn = randomRange(COMET_SPAWN_MIN, COMET_SPAWN_MAX);
          gameTime = 0;
          winTriggered = false;
          spawnComet();
          initStarfield();
          score = 0;
        }

        // ----- Game Loop -----
        // Rename the game loop timer variable to avoid conflicts
        let lastTimeGame = performance.now();
        function gameLoop(now) {
          const dt = (now - lastTimeGame) / 1000;
          lastTimeGame = now;
          updateExplosionParticles(dt);
          update(dt);
          draw();
          requestAnimationFrame(gameLoop);
        }
        requestAnimationFrame(gameLoop);

        function update(dt) {
          if (gameState === "menu" || gameState === "settings") {
            updateStarfield(dt);
            return;
          }
          if (gameState === "gameover" || gameState === "win") {
            updateStarfield(dt);
            return;
          }
          updateStarfield(dt);
          gameTime += dt;
          let spawnAllowed = gameTime < 120;
          if (gameTime >= 120 && comets.length === 0 && !winTriggered) {
            createHugeExplosion(spaceship.x, spaceship.y);
            winTriggered = true;
            gameState = "win";
          }
          if (spaceship.invulnerableTimer > 0) {
            spaceship.invulnerableTimer -= dt;
            if (spaceship.invulnerableTimer < 0) {
              spaceship.invulnerableTimer = 0;
            }
          }

          if (keys["ArrowUp"]) {
            spaceship.vx += Math.cos(spaceship.angle) * SHIP_ACCEL * dt;
            spaceship.vy += Math.sin(spaceship.angle) * SHIP_ACCEL * dt;
          }
          if (keys["ArrowDown"]) {
            spaceship.vx -= Math.cos(spaceship.angle) * SHIP_REVERSE * dt;
            spaceship.vy -= Math.sin(spaceship.angle) * SHIP_REVERSE * dt;
          }
          if (keys["Space"]) {
            let speed = Math.sqrt(spaceship.vx ** 2 + spaceship.vy ** 2);
            if (speed > 0) {
              let deceleration = SHIP_REVERSE * dt;
              let newSpeed = Math.max(0, speed - deceleration);
              spaceship.vx = (spaceship.vx / speed) * newSpeed;
              spaceship.vy = (spaceship.vy / speed) * newSpeed;
            }
          }
          if (keys["ArrowLeft"]) {
            spaceship.angle -= SHIP_ROT_SPEED * dt;
          }
          if (keys["ArrowRight"]) {
            spaceship.angle += SHIP_ROT_SPEED * dt;
          }
          spaceship.x += spaceship.vx * dt;
          spaceship.y += spaceship.vy * dt;
          spaceship.vx *= FRICTION;
          spaceship.vy *= FRICTION;
          bounce(spaceship, spaceship.size);

          if (spaceship.invulnerableTimer === 0) {
            for (let i = 0; i < comets.length; i++) {
              const c = comets[i];
              const dx = spaceship.x - c.x;
              const dy = spaceship.y - c.y;
              if (Math.hypot(dx, dy) < spaceship.size + c.radius) {
                if (c.tier === MAX_COMET_TIER) {
                  let norm = Math.hypot(dx, dy);
                  let nx = dx / norm;
                  let ny = dy / norm;
                  spaceship.vx = -spaceship.vx * 0.3;
                  spaceship.vy = -spaceship.vy * 0.3;
                  c.vx = -c.vx * 0.3;
                  c.vy = -c.vy * 0.3;
                }
                spaceship.hitPoints--;
                spaceship.invulnerableTimer = 0.5;
                if (spaceship.hitPoints <= 0) {
                  comets = [];
                  bullets = [];
                  sparks = [];
                  createHugeExplosion(spaceship.x, spaceship.y);
                  gameState = "gameover";
                  return;
                }
              }
            }
          }

          lastBulletTime += dt * 1000;
          if (lastBulletTime > BULLET_INTERVAL) {
            const noseX = spaceship.x + Math.cos(spaceship.angle) * spaceship.size;
            const noseY = spaceship.y + Math.sin(spaceship.angle) * spaceship.size;
            const perpX = Math.cos(spaceship.angle + Math.PI / 2);
            const perpY = Math.sin(spaceship.angle + Math.PI / 2);
            const holeOffset = spaceship.size / 4;

            const leftAngle = spaceship.angle - randomRange(0.1, 0.15);
            const centerAngle = spaceship.angle + randomRange(-0.03, 0.03);
            const rightAngle = spaceship.angle + randomRange(0.1, 0.15);

            const spawnPositions = [
              { x: noseX + perpX * holeOffset, y: noseY + perpY * holeOffset },
              { x: noseX, y: noseY },
              { x: noseX - perpX * holeOffset, y: noseY - perpY * holeOffset },
            ];
            const bulletAngles = [leftAngle, centerAngle, rightAngle];
            for (let i = 0; i < 3; i++) {
              const pos = spawnPositions[i];
              const angle = bulletAngles[i];
              const bullet = {
                x: pos.x,
                y: pos.y,
                vx: Math.cos(angle) * BULLET_SPEED + spaceship.vx,
                vy: Math.sin(angle) * BULLET_SPEED + spaceship.vy,
                radius: BULLET_RADIUS,
              };
              bullets.push(bullet);
            }
            bulletSound.currentTime = 0;
            bulletSound.play();
            lastBulletTime = 0;
            const numSparks = Math.floor(randomRange(1, 3));
            for (let i = 0; i < numSparks; i++) {
              const baseSparkOffset = Math.PI / 8;
              const sparkAngle = spaceship.angle + (Math.random() < 0.5 ? baseSparkOffset : -baseSparkOffset) + randomRange(-0.05, 0.05);
              sparks.push({
                angle: sparkAngle,
                length: randomRange(2, 5),
                lifetime: 0.2,
              });
            }
          }

          for (let i = sparks.length - 1; i >= 0; i--) {
            sparks[i].lifetime -= dt;
            if (sparks[i].lifetime <= 0) {
              sparks.splice(i, 1);
            }
          }

          for (let i = bullets.length - 1; i >= 0; i--) {
            const b = bullets[i];
            b.x += b.vx * dt;
            b.y += b.vy * dt;
            if (b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) {
              bullets.splice(i, 1);
            }
          }

          for (let comet of comets) {
            if (comet.slowEffectTimer > 0) {
              comet.slowEffectTimer -= dt;
              if (comet.slowEffectTimer <= 0) {
                comet.vx = comet.oldVX;
                comet.vy = comet.oldVY;
                comet.slowEffectTimer = 0;
              }
            }
            if (comet.indestructableTimer > 0) {
              comet.indestructableTimer -= dt;
              if (comet.indestructableTimer < 0) {
                comet.indestructableTimer = 0;
              }
            }
            if (comet.hitEffectTimer > 0) {
              comet.hitEffectTimer -= dt;
              if (comet.hitEffectTimer < 0) {
                comet.hitEffectTimer = 0;
              }
            }
            comet.x += comet.vx * dt;
            comet.y += comet.vy * dt;
            comet.vx *= COMET_FRICTION;
            comet.vy *= COMET_FRICTION;
            bounce(comet, comet.radius);

            // Update comet trail
            comet.trailTimer += dt;
            if (comet.trailTimer >= TRAIL_INTERVAL) {
              comet.trailTimer -= TRAIL_INTERVAL;
              comet.trail.push({ x: comet.x, y: comet.y });
              if (comet.trail.length > 10) {
                comet.trail.shift();
              }
            }
          }

          for (let i = bullets.length - 1; i >= 0; i--) {
            const b = bullets[i];
            let bulletHit = false;
            for (let j = comets.length - 1; j >= 0; j--) {
              const c = comets[j];
              if (c.indestructableTimer > 0) continue;
              const dx = b.x - c.x;
              const dy = b.y - c.y;
              if (Math.hypot(dx, dy) < c.radius) {
                bulletHit = true;
                hitSound.currentTime = 0;
                hitSound.play();
                c.hitPoints--;
                if (c.tier === 3) {
                  if (c.slowEffectTimer === 0) {
                    c.oldVX = c.vx;
                    c.oldVY = c.vy;
                  }
                  c.vx *= 0.66;
                  c.vy *= 0.66;
                  c.slowEffectTimer = 0.5;
                }
                c.hitEffectTimer = 0.5;
                if (c.hitPoints <= 0) {
                  createSmallExplosion(c.x, c.y);
                  if (c.tier > 1) {
                    const newTier = c.tier - 1;
                    const baseSpeed = Math.hypot(c.oldVX, c.oldVY);
                    let splits = Math.floor(randomRange(2, 6));
                    const offset = 50;
                    for (let k = 0; k < splits; k++) {
                      let newAngle = Math.random() * 2 * Math.PI;
                      let factor = randomRange(0.7, 0.8);
                      let extraFactor = randomRange(1.2, 1.5);
                      let newSpeed = baseSpeed * factor * extraFactor;
                      spawnComet(
                        newTier,
                        c.x + Math.cos(newAngle) * offset,
                        c.y + Math.sin(newAngle) * offset,
                        Math.cos(newAngle) * newSpeed,
                        Math.sin(newAngle) * newSpeed
                      );
                      comets[comets.length - 1].indestructableTimer = 0.01;
                    }
                    spaceship.invulnerableTimer = 0.5;
                  } else {
                    spaceship.invulnerableTimer = 0.5;
                  }
                  score += 10;
                  comets.splice(j, 1);
                }
                break;
              }
            }
            if (bulletHit) {
              bullets.splice(i, 1);
            }
          }

          checkCometCollisions();

          if (gameTime < 120) {
            cometSpawnTimer += dt;
            if (cometSpawnTimer > nextCometSpawn) {
              let area = canvas.width * canvas.height;
              let scaleFactor = area / 480000;
              scaleFactor = Math.max(0.5, Math.min(2, scaleFactor));
              let spawnCount = Math.floor(
                (COMET_SPAWN_BATCH_MIN + Math.floor(Math.random() * (COMET_SPAWN_BATCH_MAX - COMET_SPAWN_BATCH_MIN + 1))) *
                scaleFactor
              );
              for (let i = 0; i < spawnCount; i++) {
                spawnComet();
              }
              cometSpawnTimer = 0;
              nextCometSpawn = randomRange(COMET_SPAWN_MIN, COMET_SPAWN_MAX);
            }
          }
        }

        function draw() {
          ctx.fillStyle = "black";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          drawStarfield(ctx);

          if (gameState === "menu") {
            ctx.fillStyle = "white";
            ctx.font = "48px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText("Splitting Comets", canvas.width / 2, canvas.height / 2 - 50);
            ctx.font = "24px sans-serif";
            ctx.fillText("Press ENTER to start", canvas.width / 2, canvas.height / 2);
            ctx.fillText("Press S for settings", canvas.width / 2, canvas.height / 2 + 40);
            ctx.fillText("Score: " + score, canvas.width / 2, 40);
            return;
          }
          if (gameState === "settings") {
            ctx.fillStyle = "white";
            ctx.font = "48px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText("Settings (dummy)", canvas.width / 2, canvas.height / 2 - 50);
            ctx.font = "24px sans-serif";
            ctx.fillText("Press ESC to return", canvas.width / 2, canvas.height / 2);
            return;
          }
          if (gameState === "win") {
            for (let p of smallExplosionParticles) {
              ctx.beginPath();
              ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
              ctx.fillStyle = p.color;
              ctx.fill();
            }
            ctx.fillStyle = "lime";
            ctx.font = "48px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText("WIN!", canvas.width / 2, canvas.height / 2);
            ctx.font = "24px sans-serif";
            ctx.fillText("Score: " + score, canvas.width / 2, 40);
            return;
          }
          if (gameState === "gameover") {
            for (let p of smallExplosionParticles) {
              ctx.beginPath();
              ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
              ctx.fillStyle = p.color;
              ctx.fill();
            }
            ctx.fillStyle = "red";
            ctx.font = "48px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2);
            ctx.font = "24px sans-serif";
            ctx.fillText("Press ENTER to restart", canvas.width / 2, canvas.height / 2 + 40);
            ctx.fillText("Score: " + score, canvas.width / 2, 40);
            return;
          }

          ctx.fillStyle = "white";
          ctx.font = "24px sans-serif";
          ctx.textAlign = "center";
          ctx.fillText("Score: " + score, canvas.width / 2, 40);

          // Draw spaceship
          ctx.save();
          ctx.translate(spaceship.x, spaceship.y);
          ctx.rotate(spaceship.angle);
          ctx.shadowBlur = 20;
          ctx.shadowColor = "cyan";
          ctx.beginPath();
          ctx.moveTo(spaceship.size, 0);
          ctx.quadraticCurveTo(spaceship.size / 2, -spaceship.size / 2, -spaceship.size / 2, -spaceship.size / 4);
          ctx.quadraticCurveTo(-spaceship.size / 2, spaceship.size / 4, spaceship.size / 2, spaceship.size / 2);
          ctx.quadraticCurveTo(spaceship.size, 0, spaceship.size, 0);
          ctx.closePath();
          ctx.fillStyle = "gray";
          ctx.fill();
          ctx.strokeStyle = "white";
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(spaceship.size / 2, 0, spaceship.size / 8, 0, 2 * Math.PI);
          ctx.fillStyle = "lightblue";
          ctx.fill();
          ctx.stroke();
          ctx.restore();

          // Draw sparks
          const noseX = spaceship.x + Math.cos(spaceship.angle) * spaceship.size;
          const noseY = spaceship.y + Math.sin(spaceship.angle) * spaceship.size;
          ctx.save();
          ctx.strokeStyle = "yellow";
          ctx.lineWidth = 1;
          for (let spark of sparks) {
            ctx.beginPath();
            ctx.moveTo(noseX, noseY);
            ctx.lineTo(
              noseX + Math.cos(spark.angle) * spark.length,
              noseY + Math.sin(spark.angle) * spark.length
            );
            ctx.stroke();
          }
          ctx.restore();

          // Draw bullets
          ctx.fillStyle = "white";
          for (let b of bullets) {
            ctx.beginPath();
            ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
            ctx.fill();
          }

          // Draw comet trails using the comet's own color
          for (let c of comets) {
            if (c.trail && c.trail.length > 0) {
              ctx.save();
              let maxAlpha = 0.125;
              for (let i = 0; i < c.trail.length; i++) {
                let pos = c.trail[i];
                let alpha = ((i + 1) / c.trail.length) * maxAlpha;
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, c.radius, 0, 2 * Math.PI);
                ctx.fillStyle = c.color;
                ctx.fill();
              }
              ctx.restore();
            }
          }

          // Draw comets with 50% opacity (darker and more transparent)
          for (let c of comets) {
            let drawX = c.x;
            let drawY = c.y;
            if (c.hitEffectTimer > 0) {
              drawX += randomRange(-2, 2);
              drawY += randomRange(-2, 2);
              let haloRadius = c.radius + 12;
              ctx.save();
              let haloGrad = ctx.createRadialGradient(drawX, drawY, c.radius, drawX, drawY, haloRadius);
              haloGrad.addColorStop(0, "rgba(255,255,255,0.3)");
              haloGrad.addColorStop(1, "rgba(255,255,255,0)");
              ctx.fillStyle = haloGrad;
              ctx.beginPath();
              ctx.arc(drawX, drawY, haloRadius, 0, 2 * Math.PI);
              ctx.fill();
              ctx.restore();
            }
            ctx.save();
            ctx.globalAlpha = 0.5;  // 50% opacity for comets
            ctx.beginPath();
            ctx.arc(drawX, drawY, c.radius, 0, Math.PI * 2);
            ctx.fillStyle = c.color;
            ctx.fill();
            ctx.strokeStyle = "white";
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.restore();
          }

          // Draw explosion particles
          for (let p of smallExplosionParticles) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fillStyle = p.color;
            ctx.fill();
          }
        }

        // Spawn an initial comet
        spawnComet();

      })();
    </script>
  </body>
</html>
