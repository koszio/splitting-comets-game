<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Splitting Comets Game â€“ With Comet Trails and Transparent Comets</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      background: black;
      overflow: hidden;
    }

    canvas {
      display: block;
      background: black;
    }
  </style>
</head>

<body>
  <canvas id="gameCanvas" tabindex="1"></canvas>
  <script>
    (function () {
      /*
        ---- SOUND EFFECTS ----
        bulletSound: 0.2s wood tap
        hitSound: 0.2s flick (each hit plays fully at lower volume)
        explosionSound: using local file "small-explosion-94980.mp3"
      */
      // Use your local file for explosion sounds.
      const explosionSoundURL = "expl-sfx.mp3";
      const bulletSoundSrc = "";
      const hitSoundSrc = "";
      const powerUpSound = new Audio("mixkit-video-game-health-recharge-2837.wav");
      const victorySound = new Audio("mixkit-cheering-crowd-loud-whistle.wav");
      const defeatSound = new Audio("mixkit-arcade-retro-game-over.wav");
      victorySound.volume = 0.4;
      defeatSound.volume = 0.3;

      // Initialize sound system
      let currentMusicTrack = "";
      const bgMusic = new Audio();
      bgMusic.loop = true;
      bgMusic.volume = 0.1;
      let musicEnabled = true; // Track music state
      let soundEnabled = true; // Track sound effects state

      // Function to toggle music on/off
      function toggleMusic() {
        musicEnabled = !musicEnabled;
        
        if (musicEnabled) {
          // Resume music based on current game state
          if (gameState === GAME_STATE.MAIN_MENU || gameState === GAME_STATE.SETTINGS || 
              gameState === GAME_STATE.DIFFICULTY_SELECT || gameState === GAME_STATE.HOW_TO_PLAY || 
              gameState === GAME_STATE.HIGH_SCORES) {
            startMenuMusic();
          } else if (gameState === GAME_STATE.PLAYING) {
            startGameplayMusic();
          }
        } else {
          // Pause music
          bgMusic.pause();
        }
      }
      
      // Function to toggle all sounds (music and effects)
      function toggleAllSounds() {
        soundEnabled = !soundEnabled;
        
        if (!soundEnabled) {
          // Mute all sound effects
          powerUpSound.muted = true;
          victorySound.muted = true;
          defeatSound.muted = true;
          
          // Mute sound pools
          for (let sound of bulletSoundPool) {
            sound.muted = true;
          }
          for (let sound of hitSoundPool) {
            sound.muted = true;
          }
        } else {
          // Unmute all sound effects
          powerUpSound.muted = false;
          victorySound.muted = false;
          defeatSound.muted = false;
          
          // Unmute sound pools
          for (let sound of bulletSoundPool) {
            sound.muted = false;
          }
          for (let sound of hitSoundPool) {
            sound.muted = false;
          }
        }
      }

      // Function to start menu music
      function startMenuMusic() {
        if (currentMusicTrack !== "menu") {
          bgMusic.pause();
          bgMusic.src = "menu_music.mp3"; 
          bgMusic.load();
          if (musicEnabled) {
            bgMusic.play().catch(err => console.error("Error playing menu music:", err));
          }
          currentMusicTrack = "menu";
        } else if (musicEnabled && bgMusic.paused) {
          bgMusic.play().catch(err => console.error("Error resuming menu music:", err));
        }
      }

      // Function to start gameplay music with delay
      function startGameplayMusic() {
        if (currentMusicTrack !== "gameplay") {
          bgMusic.pause();
          bgMusic.src = "ingame_music.mp3";
          bgMusic.load();
          if (musicEnabled) {
            setTimeout(() => {
              bgMusic.play().catch(err => console.error("Error playing gameplay music:", err));
            }, 1300); // 1300ms delay
          }
          currentMusicTrack = "gameplay";
        } else if (musicEnabled && bgMusic.paused) {
          bgMusic.play().catch(err => console.error("Error resuming gameplay music:", err));
        }
      }

      // Add error handling for music loading
      bgMusic.onerror = function() {
        console.error("Error loading music file:", bgMusic.src);
      };

      // Game states
      const GAME_STATE = {
        MAIN_MENU: "mainMenu",
        DIFFICULTY_SELECT: "difficultySelect",
        SETTINGS: "settings",
        HOW_TO_PLAY: "howToPlay",
        HIGH_SCORES: "highScores",
        PLAYING: "playing",
        GAME_OVER: "gameOver",
        WIN: "win"
      };
      
      let gameState = GAME_STATE.MAIN_MENU;
      
      // Auto-start menu music when the page loads
      document.addEventListener('DOMContentLoaded', function() {
        // Initialize sound pools before trying to use them
        createSoundPools();
        startMenuMusic();
      });
      
      // Create sound pools
      function createSoundPools() {
        // This function is called early to ensure pools exist before they're used in toggleAllSounds
        if (!bulletSoundPool) bulletSoundPool = [];
        if (!hitSoundPool) hitSoundPool = [];
      }

      // Create a pool for bullet sounds (pool size 3)
      const BULLET_SOUND_POOL_SIZE = 3;
      const bulletSoundPool = [];
      for (let i = 0; i < BULLET_SOUND_POOL_SIZE; i++) {
        let a = new Audio(bulletSoundSrc);
        a.volume = 0.25;
        bulletSoundPool.push(a);
      }
      let nextBulletSoundIndex = 0;

      // Create a much smaller pool for hit sounds at lower volume
      const HIT_SOUND_POOL_SIZE = 3;
      const hitSoundPool = [];
      for (let i = 0; i < HIT_SOUND_POOL_SIZE; i++) {
        let a = new Audio(hitSoundSrc);
        a.volume = 0.1; // Reduced volume
        hitSoundPool.push(a);
      }
      let nextHitSoundIndex = 0;
      
      // Add throttling for hit sounds
      let lastHitSoundTime = 0;
      const HIT_SOUND_THROTTLE = 150; // Minimum milliseconds between hit sounds

      // ----- BACKGROUND MUSIC -----
      // Background music is now started automatically on page load

      // ----- Setup Canvas -----
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      resizeCanvas();
      window.addEventListener("resize", () => {
        resizeCanvas();
        initStarfield();
      });
      canvas.focus();
      
      // ----- Menu Background System -----
      let menuBgLoaded = false;
      let menuBgOffset = {x: 0, y: 0}; // For slow panning motion
      let menuBgCanvas, menuBgCtx;
      
      // Create a separate canvas for the menu background
      function initMenuBackground() {
        menuBgCanvas = document.createElement('canvas');
        menuBgCanvas.width = canvas.width;
        menuBgCanvas.height = canvas.height;
        menuBgCtx = menuBgCanvas.getContext('2d');
        
        // Draw the static menu background
        drawMenuBackground();
        menuBgLoaded = true;
      }
      
      // Draw the menu background components
      function drawMenuBackground() {
        // Reset the canvas
        menuBgCtx.clearRect(0, 0, menuBgCanvas.width, menuBgCanvas.height);
        
        // 1. Deep Space Background gradient
        const bgGradient = menuBgCtx.createRadialGradient(
          menuBgCanvas.width/2, menuBgCanvas.height/2, 10,
          menuBgCanvas.width/2, menuBgCanvas.height/2, menuBgCanvas.height
        );
        bgGradient.addColorStop(0, '#1a1a40'); // Deep blue/purple
        bgGradient.addColorStop(0.6, '#0c0c20'); // Darker blue
        bgGradient.addColorStop(1, '#000000'); // Black at edges
        
        menuBgCtx.fillStyle = bgGradient;
        menuBgCtx.fillRect(0, 0, menuBgCanvas.width, menuBgCanvas.height);
        
        // 2. Nebula-like wispy clouds
        drawNebulaWisps(menuBgCtx);
        
        // 3. Stars with varying sizes and colors
        drawStarField(menuBgCtx);
        
        // 4. Small distant planet with rings
        drawDistantPlanet(menuBgCtx);
        
        // 5. Comet field diagonally across screen
        drawCometField(menuBgCtx);
        
        // 6. Subtle spaceship silhouette
        drawShipSilhouette(menuBgCtx);
      }
      
      // Draw nebula-like wisps
      function drawNebulaWisps(ctx) {
        ctx.save();
        
        // Create several nebula patches
        for (let i = 0; i < 5; i++) {
          // Random positions, mostly around edges
          let x, y;
          const edgePos = Math.random() < 0.7;
          
          if (edgePos) {
            // Position near edges
            if (Math.random() < 0.5) {
              // Left or right edge
              x = Math.random() < 0.5 ? canvas.width * 0.1 : canvas.width * 0.9;
              y = canvas.height * Math.random();
            } else {
              // Top or bottom edge
              x = canvas.width * Math.random();
              y = Math.random() < 0.5 ? canvas.height * 0.1 : canvas.height * 0.9;
            }
          } else {
            // Random position anywhere
            x = canvas.width * Math.random();
            y = canvas.height * Math.random();
          }
          
          // Create nebula gradient
          const size = Math.random() * 300 + 200;
          const grad = ctx.createRadialGradient(
            x, y, 0,
            x, y, size
          );
          
          // Purple/blue nebula colors with low opacity
          const hue = 240 + Math.random() * 60; // Blue to purple
          grad.addColorStop(0, `hsla(${hue}, 70%, 30%, 0.08)`);
          grad.addColorStop(0.5, `hsla(${hue}, 60%, 20%, 0.05)`);
          grad.addColorStop(1, 'rgba(0,0,0,0)');
          
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fill();
        }
        
        ctx.restore();
      }
      
      // Draw starfield
      function drawStarField(ctx) {
        ctx.save();
        
        // Draw around 500 stars of varying sizes and colors
        for (let i = 0; i < 500; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const size = Math.random() * 2 + 0.5;
          
          // Occasionally use colored stars
          let color;
          if (Math.random() < 0.1) {
            // Create some colored stars
            const hue = Math.random() < 0.5 ? 
              Math.floor(Math.random() * 60) : // Yellowish
              Math.floor(Math.random() * 30) + 200; // Blueish
            color = `hsla(${hue}, 80%, 80%, 0.8)`;
          } else {
            // White stars
            color = 'rgba(255, 255, 255, 0.8)';
          }
          
          // Draw the star
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fillStyle = color;
          ctx.fill();
          
          // Add glow to brighter stars
          if (size > 1.5) {
            ctx.beginPath();
            ctx.arc(x, y, size * 2, 0, Math.PI * 2);
            const grad = ctx.createRadialGradient(
              x, y, size/2,
              x, y, size * 2
            );
            grad.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
            grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = grad;
            ctx.fill();
          }
        }
        
        ctx.restore();
      }
      
      // Draw a distant planet with rings
      function drawDistantPlanet(ctx) {
        ctx.save();
        
        // Planet position in upper corner
        const x = canvas.width * 0.15;
        const y = canvas.height * 0.2;
        const radius = canvas.height * 0.08; // Small planet
        
        // Planet gradient
        const planetGrad = ctx.createRadialGradient(
          x - radius * 0.2, y - radius * 0.2, radius * 0.1,
          x, y, radius
        );
        planetGrad.addColorStop(0, '#4a6fa3'); // Lighter bluish
        planetGrad.addColorStop(0.6, '#2c5289'); // Medium blue
        planetGrad.addColorStop(1, '#1c3b6f'); // Darker blue
        
        // Draw planet
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fillStyle = planetGrad;
        ctx.fill();
        
        // Planet rings
        ctx.beginPath();
        ctx.ellipse(x, y, radius * 2, radius * 0.5, Math.PI/6, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(180, 190, 220, 0.3)';
        ctx.lineWidth = radius * 0.1;
        ctx.stroke();
        
        // Ring shadow
        ctx.beginPath();
        ctx.ellipse(x, y, radius * 1.8, radius * 0.45, Math.PI/6, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(100, 120, 180, 0.15)';
        ctx.lineWidth = radius * 0.3;
        ctx.stroke();
        
        ctx.restore();
      }
      
      // Draw comet field diagonally
      function drawCometField(ctx) {
        ctx.save();
        
        // Create diagonal path for comets (lower left to upper right)
        const startX = -canvas.width * 0.2;
        const startY = canvas.height * 1.2;
        const endX = canvas.width * 1.2;
        const endY = -canvas.height * 0.2;
        
        // Comets along the path
        const numComets = 18; // Number of comets in the field
        
        for (let i = 0; i < numComets; i++) {
          // Position along the diagonal path
          const t = i / (numComets - 1);
          const x = startX + (endX - startX) * t;
          const y = startY + (endY - startY) * t;
          
          // Randomize position slightly
          const offsetX = (Math.random() - 0.5) * canvas.width * 0.3;
          const offsetY = (Math.random() - 0.5) * canvas.height * 0.3;
          
          const cometX = x + offsetX;
          const cometY = y + offsetY;
          
          // Random comet size, larger in the center, smaller at ends
          const centerOffset = Math.abs(t - 0.5);
          const sizeMultiplier = 1 - centerOffset;
          const radius = (10 + Math.random() * 25) * sizeMultiplier;
          
          // Create comet shape
          ctx.beginPath();
          
          // Comet body
          ctx.arc(cometX, cometY, radius, 0, Math.PI * 2);
          
          // Tail length based on size
          const tailLength = radius * (3 + Math.random() * 2);
          
          // Tail direction (mostly upper left to lower right)
          const angle = Math.PI * 0.75 + (Math.random() - 0.5) * 0.5;
          
          // Draw the tail
          ctx.moveTo(cometX, cometY);
          ctx.lineTo(
            cometX + Math.cos(angle) * tailLength,
            cometY + Math.sin(angle) * tailLength
          );
          
          // Set comet color with blue cyan outlines
          ctx.fillStyle = 'rgba(30, 30, 50, 0.7)';
          ctx.fill();
          
          // Add blue/cyan outline
          ctx.strokeStyle = 'rgba(100, 200, 255, 0.3)';
          ctx.lineWidth = 2;
          ctx.stroke();
          
          // Add glow effect for bigger comets
          if (radius > 20) {
            ctx.beginPath();
            ctx.arc(cometX, cometY, radius * 1.5, 0, Math.PI * 2);
            
            const glowGrad = ctx.createRadialGradient(
              cometX, cometY, radius * 0.8,
              cometX, cometY, radius * 1.5
            );
            glowGrad.addColorStop(0, 'rgba(100, 200, 255, 0.1)');
            glowGrad.addColorStop(1, 'rgba(100, 200, 255, 0)');
            
            ctx.fillStyle = glowGrad;
            ctx.fill();
          }
        }
        
        ctx.restore();
      }
      
      // Draw subtle spaceship silhouette
      function drawShipSilhouette(ctx) {
        ctx.save();
        
        // Ship position at bottom center
        const x = canvas.width / 2;
        const y = canvas.height * 0.85;
        const size = canvas.height * 0.05; // Very small
        
        // Very subtle, almost invisible
        ctx.globalAlpha = 0.15;
        
        // Simple ship silhouette
        ctx.beginPath();
        ctx.moveTo(x, y - size); // Top
        ctx.lineTo(x + size * 0.7, y + size * 0.5); // Bottom right
        ctx.lineTo(x - size * 0.7, y + size * 0.5); // Bottom left
        ctx.closePath();
        
        // Very subtle gradient
        const shipGrad = ctx.createLinearGradient(
          x, y - size,
          x, y + size
        );
        shipGrad.addColorStop(0, 'rgba(200, 220, 255, 0.3)');
        shipGrad.addColorStop(1, 'rgba(100, 150, 200, 0.1)');
        
        ctx.fillStyle = shipGrad;
        ctx.fill();
        
        // Add very faint engine glow
        ctx.beginPath();
        ctx.arc(x, y + size * 0.5, size * 0.3, 0, Math.PI * 2);
        
        const glowGrad = ctx.createRadialGradient(
          x, y + size * 0.5, 0,
          x, y + size * 0.5, size * 0.6
        );
        glowGrad.addColorStop(0, 'rgba(100, 180, 255, 0.4)');
        glowGrad.addColorStop(1, 'rgba(100, 180, 255, 0)');
        
        ctx.fillStyle = glowGrad;
        ctx.fill();
        
        ctx.restore();
      }
      
      // Update the menu background (subtle panning)
      function updateMenuBackground(dt) {
        if (!menuBgLoaded) return;
        
        // Very slow panning motion (5-10 pixels per minute)
        const panSpeed = 0.15; // pixels per second
        menuBgOffset.x += panSpeed * dt;
        menuBgOffset.y += panSpeed * 0.7 * dt; // Move slightly slower vertically
        
        // Reset when moved too far
        if (menuBgOffset.x > 100 || menuBgOffset.y > 100) {
          menuBgOffset.x = 0;
          menuBgOffset.y = 0;
        }
      }
      
      // Draw the menu background on the main canvas
      function renderMenuBackground() {
        if (!menuBgLoaded) return;
        
        // Draw with slight offset for slow panning
        ctx.save();
        // Apply 60% opacity
        ctx.globalAlpha = 0.7;
        ctx.drawImage(
          menuBgCanvas, 
          -menuBgOffset.x, -menuBgOffset.y, 
          canvas.width + menuBgOffset.x, canvas.height + menuBgOffset.y
        );
        ctx.restore();
      }
      
      // Initialize the menu background on window load or resize
      window.addEventListener('load', initMenuBackground);
      window.addEventListener('resize', initMenuBackground);

      // ----- Global Constants -----
      const SHIP_ROT_SPEED = 6;       // radians/sec
      const SHIP_REVERSE = 400;     // pixels/secÂ² (braking)
      const BULLET_SPEED = 600;     // pixels/sec
      const BULLET_RADIUS = 4;
      const BULLET_INTERVAL = 30;      // ms between shots
      const FRICTION = 0.99;

      const SHIP_SIZE = 30;      // spaceship size (pixels)
      const SHIP_ACCEL = 800;     // pixels/secÂ²
      
      // Triple Shot Power-up Constants
      const TRIPLE_SHOT_DURATION = 20;  // Seconds the power-up lasts
      const TRIPLE_SHOT_POWERUP_COLOR = "#1e90ff"; // Dodger blue color
      const ENHANCED_SHOT_MULTIPLIER = 6; // For Infinity mode when reaching 150% spawn rate
      const TRIPLE_SHOT_SPAWN_TIME = 3; // Seconds before big comets to spawn power-up

      // Normal Comets â€“ speeds: 400 to 700
      const COMET_SPEED_MIN = 400;
      const COMET_SPEED_MAX = 700;
      const COMET_FRICTION = 0.998;
      const MAX_COMET_TIER = 3;
      const BASE_COMET_RADIUS = 30;
      const COMET_SPAWN_MIN = 2;
      const COMET_SPAWN_MAX = 3;
      const COMET_SPAWN_BATCH_MIN = 1;
      const COMET_SPAWN_BATCH_MAX = 3;
      const COMET_MIN_SPEED = 250;

      // Big Comets
      let bigComets = [];
      let bigCometSpawnTimer = 0;
      const BIG_COMET_SPAWN_INTERVAL = 25;
      const BIG_COMET_SPAWN_MAX = 1;
      const DIAGONAL_ANGLES = [Math.PI / 4, 3 * Math.PI / 4, 5 * Math.PI / 4, 7 * Math.PI / 4];
      const BIG_COMET_SPEED_MIN = 150;
      const BIG_COMET_SPEED_MAX = 200;
      const BIG_COMET_COLOR = "#cd7f32";
      const BIG_COMET_SCALE = 5.5;
      const BIG_COMET_HEALTH = 1000; // Number of bullet hits required to break
      const BIG_COMET_BREAKUP_PIECES = 20; // Number of tier 2 comets to spawn on explosion

      // Powerâ€‘Up Constants
      const POWERUP_SPAWN_INTERVAL = 15;
      const POWERUP_LIFETIME = 15;
      const POWERUP_SIZE = 45; // Core size of power-ups (increased from 30)
      const POWERUP_RADIUS = POWERUP_SIZE; // For collision detection
      const POWERUP_BLINK_SPEED = 5; // Blinking effect speed for power-ups
      const POWERUP_PULSE_SPEED = 2; // Pulsation speed for the glow effect
      const POWERUP_ROTATION_SPEED = 1; // Rotation speed for the orbital particles

      // Pulsar animation variables
      let pulsarActive = true;
      let pulsarX = 100;
      let pulsarY = 100;
      let pulsarRadius = 25;
      let pulsarTime = 0;
      let pulsarColor = 'rgba(100, 200, 255, ';
      
      let powerUps = [];
      let powerUpSpawnTimer = 0;
      let tripleShootPowerUpTimer = 0;
      let tripleShootPowerUpSpawned = false;

      // ----- Difficulty Settings -----
      const DIFFICULTY = {
        EASY: "easy",
        MEDIUM: "medium",
        HARD: "hard",
        INFINITY: "infinity"
      };
      
      // Game duration in seconds for each difficulty
      const GAME_DURATION = {
        [DIFFICULTY.EASY]: 90,
        [DIFFICULTY.MEDIUM]: 110,
        [DIFFICULTY.HARD]: 120,
        [DIFFICULTY.INFINITY]: Infinity
      };
      
      // Comet spawn rate multipliers for each difficulty
      const SPAWN_RATE_MULTIPLIER = {
        [DIFFICULTY.EASY]: 0.7,  // 70% of base rate
        [DIFFICULTY.MEDIUM]: 1.0, // Base rate (100%)
        [DIFFICULTY.HARD]: 1.1,  // 110% of base rate
        [DIFFICULTY.INFINITY]: 1.0 // Starts at base rate, increases over time
      };
      
      // ----- Game State & Timer -----
      let currentDifficulty = DIFFICULTY.MEDIUM; // Default difficulty
      let score = 0;
      let gameTime = 0;
      let winTriggered = false;
      let infinityModeTime = 0; // Tracks time in infinity mode
      let infinityModeSpawnMultiplier = 1.0; // Starting multiplier for infinity mode
      
      // Menu selection tracking
      let selectedMainMenuItem = 0;
      let selectedDifficultyItem = 1; // Default to Medium
      let selectedSettingsItem = 0;
      let selectedPauseMenuItem = 0; // For pause menu
      let previousGameState = null; // To track navigation between screens

      // Spaceship
      let spaceship = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        vx: 0,
        vy: 0,
        angle: 0,
        size: SHIP_SIZE,
        hitPoints: 5,
        hitFlashTimer: 0,
        tripleShot: false,
        tripleShotTimer: 0
      };

      let bullets = [];
      let sparks = [];
      let smallExplosionParticles = [];
      let comets = [];

      // ----- Background Elements -----
      const NUM_STARS = 500;
      const NUM_DISTANT_STARS = 200;
      const NUM_NEBULA_CLOUDS = 5;
      const NUM_DUST_PARTICLES = 120;
      const NUM_SHOOTING_STARS = 3;
      
      let stars = [];
      let distantStars = []; // Parallax effect stars
      let nebulaClouds = [];
      let spaceDust = [];
      let shootingStars = [];
      let auroraPoints = [];
      
      // Initialize all background elements
      function initStarfield() {
        // Reset all arrays
        stars = [];
        distantStars = [];
        nebulaClouds = [];
        spaceDust = [];
        shootingStars = [];
        auroraPoints = [];
        
        // Regular stars (closer/faster)
        for (let i = 0; i < NUM_STARS; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const baseSize = Math.random() * 2 + 0.5;
          const flicker = Math.random() < 0.7;
          const sizeVariation = flicker ? (Math.random() * 1 + 0.2) : 0;
          const sizeSpeed = flicker ? (Math.random() * 0.5 + 0.2) : 0;
          const sizeTime = flicker ? Math.random() * Math.PI * 2 : 0;
          // Add color variations for some stars
          const colorHue = Math.random() < 0.2 ? 
            Math.floor(Math.random() * 60) + (Math.random() < 0.5 ? 0 : 180) : // red/orange or blue tones
            null; // white (default)
          stars.push({ 
            x, y, baseSize, sizeVariation, sizeSpeed, sizeTime, flicker, 
            colorHue,
            parallaxFactor: 1.0 
          });
        }
        
        // Distant stars (parallax effect - move slower)
        for (let i = 0; i < NUM_DISTANT_STARS; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const baseSize = Math.random() * 1.5 + 0.3;
          const flicker = Math.random() < 0.3; // Less flickering in distance
          const sizeVariation = flicker ? (Math.random() * 0.7 + 0.1) : 0;
          const sizeSpeed = flicker ? (Math.random() * 0.3 + 0.1) : 0;
          const sizeTime = flicker ? Math.random() * Math.PI * 2 : 0;
          distantStars.push({ 
            x, y, baseSize, sizeVariation, sizeSpeed, sizeTime, flicker,
            parallaxFactor: 0.3 // Move much slower
          });
        }
        
        // Nebula clouds
        for (let i = 0; i < NUM_NEBULA_CLOUDS; i++) {
          // Create larger-scale nebula elements
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const width = Math.random() * 300 + 200;
          const height = Math.random() * 200 + 150;
          
          // Random nebula colors - purples, blues, reds
          const colorPalette = [
            'rgba(110, 20, 170, 0.07)',  // Purple
            'rgba(50, 70, 180, 0.06)',   // Blue
            'rgba(180, 50, 90, 0.05)',   // Red
            'rgba(60, 100, 200, 0.07)',  // Light blue
            'rgba(180, 90, 30, 0.05)'    // Orange
          ];
          
          const color = colorPalette[Math.floor(Math.random() * colorPalette.length)];
          const driftSpeed = {
            x: (Math.random() - 0.5) * 4, // Slow horizontal drift
            y: (Math.random() - 0.5) * 2  // Even slower vertical drift
          };
          
          nebulaClouds.push({
            x, y, width, height, color, driftSpeed,
            // Each nebula has several "centers" to create irregular shapes
            centers: Array(Math.floor(Math.random() * 4 + 3)).fill().map(() => ({
              xOffset: (Math.random() - 0.5) * width * 0.7,
              yOffset: (Math.random() - 0.5) * height * 0.7,
              radius: Math.random() * 80 + 40
            })),
            // Animation variables
            time: Math.random() * Math.PI * 2,
            timeFactor: Math.random() * 0.4 + 0.1
          });
        }
        
        // Space dust particles
        for (let i = 0; i < NUM_DUST_PARTICLES; i++) {
          const x = Math.random() * canvas.width;
          const y = Math.random() * canvas.height;
          const size = Math.random() * 1.5 + 0.5;
          const opacity = Math.random() * 0.15 + 0.05; // Very subtle
          const driftSpeed = {
            x: (Math.random() - 0.5) * 15, // Medium drift speed
            y: (Math.random() - 0.5) * 15
          };
          
          spaceDust.push({
            x, y, size, opacity, driftSpeed
          });
        }
        
        // Create shooting stars (inactive initially)
        for (let i = 0; i < NUM_SHOOTING_STARS; i++) {
          shootingStars.push({
            active: false,
            timeToNext: Math.random() * 10 + 5 // Random delay before first appearance
          });
        }
        
        // Aurora points
        const numPoints = 15;
        for (let i = 0; i < numPoints; i++) {
          const xPos = (i / (numPoints - 1)) * canvas.width;
          auroraPoints.push({
            x: xPos,
            y: canvas.height * 0.05, // Near top of screen
            wavePhase: Math.random() * Math.PI * 2,
            waveSpeed: Math.random() * 0.5 + 0.2
          });
        }
      }
      
      initStarfield();
      
      function updateStarfield(dt) {
        // Update regular stars
        for (let star of stars) {
          if (star.flicker) {
            star.sizeTime += dt * star.sizeSpeed;
          }
        }
        
        // Update distant stars (slower)
        for (let star of distantStars) {
          if (star.flicker) {
            star.sizeTime += dt * star.sizeSpeed * 0.7; // Even slower flicker
          }
        }
        
        // Update nebula clouds - slow drifting motion
        for (let cloud of nebulaClouds) {
          cloud.x += cloud.driftSpeed.x * dt * 0.2;
          cloud.y += cloud.driftSpeed.y * dt * 0.1;
          
          // Wrap around edges
          if (cloud.x < -cloud.width) cloud.x = canvas.width + cloud.width/2;
          if (cloud.x > canvas.width + cloud.width) cloud.x = -cloud.width/2;
          if (cloud.y < -cloud.height) cloud.y = canvas.height + cloud.height/2;
          if (cloud.y > canvas.height + cloud.height) cloud.y = -cloud.height/2;
          
          // Update animation time
          cloud.time += dt * cloud.timeFactor;
        }
        
        // Update space dust - faster drift
        for (let dust of spaceDust) {
          dust.x += dust.driftSpeed.x * dt;
          dust.y += dust.driftSpeed.y * dt;
          
          // Wrap around edges
          if (dust.x < 0) dust.x = canvas.width;
          if (dust.x > canvas.width) dust.x = 0;
          if (dust.y < 0) dust.y = canvas.height;
          if (dust.y > canvas.height) dust.y = 0;
        }
        
        // Update shooting stars
        for (let star of shootingStars) {
          if (!star.active) {
            // Count down to next activation
            star.timeToNext -= dt;
            if (star.timeToNext <= 0) {
              // Activate new shooting star
              star.active = true;
              star.x = Math.random() * canvas.width;
              star.y = Math.random() * (canvas.height * 0.3); // Top third of screen
              star.length = Math.random() * 100 + 50;
              star.angle = Math.PI * 0.25 + Math.random() * Math.PI * 0.5; // Downward angle
              star.speed = Math.random() * 300 + 200;
              star.duration = Math.random() * 2 + 1; // 1-3 seconds
              star.elapsed = 0;
              star.thickness = Math.random() * 2 + 1;
            }
          } else {
            // Update active shooting star
            star.x += Math.cos(star.angle) * star.speed * dt;
            star.y += Math.sin(star.angle) * star.speed * dt;
            star.elapsed += dt;
            
            // Check if shooting star is done
            if (star.elapsed >= star.duration || 
                star.x < -star.length || star.x > canvas.width + star.length ||
                star.y < -star.length || star.y > canvas.height + star.length) {
              star.active = false;
              star.timeToNext = Math.random() * 15 + 5; // 5-20 seconds until next appearance
            }
          }
        }
        
        // Update aurora points
        for (let point of auroraPoints) {
          point.wavePhase += dt * point.waveSpeed;
          // Aurora waves up and down slightly
          point.y = canvas.height * 0.05 + Math.sin(point.wavePhase) * 15;
        }
      }
      
      function drawStarfield(ctx) {
        ctx.save();
        
        // Draw nebula clouds first (behind everything)
        for (let cloud of nebulaClouds) {
          ctx.save();
          // For each cloud, draw multiple overlapping gradients at its "centers"
          for (let center of cloud.centers) {
            const x = cloud.x + center.xOffset;
            const y = cloud.y + center.yOffset;
            // Add subtle pulsing to the radius
            const adjustedRadius = center.radius * (1 + 0.1 * Math.sin(cloud.time));
            
            const gradient = ctx.createRadialGradient(
              x, y, 0,
              x, y, adjustedRadius
            );
            gradient.addColorStop(0, cloud.color);
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, adjustedRadius, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();
        }
        
        // Draw distant stars (parallax effect)
        for (let star of distantStars) {
          let currentSize = star.baseSize;
          if (star.flicker) {
            currentSize += star.sizeVariation * Math.sin(star.sizeTime);
            if (currentSize < 0) currentSize = 0;
          }
          let gradient = ctx.createRadialGradient(
            star.x, star.y, currentSize * 0.2,
            star.x, star.y, currentSize
          );
          gradient.addColorStop(0, "rgba(255,255,255,0.8)");
          gradient.addColorStop(1, "rgba(255,255,255,0)");
          ctx.fillStyle = gradient;
          ctx.shadowBlur = 3; // Less glow for distant stars
          ctx.shadowColor = "white";
          ctx.beginPath();
          ctx.arc(star.x, star.y, currentSize, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Draw closer/regular stars
        for (let star of stars) {
          let currentSize = star.baseSize;
          if (star.flicker) {
            currentSize += star.sizeVariation * Math.sin(star.sizeTime);
            if (currentSize < 0) currentSize = 0;
          }
          
          // Color or white based on star properties
          let innerColor, outerColor;
          if (star.colorHue !== null) {
            innerColor = `hsla(${star.colorHue}, 80%, 70%, 1)`;
            outerColor = `hsla(${star.colorHue}, 80%, 70%, 0)`;
          } else {
            innerColor = "rgba(255,255,255,1)";
            outerColor = "rgba(255,255,255,0)";
          }
          
          let gradient = ctx.createRadialGradient(
            star.x, star.y, currentSize * 0.2,
            star.x, star.y, currentSize
          );
          gradient.addColorStop(0, innerColor);
          gradient.addColorStop(1, outerColor);
          ctx.fillStyle = gradient;
          ctx.shadowBlur = 5;
          ctx.shadowColor = star.colorHue !== null ? innerColor : "white";
          ctx.beginPath();
          ctx.arc(star.x, star.y, currentSize, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Draw space dust particles
        ctx.shadowBlur = 0; // No glow for dust
        for (let dust of spaceDust) {
          ctx.fillStyle = `rgba(255,255,255,${dust.opacity})`;
          ctx.beginPath();
          ctx.arc(dust.x, dust.y, dust.size, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Draw shooting stars
        for (let star of shootingStars) {
          if (star.active) {
            ctx.save();
            // Fade in at start and out at end
            const fade = Math.min(star.elapsed, star.duration - star.elapsed) / 0.3;
            const alpha = Math.min(1, fade);
            
            // Trail gradient
            const gradient = ctx.createLinearGradient(
              star.x, star.y,
              star.x - Math.cos(star.angle) * star.length,
              star.y - Math.sin(star.angle) * star.length
            );
            gradient.addColorStop(0, `rgba(255,255,255,${alpha})`);
            gradient.addColorStop(0.3, `rgba(200,200,255,${alpha * 0.6})`);
            gradient.addColorStop(1, 'rgba(200,200,255,0)');
            
            ctx.strokeStyle = gradient;
            ctx.lineWidth = star.thickness;
            ctx.shadowBlur = 10;
            ctx.shadowColor = "white";
            
            ctx.beginPath();
            ctx.moveTo(star.x, star.y);
            ctx.lineTo(
              star.x - Math.cos(star.angle) * star.length,
              star.y - Math.sin(star.angle) * star.length
            );
            ctx.stroke();
            ctx.restore();
          }
        }
        
        // Draw aurora effect near the top of the screen
        if (auroraPoints.length > 1) {
          ctx.save();
          // Create aurora gradient
          const gradient = ctx.createLinearGradient(
            canvas.width / 2, 0,
            canvas.width / 2, canvas.height * 0.15
          );
          gradient.addColorStop(0, 'rgba(0, 200, 100, 0.2)'); // Green
          gradient.addColorStop(0.5, 'rgba(20, 100, 200, 0.1)'); // Blue
          gradient.addColorStop(1, 'rgba(0, 0, 0, 0)'); // Fade out
          
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.moveTo(0, canvas.height);
          
          // Draw top curve
          ctx.moveTo(0, auroraPoints[0].y);
          for (let i = 0; i < auroraPoints.length - 1; i++) {
            const xMid = (auroraPoints[i].x + auroraPoints[i+1].x) / 2;
            const yMid = (auroraPoints[i].y + auroraPoints[i+1].y) / 2;
            ctx.quadraticCurveTo(
              auroraPoints[i].x, auroraPoints[i].y,
              xMid, yMid
            );
          }
          // Last curve
          ctx.quadraticCurveTo(
            auroraPoints[auroraPoints.length-1].x, 
            auroraPoints[auroraPoints.length-1].y,
            canvas.width, auroraPoints[auroraPoints.length-1].y
          );
          
          // Complete the aurora shape
          ctx.lineTo(canvas.width, 0);
          ctx.lineTo(0, 0);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }
        
        ctx.restore();
      }

      function generateStonePattern() {
        const baseColors = [
        "#8B4513", // Saddle Brown
          "#A0522D", // Sienna
          "#6B4423", // Deep Brown
          "#8B5742", // Light Brown
          "#654321", // Dark Brown
          "#704214", // Rustic Brown
          "#5C4033", // Rich Brown
          "#4A3728", // Dark Chocolate
          "#6F4E37", // Coffee
          "#7B3F00"  // Chocolate
        ];
        // Pick a random base color
        const baseColor = baseColors[Math.floor(Math.random() * baseColors.length)];

        let patternCanvas = document.createElement("canvas");
        patternCanvas.width = 50;
        patternCanvas.height = 50;
        let pctx = patternCanvas.getContext("2d");

        // Use the chosen base color
        pctx.fillStyle = baseColor;
        pctx.fillRect(0, 0, patternCanvas.width, patternCanvas.height);

        // Add random speckles for texture
        for (let i = 0; i < 20; i++) {
          let x = Math.random() * patternCanvas.width;
          let y = Math.random() * patternCanvas.height;
          let radius = Math.random() * 3;
          // Use random gray values for the speckles
          let gray = Math.floor(100 + Math.random() * 50);
          pctx.fillStyle = `rgb(${gray}, ${gray}, ${gray})`;
          pctx.beginPath();
          pctx.arc(x, y, radius, 0, 2 * Math.PI);
          pctx.fill();
        }

        return ctx.createPattern(patternCanvas, "repeat");
      }

      // Planet animation state vars
      let ringRotation = -Math.PI / 6; // Fixed rotation angle - no rotation
      let planetGlowTime = 0; // Time for planet glow effect
      let planetGlowSpeed = 0.3; // Reduced speed of glow pulsation for less trembling
      
      // ----- Cronos Planet -----
      function drawCronos(ctx) {
        // Planet position & size
        const x = canvas.width * 0.75;
        const y = canvas.height * 0.5;
        const radius = 200; // Planet radius
        
        // Update planet animation values - reduced trembling
        planetGlowTime += 0.016; // Approximate dt for consistent animation
        const glowStrength = 3 + Math.sin(planetGlowTime * planetGlowSpeed) * 1.2; // Reduced oscillation
        
        // No rotation of rings
        
        // ---------- Planet Surface Features ----------
        // Create surface details canvas
        const surfaceCanvas = document.createElement('canvas');
        surfaceCanvas.width = radius * 2.5;
        surfaceCanvas.height = radius * 2.5;
        const surfaceCtx = surfaceCanvas.getContext('2d');
        
        // Base planet color
        surfaceCtx.fillStyle = "#b09b83";
        surfaceCtx.fillRect(0, 0, surfaceCanvas.width, surfaceCanvas.height);
        
        // Add some large darker areas (craters and surface features)
        for (let i = 0; i < 8; i++) {
          const featureX = Math.random() * surfaceCanvas.width;
          const featureY = Math.random() * surfaceCanvas.height;
          const featureSize = Math.random() * radius * 0.8 + radius * 0.3;
          const featureGradient = surfaceCtx.createRadialGradient(
            featureX, featureY, 0,
            featureX, featureY, featureSize
          );
          featureGradient.addColorStop(0, 'rgba(80, 70, 55, 0.4)');
          featureGradient.addColorStop(1, 'rgba(120, 110, 95, 0)');
          
          surfaceCtx.fillStyle = featureGradient;
          surfaceCtx.beginPath();
          surfaceCtx.arc(featureX, featureY, featureSize, 0, Math.PI * 2);
          surfaceCtx.fill();
        }
        
        // Create lighter areas for highlands
        for (let i = 0; i < 6; i++) {
          const featureX = Math.random() * surfaceCanvas.width;
          const featureY = Math.random() * surfaceCanvas.height;
          const featureSize = Math.random() * radius * 0.6 + radius * 0.2;
          const featureGradient = surfaceCtx.createRadialGradient(
            featureX, featureY, 0,
            featureX, featureY, featureSize
          );
          featureGradient.addColorStop(0, 'rgba(200, 190, 170, 0.3)');
          featureGradient.addColorStop(1, 'rgba(200, 190, 170, 0)');
          
          surfaceCtx.fillStyle = featureGradient;
          surfaceCtx.beginPath();
          surfaceCtx.arc(featureX, featureY, featureSize, 0, Math.PI * 2);
          surfaceCtx.fill();
        }
        
        // The planet's surface pattern
        const surfacePattern = ctx.createPattern(surfaceCanvas, 'no-repeat');

        // ---------- Planet Gradient with Surface ----------
        const grad = ctx.createRadialGradient(x, y, radius * 0.2, x, y, radius);
        grad.addColorStop(0.2, "#c9b8a3"); // center
        grad.addColorStop(0.5, "#b09b83");
        grad.addColorStop(0.8, "#97856f");
        grad.addColorStop(1, "#7f6f5a"); // outer edge

        // ---------- Ring Geometry ----------
        const ringOuter = radius * 1.9;   // Outer ellipse radius
        const ringInner = radius * 1.25;  // Inner ellipse radius
        const ringFlatten = 0.45;         // How "flat" the ring ellipse is

        // ---------- Ring Pattern with Dust ----------
        const ringCanvas = document.createElement("canvas");
        ringCanvas.width = 80;
        ringCanvas.height = 40;
        const ringCtx = ringCanvas.getContext("2d");

        // Semiâ€‘transparent dark fill
        ringCtx.fillStyle = "rgba(60,50,40,0.4)";
        ringCtx.fillRect(0, 0, ringCanvas.width, ringCanvas.height);

        // Scatter small dots for ring dust with some color variation
        for (let i = 0; i < 40; i++) {
          const rx = Math.random() * ringCanvas.width;
          const ry = Math.random() * ringCanvas.height;
          const dustColor = Math.random() < 0.3 ? 
            "rgba(180,160,120,0.5)" : // Lighter dust particles
            "rgba(0,0,0,0.6)";        // Darker dust particles
          ringCtx.fillStyle = dustColor;
          ringCtx.beginPath();
          ringCtx.arc(rx, ry, Math.random() * 1.5 + 0.5, 0, 2 * Math.PI);
          ringCtx.fill();
        }

        const ringPattern = ctx.createPattern(ringCanvas, "repeat");

        // Helper function: draw half of a donut arc from angleStart to angleEnd
        // Using "evenodd" so the inner ellipse carves out a hole.
        function drawDonutArc(angleStart, angleEnd) {
          ctx.beginPath();
          // Outer ellipse arc
          ctx.ellipse(0, 0, ringOuter, ringOuter * ringFlatten, 0, angleStart, angleEnd, true);
          // Inner ellipse arc (reverse)
          ctx.ellipse(0, 0, ringInner, ringInner * ringFlatten, 0, angleEnd, angleStart, false);
          ctx.fillStyle = ringPattern;
          ctx.fill("evenodd");
        }

        // ---------- DRAW THE RING BACK HALF ----------
        // (the portion behind the planet)
        ctx.save();
        // Move to planet center & tilt the ring - now with animation
        ctx.translate(x, y);
        ctx.rotate(ringRotation);
        // e.g. 0..Math.PI is the "back half" after rotation
        drawDonutArc(0, Math.PI);
        ctx.restore();

        // ---------- DRAW THE PLANET ----------
        ctx.save();
        
        // Draw planet glow
        const glowGradient = ctx.createRadialGradient(
          x, y, radius * 0.9,
          x, y, radius * 1.5
        );
        glowGradient.addColorStop(0, 'rgba(180,160,140,0.2)');
        glowGradient.addColorStop(1, 'rgba(180,160,140,0)');
        
        ctx.fillStyle = glowGradient;
        ctx.beginPath();
        ctx.arc(x, y, radius * 1.5, 0, 2 * Math.PI);
        ctx.fill();
        
        // Draw the main planet with pattern
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI);
        ctx.fill();
        
        // Apply the surface pattern to the planet
        ctx.globalCompositeOperation = 'multiply';
        ctx.translate(x - radius * 1.25, y - radius * 1.25);
        ctx.fillStyle = surfacePattern;
        ctx.beginPath();
        ctx.arc(radius * 1.25, radius * 1.25, radius, 0, 2 * Math.PI);
        ctx.fill();
        ctx.globalCompositeOperation = 'source-over';
        
        // Draw atmosphere highlight
        ctx.translate(-x + radius * 1.25, -y + radius * 1.25);
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI);
        const highlight = ctx.createRadialGradient(
          x - radius * 0.3, y - radius * 0.3, 0,
          x, y, radius
        );
        highlight.addColorStop(0, 'rgba(240,230,215,0.15)');
        highlight.addColorStop(0.6, 'rgba(240,230,215,0.03)');
        highlight.addColorStop(1, 'rgba(240,230,215,0)');
        ctx.fillStyle = highlight;
        ctx.fill();
        
        ctx.restore();

        // ---------- DRAW THE RING FRONT HALF ----------
        // (the portion in front of the planet)
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(ringRotation);
        // front half is Math.PI..2*Math.PI
        drawDonutArc(Math.PI, 2 * Math.PI);
        ctx.restore();
        
        // No ring shadow on the planet as requested
        ctx.restore();
      }


      function drawMusicIcon() {
        const iconSize = 40;
        const margin = 20;
        const x = margin;
        const y = margin;
        
        ctx.save();
        ctx.fillStyle = "white";
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        
        // Draw speaker base
        ctx.beginPath();
        ctx.moveTo(x, y + iconSize/2);
        ctx.lineTo(x + iconSize/3, y + iconSize/2);
        ctx.lineTo(x + iconSize*2/3, y);
        ctx.lineTo(x + iconSize*2/3, y + iconSize);
        ctx.lineTo(x + iconSize/3, y + iconSize/2);
        ctx.closePath();
        ctx.fill();
        
        // Draw sound waves if sound is enabled - check both music and sound effects
        if (musicEnabled && soundEnabled) {
          // First wave
          ctx.beginPath();
          ctx.arc(x + iconSize*2/3, y + iconSize/2, iconSize/3, -Math.PI/4, Math.PI/4);
          ctx.stroke();
          
          // Second wave
          ctx.beginPath();
          ctx.arc(x + iconSize*2/3, y + iconSize/2, iconSize*2/3, -Math.PI/4, Math.PI/4);
          ctx.stroke();
        } else {
          // Draw X over the speaker when either sound or music is off
          ctx.beginPath();
          ctx.moveTo(x + iconSize/3, y + iconSize/4);
          ctx.lineTo(x + iconSize, y + iconSize*3/4);
          ctx.stroke();
          
          ctx.beginPath();
          ctx.moveTo(x + iconSize, y + iconSize/4);
          ctx.lineTo(x + iconSize/3, y + iconSize*3/4);
          ctx.stroke();
        }
        
        ctx.restore();
      }

      function drawHealthBar() {
        const barWidth = 100;
        const barHeight = 15;
        const margin = 20;
        const x = canvas.width - margin - barWidth;
        const y = margin;
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, barWidth, barHeight);
        let hpFraction = spaceship.hitPoints / 5;
        ctx.fillStyle = "red";
        ctx.fillRect(x, y, barWidth * hpFraction, barHeight);
      }

      function spawnPowerUp() {
        let loc = getPowerUpSpawnLocation(); // Use the central spawn location
        return {
          x: loc.x,
          y: loc.y,
          vx: randomRange(-40, 40), // Slightly slower movement
          vy: randomRange(-40, 40),
          lifetime: 10,
          radius: POWERUP_RADIUS,
          type: "health" // Default type is health
        };
      }
      
      function spawnTripleShotPowerUp() {
        let loc = getPowerUpSpawnLocation(); // Use the central spawn location
        return {
          x: loc.x,
          y: loc.y,
          vx: randomRange(-40, 40), // Slightly slower movement
          vy: randomRange(-40, 40),
          lifetime: TRIPLE_SHOT_DURATION, // Power-up exists for 20 seconds before disappearing
          radius: POWERUP_RADIUS,
          type: "tripleShot",
          enhanced: currentDifficulty === DIFFICULTY.INFINITY && infinityModeSpawnMultiplier >= 1.5
        };
      }

      // Timers
      let lastBulletTime = 0;
      let cometSpawnTimer = 0;

      // Big Comet logic
      function updateBigComets(dt) {
        for (let i = bigComets.length - 1; i >= 0; i--) {
          let bc = bigComets[i];
          
          // Update hit flash timer
          if (bc.hitFlashTimer > 0) {
            bc.hitFlashTimer -= dt;
            if (bc.hitFlashTimer < 0) bc.hitFlashTimer = 0;
          }
          
          // Update shake effect with higher frequency for more damage
          if (bc.shakeTimer > 0) {
            bc.shakeTimer -= dt;
            
            // Adjust frequency based on damage - much higher frequency
            const shakeFrequency = 10 + (bc.hitCount / BIG_COMET_HEALTH) * 50; // Increase from 10 to 60 Hz
            
            // Use sine waves with increasing frequency for more natural vibration
            const time = performance.now() / 1000; // Current time in seconds
            
            // Apply shake with higher frequency but MUCH smaller amplitude as damage increases
            // Cap the maximum shake distance to a small value
            const maxShakeDistance = Math.min(bc.shakeAmount, 8); // Never shake more than 8 pixels
            const dampingFactor = Math.max(0.15, 1 - (bc.hitCount / BIG_COMET_HEALTH)); // More damping
            
            // Use multiple sine waves at different frequencies for more chaotic vibration
            bc.shakeX = (
              Math.sin(time * shakeFrequency) * 0.6 + 
              Math.sin(time * shakeFrequency * 1.3) * 0.4
            ) * maxShakeDistance * dampingFactor;
            bc.shakeY = Math.cos(time * shakeFrequency * 1.3) * maxShakeDistance * dampingFactor * 0.8; // Y-shake is slightly less
            
            // Gradually reduce shake amount
            bc.shakeAmount *= 0.98;
            
            if (bc.shakeTimer <= 0) {
              bc.shakeTimer = 0;
              bc.shakeX = 0;
              bc.shakeY = 0;
            }
          }
          
          // Apply movement with reduced speed based on hit count
          // The more hits, the slower it moves
          const speedFactor = Math.max(0.2, 1 - (bc.hitCount / BIG_COMET_HEALTH) * 0.8);
          bc.x += bc.vx * dt * speedFactor;
          bc.y += bc.vy * dt * speedFactor;
          
          // Remove if out of bounds
          if (bc.x < -bc.radius || bc.x > canvas.width + bc.radius ||
              bc.y < -bc.radius || bc.y > canvas.height + bc.radius) {
            bigComets.splice(i, 1);
          }
          
          // Check if it should explode
          if (bc.hitPoints <= 0) {
            // Create a huge explosion
            createHugeExplosion(bc.x, bc.y);
            
            // Spawn tier 2 comets
            for (let j = 0; j < BIG_COMET_BREAKUP_PIECES; j++) {
              const angle = Math.random() * Math.PI * 2;
              const distance = bc.radius * 0.5 * Math.random();
              const speed = randomRange(COMET_SPEED_MIN, COMET_SPEED_MAX);
              
              spawnComet(
                2, // Tier 2 comets
                bc.x + Math.cos(angle) * distance,
                bc.y + Math.sin(angle) * distance,
                Math.cos(angle) * speed,
                Math.sin(angle) * speed
              );
            }
            
            // Award score
            score += 100;
            
            // Remove the big comet
            bigComets.splice(i, 1);
          }
        }
      }

      function updateTimers(dt) {
        bigCometSpawnTimer += dt;
        if (bigCometSpawnTimer >= BIG_COMET_SPAWN_INTERVAL) {
          for (let i = 0; i < BIG_COMET_SPAWN_MAX; i++) {
            spawnBigComet();
          }
          bigCometSpawnTimer = 0;
        }
      }

      // INPUT HANDLING
      const keys = {};
      window.addEventListener("keydown", (e) => {
        // Music toggle with 'M' key (in any game state)
        if (e.key.toLowerCase() === "m" || e.code === "KeyM") {
          // Get the current state before toggling
          const wasMusicEnabled = musicEnabled;
          const wasSoundEnabled = soundEnabled;
          
          // Set both to the same state (both on or both off)
          if (wasMusicEnabled || wasSoundEnabled) {
            // If either was on, turn both off
            musicEnabled = false;
            soundEnabled = false;
            // Apply changes
            bgMusic.pause();
            
            // Mute all sound effects
            powerUpSound.muted = true;
            victorySound.muted = true;
            defeatSound.muted = true;
            
            // Mute sound pools
            for (let sound of bulletSoundPool) {
              sound.muted = true;
            }
            for (let sound of hitSoundPool) {
              sound.muted = true;
            }
          } else {
            // If both were off, turn both on
            musicEnabled = true;
            soundEnabled = true;
            
            // Resume appropriate music
            if (gameState === GAME_STATE.MAIN_MENU || gameState === GAME_STATE.SETTINGS || 
                gameState === GAME_STATE.DIFFICULTY_SELECT || gameState === GAME_STATE.HOW_TO_PLAY || 
                gameState === GAME_STATE.HIGH_SCORES) {
              startMenuMusic();
            } else if (gameState === GAME_STATE.PLAYING) {
              startGameplayMusic();
            }
            
            // Unmute all sound effects
            powerUpSound.muted = false;
            victorySound.muted = false;
            defeatSound.muted = false;
            
            // Unmute sound pools
            for (let sound of bulletSoundPool) {
              sound.muted = false;
            }
            for (let sound of hitSoundPool) {
              sound.muted = false;
            }
          }
        }
        
        // Open pause menu with Escape key during gameplay
        if (gameState === GAME_STATE.PLAYING && (e.key === "Escape" || e.keyCode === 27)) {
          gameState = GAME_STATE.PAUSE_MENU;
          // Keep game music playing but at lower volume
          if (musicEnabled && !bgMusic.paused) {
            bgMusic.volume = 0.05;
          }
        }
        
        // Handle pause menu navigation
        else if (gameState === GAME_STATE.PAUSE_MENU) {
          if (e.key === "ArrowUp" || e.keyCode === 38) {
            // Navigate up in pause menu
            selectedPauseMenuItem = (selectedPauseMenuItem - 1 + 4) % 4;
          } else if (e.key === "ArrowDown" || e.keyCode === 40) {
            // Navigate down in pause menu
            selectedPauseMenuItem = (selectedPauseMenuItem + 1) % 4;
          } else if (e.key === "Enter" || e.code === "Enter" || e.keyCode === 13) {
            // Select current pause menu item
            switch(selectedPauseMenuItem) {
              case 0: // Resume Game
                gameState = GAME_STATE.PLAYING;
                // Restore music volume
                if (musicEnabled && !bgMusic.paused) {
                  bgMusic.volume = 0.1;
                }
                break;
              case 1: // Settings
                previousGameState = GAME_STATE.PAUSE_MENU; // Remember we came from pause menu
                gameState = GAME_STATE.SETTINGS;
                break;
              case 2: // How to Play
                previousGameState = GAME_STATE.PAUSE_MENU; // Remember we came from pause menu
                gameState = GAME_STATE.HOW_TO_PLAY;
                break;
              case 3: // Exit to Main Menu
                // Confirm exit dialog
                if (confirm("Are you sure you want to exit? Your progress will be lost.")) {
                  // Reset the game state manually
                  
                  // Clear all game objects
                  bullets = [];
                  sparks = [];
                  comets = [];
                  bigComets = [];
                  smallExplosionParticles = [];
                  powerUps = [];
                  
                  // Reset spaceship
                  spaceship.x = canvas.width / 2;
                  spaceship.y = canvas.height / 2;
                  spaceship.vx = 0;
                  spaceship.vy = 0;
                  spaceship.angle = 0;
                  spaceship.hitPoints = 5;
                  spaceship.tripleShot = false;
                  
                  // Reset game parameters
                  // Keep the score for display on main menu
                  // score = 0; 
                  gameTime = 0;
                  winTriggered = false;
                  
                  // Keep the current difficulty selection
                  // currentDifficulty = DIFFICULTY.MEDIUM;
                  
                  // Reset menu positions but keep difficulty selection
                  selectedMainMenuItem = 0;
                  // Keep the selected difficulty item
                  // selectedDifficultyItem = 1;
                  selectedPauseMenuItem = 0;
                  selectedSettingsItem = 0;
                  
                  // Set game state directly to main menu (not difficulty select)
                  previousGameState = null;
                  gameState = GAME_STATE.MAIN_MENU;
                  
                  // Start menu music
                  startMenuMusic();
                } else {
                  // If canceled, stay in pause menu
                  gameState = GAME_STATE.PAUSE_MENU;
                }
                break;
            }
          } else if (e.key === "Escape" || e.keyCode === 27) {
            // Resume game with Escape key
            gameState = GAME_STATE.PLAYING;
            // Restore music volume
            if (musicEnabled && !bgMusic.paused) {
              bgMusic.volume = 0.1;
            }
          }
        }
        
        // Main Menu navigation
        if (gameState === GAME_STATE.MAIN_MENU) {
          startMenuMusic();
          
          if (e.key === "ArrowUp" || e.keyCode === 38) {
            // Navigate up in main menu
            selectedMainMenuItem = (selectedMainMenuItem - 1 + 4) % 4;
          } else if (e.key === "ArrowDown" || e.keyCode === 40) {
            // Navigate down in main menu
            selectedMainMenuItem = (selectedMainMenuItem + 1) % 4;
          } else if (e.key === "Enter" || e.code === "Enter" || e.keyCode === 13) {
            // Select current menu item
            switch(selectedMainMenuItem) {
              case 0: // Play Game
                gameState = GAME_STATE.DIFFICULTY_SELECT;
                break;
              case 1: // Settings
                gameState = GAME_STATE.SETTINGS;
                break;
              case 2: // How to Play
                gameState = GAME_STATE.HOW_TO_PLAY;
                break;
              case 3: // High Scores
                gameState = GAME_STATE.HIGH_SCORES;
                break;
            }
          }
        } 
        // Difficulty select screen
        else if (gameState === GAME_STATE.DIFFICULTY_SELECT) {
          if (e.key === "ArrowUp" || e.keyCode === 38) {
            // Navigate up in difficulty menu
            selectedDifficultyItem = (selectedDifficultyItem - 1 + 4) % 4;
            // Update the current difficulty based on selection
            switch(selectedDifficultyItem) {
              case 0: currentDifficulty = DIFFICULTY.EASY; break;
              case 1: currentDifficulty = DIFFICULTY.MEDIUM; break;
              case 2: currentDifficulty = DIFFICULTY.HARD; break;
              case 3: currentDifficulty = DIFFICULTY.INFINITY; break;
            }
          } else if (e.key === "ArrowDown" || e.keyCode === 40) {
            // Navigate down in difficulty menu
            selectedDifficultyItem = (selectedDifficultyItem + 1) % 4;
            // Update the current difficulty based on selection
            switch(selectedDifficultyItem) {
              case 0: currentDifficulty = DIFFICULTY.EASY; break;
              case 1: currentDifficulty = DIFFICULTY.MEDIUM; break;
              case 2: currentDifficulty = DIFFICULTY.HARD; break;
              case 3: currentDifficulty = DIFFICULTY.INFINITY; break;
            }
          } else if (e.key === "Enter" || e.code === "Enter" || e.keyCode === 13) {
            // Start the game with selected difficulty
            gameState = GAME_STATE.PLAYING;
            score = 0;
            gameTime = 0;
            winTriggered = false;
            
            // Reset infinity mode time and multiplier
            infinityModeTime = 0;
            infinityModeSpawnMultiplier = 1.0;
            
            startGameplayMusic();
          } else if (e.key === "Escape" || e.keyCode === 27) {
            // Back to main menu
            gameState = GAME_STATE.MAIN_MENU;
          }
        } 
        // Settings screen
        else if (gameState === GAME_STATE.SETTINGS) {
          if (e.key === "ArrowUp" || e.keyCode === 38) {
            // Navigate up in settings menu
            selectedSettingsItem = (selectedSettingsItem - 1 + 2) % 2;
          } else if (e.key === "ArrowDown" || e.keyCode === 40) {
            // Navigate down in settings menu
            selectedSettingsItem = (selectedSettingsItem + 1) % 2;
          } else if (e.key === "Enter" || e.code === "Enter" || e.keyCode === 13) {
            // Toggle the selected setting
            if (selectedSettingsItem === 0) {
              // Toggle music
              toggleMusic();
            } else if (selectedSettingsItem === 1) {
              // Toggle sound effects
              toggleAllSounds();
            }
            
            // Stop sound from affecting infinity mode multiplier
            // Reset to default values if we accidentally started changing them
            if (currentDifficulty === DIFFICULTY.INFINITY) {
              // Only reset if we're in settings and not actively playing
              if (gameState !== GAME_STATE.PLAYING) {
                infinityModeSpawnMultiplier = 1.0;
              }
            }
          } else if (e.key === "Escape" || e.keyCode === 27) {
            // Return to previous screen (either game or main menu)
            if (previousGameState === GAME_STATE.PAUSE_MENU) {
              // Return to game if we came from pause menu
              gameState = GAME_STATE.PLAYING;
              // Restore gameplay music and volume
              if (musicEnabled) {
                // First check if we need to change the track
                if (currentMusicTrack !== "gameplay") {
                  startGameplayMusic();
                } else {
                  // Just restore volume if track is already correct
                  bgMusic.volume = 0.1;
                }
              }
            } else {
              // Return to main menu if we came from there
              gameState = previousGameState || GAME_STATE.MAIN_MENU;
              // Ensure menu music is playing if returning to main menu
              if (musicEnabled && (previousGameState === GAME_STATE.MAIN_MENU || !previousGameState)) {
                if (currentMusicTrack !== "menu") {
                  startMenuMusic();
                }
              }
            }
          }
        } 
        // How to Play screen
        else if (gameState === GAME_STATE.HOW_TO_PLAY || gameState === GAME_STATE.HIGH_SCORES) {
          if (e.key === "Escape" || e.keyCode === 27 || e.key === "b" || e.code === "KeyB") {
            // Return to previous screen (either game or main menu)
            if (previousGameState === GAME_STATE.PAUSE_MENU) {
              // Return to gameplay if we came from pause menu
              gameState = GAME_STATE.PLAYING;
              // Restore gameplay music and volume
              if (musicEnabled) {
                // First check if we need to change the track
                if (currentMusicTrack !== "gameplay") {
                  startGameplayMusic();
                } else {
                  // Just restore volume if track is already correct
                  bgMusic.volume = 0.1;
                }
              }
            } else {
              // Otherwise return to main menu
              gameState = GAME_STATE.MAIN_MENU;
              // Ensure menu music is playing
              if (musicEnabled && currentMusicTrack !== "menu") {
                startMenuMusic();
              }
            }
          }
        } 
        // Game over or win screens
        else if ((gameState === GAME_STATE.GAME_OVER || gameState === GAME_STATE.WIN) &&
          (e.key === "Enter" || e.code === "Enter" || e.keyCode === 13 || 
           e.key === "Escape" || e.keyCode === 27)) {
          // Stop any sounds before restarting
          victorySound.pause();
          victorySound.currentTime = 0;
          defeatSound.pause();
          defeatSound.currentTime = 0;
          
          restartGame();
          gameState = GAME_STATE.MAIN_MENU;
          startMenuMusic();
        }
        
        keys[e.key] = true;
        e.preventDefault();
      });
      window.addEventListener("keyup", (e) => {
        keys[e.key] = false;
        e.preventDefault();
      });


      let touchStartX = null, touchStartY = null;
      canvas.addEventListener("touchstart", function (e) {
        e.preventDefault();
        let touch = e.touches[0];
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
      }, false);
      canvas.addEventListener("touchmove", function (e) {
        e.preventDefault();
        let touch = e.touches[0];
        let deltaX = touch.clientX - touchStartX;
        let deltaY = touch.clientY - touchStartY;
        if (deltaX > 20) {
          keys["ArrowRight"] = true;
          keys["ArrowLeft"] = false;
        } else if (deltaX < -20) {
          keys["ArrowLeft"] = true;
          keys["ArrowRight"] = false;
        } else {
          keys["ArrowLeft"] = false;
          keys["ArrowRight"] = false;
        }
        if (deltaY < -20) {
          keys["ArrowUp"] = true;
          keys["ArrowDown"] = false;
        } else if (deltaY > 20) {
          keys["ArrowDown"] = true;
          keys["ArrowUp"] = false;
        } else {
          keys["ArrowUp"] = false;
          keys["ArrowDown"] = false;
        }
      }, false);
      canvas.addEventListener("touchend", function (e) {
        e.preventDefault();
        keys["ArrowUp"] = false;
        keys["ArrowDown"] = false;
        keys["ArrowLeft"] = false;
        keys["ArrowRight"] = false;
        touchStartX = null;
        touchStartY = null;
      }, false);

      // Utility
      function randomRange(min, max) {
        return Math.random() * (max - min) + min;
      }
      function randomColor() {


        const hue = Math.floor(Math.random() * 360);
        return "hsl(" + hue + ", 70%, 30%)";
      }
      function bounce(obj, radius, damping = 1) {
        if (obj.x - radius < 0) {
          obj.x = radius;
          obj.vx = -obj.vx * damping;
        }
        if (obj.x + radius > canvas.width) {
          obj.x = canvas.width - radius;
          obj.vx = -obj.vx * damping;
        }
        if (obj.y - radius < 0) {
          obj.y = radius;
          obj.vy = -obj.vy * damping;
        }
        if (obj.y + radius > canvas.height) {
          obj.y = canvas.height - radius;
          obj.vy = -obj.vy * damping;
        }
      }
      function roundRect(ctx, x, y, width, height, radius) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      }

      // 1) Generate Comet Shape with freq/phase:
      function generateCometShape(segments) {
        let shape = [];
        for (let i = 0; i < segments; i++) {
          let angle = i * 2 * Math.PI / segments;
          // Make comets more round by reducing the factor variation (0.6 -> 0.3)
          let factor = 1 + (Math.random() * 0.3 - 0.15);
          // Increase frequency to make them rotate faster (multiply by 2)
          let frequency = (Math.random() * 2 + 1) * 2; // ~2..6
          let phase = Math.random() * 2 * Math.PI;
          shape.push({ angle, factor, frequency, phase });
        }
        return shape;
      }


      function randomRockColor() {
        const colors = [
          "#4B4B4B", // Dark gray
       
        ];
        return colors[Math.floor(Math.random() * colors.length)];
      }



      // 2) Spawn Comet with optional morph
      function spawnComet(tier = MAX_COMET_TIER, x, y, vx, vy) {
        if (x === undefined || y === undefined) {
          let loc = getSpawnLocation();
          x = loc.x;
          y = loc.y;
        }
        if (vx === undefined || vy === undefined) {
          const angle = Math.random() * Math.PI * 2;
          const speed = randomRange(COMET_SPEED_MIN, COMET_SPEED_MAX);
          vx = Math.cos(angle) * speed;
          vy = Math.sin(angle) * speed;
        }
        const radius = BASE_COMET_RADIUS * Math.pow(0.6, MAX_COMET_TIER - tier);
        let hp;
        if (tier === 3) hp = 5;
        else if (tier === 2) hp = 4;
        else hp = 3;

        // Add more segments to make comets rounder (8 -> 12)
        const segments = 12;
        
        const comet = {
          x, y, vx, vy,
          radius,
          tier,
          color: randomRockColor(),
          hitPoints: hp,
          hitEffectTimer: 0,
          slowEffectTimer: 0,
          indestructableTimer: 0,
          oldVX: vx,
          oldVY: vy,
          trail: [],
          trailTimer: 0,
          shape: generateCometShape(segments),
          pattern: generateStonePattern(),
          morph: true,
          // Add rotation speed
          rotationSpeed: randomRange(1, 3)
        };
        comets.push(comet);
      }

      // Additional helper for spawn location
      function getQuadrant(x, y) {
        const midX = canvas.width / 2;
        const midY = canvas.height / 2;
        if (x < midX && y < midY) return "top-left";
        if (x >= midX && y < midY) return "top-right";
        if (x < midX && y >= midY) return "bottom-left";
        return "bottom-right";
      }
      function isInSameQuadrant(x1, y1, x2, y2) {
        return getQuadrant(x1, y1) === getQuadrant(x2, y2);
      }
      function getSpawnLocation() {
        let loc, attempt = 0;
        do {
          if (Math.random() < 0.5) {
            loc = { x: randomRange(0, canvas.width), y: 0 };
          } else {
            loc = { x: randomRange(0, canvas.width), y: canvas.height };
          }
          attempt++;
          if (attempt > 10) break;
        } while (isInSameQuadrant(loc.x, loc.y, spaceship.x, spaceship.y));
        return loc;
      }
      
      // Special function for power-up spawn locations closer to the middle
      function getPowerUpSpawnLocation() {
        // Define central area of the screen (20-80% of width and height)
        const minX = canvas.width * 0.2;
        const maxX = canvas.width * 0.8;
        const minY = canvas.height * 0.2;
        const maxY = canvas.height * 0.8;
        
        // Calculate a random position within this area
        const x = randomRange(minX, maxX);
        const y = randomRange(minY, maxY);
        
        // Make sure it's not too close to the player's ship
        const minDistanceFromShip = SHIP_SIZE * 5; // Keep some distance from ship
        const dx = x - spaceship.x;
        const dy = y - spaceship.y;
        const distanceFromShip = Math.sqrt(dx*dx + dy*dy);
        
        // If too close to ship, try again with a different position
        if (distanceFromShip < minDistanceFromShip) {
          return getPowerUpSpawnLocation(); // Recursively try again
        }
        
        return { x, y };
      }
      
      // Create bullet impact effect when bullets hit comets
      function createBulletImpact(x, y) {
        const count = 8; // Fewer particles than a small explosion
        for (let i = 0; i < count; i++) {
          let angle = Math.random() * Math.PI * 2;
          let speed = randomRange(30, 100); // Lower speed than explosion
          smallExplosionParticles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            lifetime: randomRange(0.1, 0.3), // Shorter lifetime  
            size: randomRange(1, 3), // Smaller particles
            color: randomRange(0, 1) > 0.5 ? "orange" : "yellow" // Mix of colors
          });
        }
      }

      // -------------- PLACEHOLDERS FILLED BELOW -------------- //

      // Explosion Effects
      function createSmallExplosion(x, y) {
        if (soundEnabled) {
          let exp = new Audio(explosionSoundURL);
          exp.volume = 0.125;
          exp.play().catch(err => console.error("Explosion play error:", err));
        }
        const count = 10;
        for (let i = 0; i < count; i++) {
          let angle = Math.random() * Math.PI * 2;
          let speed = randomRange(50, 150);
          smallExplosionParticles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            lifetime: randomRange(0.3, 0.7),
            size: randomRange(2, 4),
            color: "orange"
          });
        }
      }

      function createHugeExplosion(x, y) {
        if (soundEnabled) {
          let exp = new Audio(explosionSoundURL);
          exp.volume = 1.0;
          exp.play().catch(err => console.error("Huge explosion play error:", err));
        }
        const count = 50;
        for (let i = 0; i < count; i++) {
          let angle = Math.random() * Math.PI * 2;
          let speed = randomRange(100, 300);
          smallExplosionParticles.push({
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            lifetime: randomRange(0.8, 1.5),
            size: randomRange(5, 10),
            color: "orange"
          });
        }
      }

      function updateExplosionParticles(dt) {
        for (let i = smallExplosionParticles.length - 1; i >= 0; i--) {
          const p = smallExplosionParticles[i];
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.lifetime -= dt;
          p.size *= 0.98;
          if (p.lifetime <= 0) {
            smallExplosionParticles.splice(i, 1);
          }
        }
      }

      function checkCometCollisions() {
        let indicesToRemove = new Set();
        for (let i = 0; i < comets.length; i++) {
          for (let j = i + 1; j < comets.length; j++) {
            let c1 = comets[i];
            let c2 = comets[j];
            let dx = c2.x - c1.x;
            let dy = c2.y - c1.y;
            let dist = Math.hypot(dx, dy);
            let minDist = c1.radius + c2.radius;
            // Colliding
            if (dist < minDist && dist > 0) {
              // If either is < MAX tier, we remove it
              if (c1.tier < MAX_COMET_TIER) {
                indicesToRemove.add(i);
                createSmallExplosion(c1.x, c1.y);
                score += 5;
              }
              if (c2.tier < MAX_COMET_TIER) {
                indicesToRemove.add(j);
                createSmallExplosion(c2.x, c2.y);
                score += 5;
              }
              // If both are MAX tier, bounce
              if (c1.tier === MAX_COMET_TIER && c2.tier === MAX_COMET_TIER) {
                let nx = dx / dist;
                let ny = dy / dist;
                let dvx = c1.vx - c2.vx;
                let dvy = c1.vy - c2.vy;
                let dot = dvx * nx + dvy * ny;
                if (dot <= 0) {
                  let impulse = dot;
                  c1.vx -= impulse * nx;
                  c1.vy -= impulse * ny;
                  c2.vx += impulse * nx;
                  c2.vy += impulse * ny;
                  let overlap = minDist - dist;
                  c1.x -= nx * overlap / 2;
                  c1.y -= ny * overlap / 2;
                  c2.x += nx * overlap / 2;
                  c2.y += ny * overlap / 2;
                }
              }
            }
          }
        }
        // Remove comets that were marked
        comets = comets.filter((_, index) => !indicesToRemove.has(index));
      }


      function checkBigCometCollisions() {
        // Big Comets vs. Big Comets
        for (let i = 0; i < bigComets.length; i++) {
          for (let j = i + 1; j < bigComets.length; j++) {
            let bc1 = bigComets[i];
            let bc2 = bigComets[j];
            let dx = bc2.x - bc1.x;
            let dy = bc2.y - bc1.y;
            let dist = Math.hypot(dx, dy);
            let minDist = bc1.radius + bc2.radius;
            if (dist < minDist && dist > 0) {
              let nx = dx / dist;
              let ny = dy / dist;
              let overlap = minDist - dist;
              // Bounce them apart equally
              bc1.x -= nx * (overlap / 2);
              bc1.y -= ny * (overlap / 2);
              bc2.x += nx * (overlap / 2);
              bc2.y += ny * (overlap / 2);
              // Adjust velocities (optional, to simulate a bounce)
              let impulse = (bc1.vx - bc2.vx) * nx + (bc1.vy - bc2.vy) * ny;
              if (impulse < 0) {
                bc1.vx -= impulse * nx;
                bc1.vy -= impulse * ny;
                bc2.vx += impulse * nx;
                bc2.vy += impulse * ny;
              }
            }
          }
        }

        // Big Comets vs. Normal Comets
        for (let i = 0; i < bigComets.length; i++) {
          for (let j = 0; j < comets.length; j++) {
            let bc = bigComets[i];
            let c = comets[j];
            let dx = c.x - bc.x;
            let dy = c.y - bc.y;
            let dist = Math.hypot(dx, dy);
            let minDist = bc.radius + c.radius;
            if (dist < minDist && dist > 0) {
              let nx = dx / dist;
              let ny = dy / dist;
              let overlap = minDist - dist;
              // Adjust positions so they bounce apart
              c.x += nx * (overlap / 2);
              c.y += ny * (overlap / 2);
              bc.x -= nx * (overlap / 2);
              bc.y -= ny * (overlap / 2);
              // Bounce the normal comet more strongly (big comets remain mostly unaffected)
              c.vx = -c.vx * 0.5;
              c.vy = -c.vy * 0.5;
            }
          }
        }
      }


      function restartGame() {
        // Go directly to main menu, not difficulty select
        gameState = GAME_STATE.MAIN_MENU;
        startMenuMusic();
        
        // Keep the difficulty selected for next game
        // but reset infinity mode parameters
        infinityModeTime = 0;
        infinityModeSpawnMultiplier = 1.0;
        
        // Reset spaceship
        spaceship.x = canvas.width / 2;
        spaceship.y = canvas.height / 2;
        spaceship.vx = 0;
        spaceship.vy = 0;
        spaceship.angle = 0;
        spaceship.hitPoints = 5;
        spaceship.hitFlashTimer = 0;
        spaceship.tripleShot = false;
        spaceship.tripleShotTimer = 0;
        
        // Clear all game objects
        bullets = [];
        sparks = [];
        comets = [];
        bigComets = [];
        smallExplosionParticles = [];
        
        // Reset timers
        lastBulletTime = 0;
        cometSpawnTimer = 0;
        bigCometSpawnTimer = 0;
        powerUps = [];
        powerUpSpawnTimer = 0;
        tripleShootPowerUpTimer = 0;
        tripleShootPowerUpSpawned = false;
        
        // Score and game state
        // Don't reset score so player can see their previous score
        gameTime = 0;
        winTriggered = false;
        
        // Reset any navigation state
        previousGameState = null;
        
        // Spawn an initial comet for menu background
        spawnComet();
        initStarfield();
      }

      // Spaceship
      function drawSpaceship() {
        ctx.save();
        ctx.translate(spaceship.x, spaceship.y);
        ctx.rotate(spaceship.angle);
        ctx.shadowBlur = 20;
        ctx.shadowColor = "cyan";

        let shipFill = "gray";
        if (spaceship.hitFlashTimer > 0) {
          shipFill = "red";
        } else if (spaceship.hitPoints <= 2) {
          shipFill = (Math.floor(gameTime * 10) % 2 === 0) ? "red" : "gray";
        }

        let shipGrad = ctx.createLinearGradient(spaceship.size, 0, -spaceship.size, 0);
        shipGrad.addColorStop(0, shipFill);
        shipGrad.addColorStop(1, "#111");

        // Body - keeping the original shape
        ctx.beginPath();
        ctx.moveTo(spaceship.size, 0);
        ctx.lineTo(spaceship.size * 0.2, spaceship.size * 0.7);
        ctx.quadraticCurveTo(-spaceship.size * 0.7, spaceship.size * 0.5, -spaceship.size * 0.6, 0);
        ctx.quadraticCurveTo(-spaceship.size * 0.7, -spaceship.size * 0.5, spaceship.size * 0.2, -spaceship.size * 0.7);
        ctx.closePath();
        ctx.fillStyle = shipGrad;
        ctx.fill();
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Add side gun 1 (top)
        ctx.beginPath();
        ctx.moveTo(spaceship.size * 0.5, -spaceship.size * 0.4);
        ctx.lineTo(spaceship.size * 0.9, -spaceship.size * 0.4);
        ctx.lineTo(spaceship.size * 0.9, -spaceship.size * 0.6);
        ctx.lineTo(spaceship.size * 0.5, -spaceship.size * 0.5);
        ctx.closePath();
        ctx.fillStyle = "#555";
        ctx.fill();
        ctx.strokeStyle = "#ccc";
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Add side gun 2 (bottom)
        ctx.beginPath();
        ctx.moveTo(spaceship.size * 0.5, spaceship.size * 0.4);
        ctx.lineTo(spaceship.size * 0.9, spaceship.size * 0.4);
        ctx.lineTo(spaceship.size * 0.9, spaceship.size * 0.6);
        ctx.lineTo(spaceship.size * 0.5, spaceship.size * 0.5);
        ctx.closePath();
        ctx.fillStyle = "#555";
        ctx.fill();
        ctx.strokeStyle = "#ccc";
        ctx.lineWidth = 2;
        ctx.stroke();

        // Flame
        ctx.save();
        ctx.globalAlpha = 0.7;
        let flameLength = spaceship.size * 0.8;
        let flameWidth = spaceship.size * 0.3;
        let flameGrad = ctx.createLinearGradient(-spaceship.size * 0.6, 0, -spaceship.size * 0.6 - flameLength, 0);
        flameGrad.addColorStop(0, "yellow");
        flameGrad.addColorStop(1, "red");
        ctx.fillStyle = flameGrad;
        ctx.beginPath();
        ctx.moveTo(-spaceship.size * 0.6, flameWidth / 2);
        ctx.lineTo(-spaceship.size * 0.6 - flameLength, 0);
        ctx.lineTo(-spaceship.size * 0.6, -flameWidth / 2);
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        // Cockpit
        let cockpitRadius = spaceship.size * 0.3;
        let cockpitGrad = ctx.createRadialGradient(
          spaceship.size * 0.3, 0,
          cockpitRadius * 0.3,
          spaceship.size * 0.3, 0,
          cockpitRadius 
        );
        cockpitGrad.addColorStop(0, "lightblue");
        cockpitGrad.addColorStop(1, "blue");
        ctx.beginPath();
        ctx.arc(spaceship.size * 0.3, 0, cockpitRadius, 0, Math.PI * 2);
        ctx.fillStyle = cockpitGrad;
        ctx.fill();
        ctx.strokeStyle = "white";
        ctx.stroke();

        ctx.restore();
      }

      // 3) Draw normal comets with morph
      function drawNormalComets() {
        for (let c of comets) {
          // Draw comet trail
          if (c.trail && c.trail.length > 0) {
            ctx.save();
            let maxAlpha = 0.1;
            for (let i = 0; i < c.trail.length; i++) {
              let pos = c.trail[i];
              let alpha = ((i + 1) / c.trail.length) * maxAlpha;
              ctx.globalAlpha = alpha;
              ctx.beginPath();
              ctx.arc(pos.x, pos.y, c.radius, 0, 2 * Math.PI);
              ctx.fillStyle = "lightblue";
              ctx.fill();
            }
            ctx.restore();
          }

          // Draw comet body
          ctx.save();
          ctx.globalAlpha = 0.8;
          ctx.beginPath();
          if (c.shape && c.shape.length > 0) {
            // First vertex
            let v0 = c.shape[0];
            let factor0 = v0.factor;
            if (c.morph) {
              // Apply rotation speed if available (for new comets)
              const rotSpeed = c.rotationSpeed || 1;
              factor0 += 0.1 * Math.sin(gameTime * v0.frequency * rotSpeed + v0.phase);
            }
            ctx.moveTo(
              c.x + c.radius * factor0 * Math.cos(v0.angle),
              c.y + c.radius * factor0 * Math.sin(v0.angle)
            );

            // Remaining vertices
            for (let i = 1; i < c.shape.length; i++) {
              let v = c.shape[i];
              let f = v.factor;
              if (c.morph) {
                // Apply rotation speed if available (for new comets)
                const rotSpeed = c.rotationSpeed || 1;
                f += 0.1 * Math.sin(gameTime * v.frequency * rotSpeed + v.phase);
              }
              ctx.lineTo(
                c.x + c.radius * f * Math.cos(v.angle),
                c.y + c.radius * f * Math.sin(v.angle)
              );
            }
            ctx.closePath();
          } else {
            ctx.arc(c.x, c.y, c.radius, 0, 2 * Math.PI);
          }
          ctx.fillStyle = c.pattern;
          ctx.fill();
          // Use the comet's color for its outline, with some opacity
          ctx.strokeStyle = c.color;
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.restore();
        }
      }

      // New rocky pattern for big comets with a darker base color
      function generateRockPattern() {
        let patternCanvas = document.createElement("canvas");
        patternCanvas.width = 50;
        patternCanvas.height = 50;
        let pctx = patternCanvas.getContext("2d");
        // Use a deep, dark brown for the background:
        pctx.fillStyle = "#4a2c2a";
        pctx.fillRect(0, 0, patternCanvas.width, patternCanvas.height);
        // Add random speckles to simulate rock:
        // Reduced number of speckles for a smoother, more uniform look
        for (let i = 0; i < 20; i++) {
          let rx = Math.random() * patternCanvas.width;
          let ry = Math.random() * patternCanvas.height;
          let r = Math.random() * 1.5 + 0.5; // Smaller variations in speckle size
          pctx.fillStyle = "rgba(30,15,15,0.5)"; // More transparent speckles
          pctx.beginPath();
          pctx.arc(rx, ry, r, 0, 2 * Math.PI);
          pctx.fill();
        }
        return pctx.createPattern(patternCanvas, "repeat");
      }


      // Cache the new rock pattern
      const cachedRockPattern = generateRockPattern();

      function spawnBigComet() {
        // Choose starting position that will cross closer to center screen
        // Use either top/bottom or left/right edges
        let x, y, angle;
        
        if (Math.random() < 0.5) {
          // Spawn from left or right edge
          x = Math.random() < 0.5 ? -BASE_COMET_RADIUS * BIG_COMET_SCALE : canvas.width + BASE_COMET_RADIUS * BIG_COMET_SCALE;
          
          // Calculate y to aim toward center-ish area (with some variation)
          const targetY = canvas.height * (0.3 + Math.random() * 0.4); // Target 30-70% of screen height
          y = randomRange(0, canvas.height);
          
          // Calculate angle toward target point near center
          angle = Math.atan2(targetY - y, (canvas.width/2) - x);
        } else {
          // Spawn from top or bottom edge
          y = Math.random() < 0.5 ? -BASE_COMET_RADIUS * BIG_COMET_SCALE : canvas.height + BASE_COMET_RADIUS * BIG_COMET_SCALE;
          
          // Calculate x to aim toward center-ish area (with some variation)
          const targetX = canvas.width * (0.3 + Math.random() * 0.4); // Target 30-70% of screen width
          x = randomRange(0, canvas.width);
          
          // Calculate angle toward target point near center
          angle = Math.atan2((canvas.height/2) - y, targetX - x);
        }
        
        // Slow down big comets for longer screen time
        const speed = randomRange(BIG_COMET_SPEED_MIN * 0.7, BIG_COMET_SPEED_MAX * 0.7);
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;
        let radius = BASE_COMET_RADIUS * BIG_COMET_SCALE;
        
        // Use more segments for a smoother, rounder shape (12 -> 18)
        let shape = generateCometShape(18);
        
        // Make big comets much more round with minimal variation
        shape.forEach(v => {
          // Minimal variation for near-perfect roundness (0.2 -> 0.05)
          v.factor = 1 + (v.factor - 1) * 0.05;
          // Greatly reduce frequency for slower rotation
          v.frequency = v.frequency * 0.3;
        });
        
        let big = {
          x, y, vx, vy,
          radius,
          color: BIG_COMET_COLOR,
          hitPoints: BIG_COMET_HEALTH,
          indestructible: false,
          shape: shape,
          // Generate a unique rock pattern for each comet
          pattern: generateRockPattern(),
          trail: [],
          trailTimer: 0,
          morph: true,
          // Slow rotation for big comets
          rotationSpeed: randomRange(0.3, 0.5),
          // Properties for hit effects
          hitFlashTimer: 0,
          hitCount: 0,
          shakeAmount: 0,
          shakeTimer: 0,
          shakeX: 0,
          shakeY: 0
        };
        bigComets.push(big);
      }



      // Function to draw the distant pulsar
      function drawPulsar(ctx) {
        if (!pulsarActive) return;
        
        // Update pulsar animation
        pulsarTime += 0.016; // Approx 60fps
        const pulseScale = 0.5 + Math.sin(pulsarTime * 2) * 0.3;
        const pulseAlpha = 0.2 + Math.sin(pulsarTime * 3) * 0.1;
        
        // Draw pulsar with pulsing effect
        ctx.save();
        
        // Outer glow
        const outerRadius = pulsarRadius * (1.5 + pulseScale);
        const gradient = ctx.createRadialGradient(
          pulsarX, pulsarY, pulsarRadius * 0.2,
          pulsarX, pulsarY, outerRadius
        );
        
        gradient.addColorStop(0, pulsarColor + (pulseAlpha + 0.1) + ')');
        gradient.addColorStop(0.4, pulsarColor + (pulseAlpha * 0.6) + ')');
        gradient.addColorStop(1, pulsarColor + '0)');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(pulsarX, pulsarY, outerRadius, 0, Math.PI * 2);
        ctx.fill();
        
        // Core
        ctx.beginPath();
        ctx.arc(pulsarX, pulsarY, pulsarRadius * pulseScale, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(200, 240, 255, ' + (pulseAlpha + 0.3) + ')';
        ctx.shadowBlur = 15;
        ctx.shadowColor = 'rgba(100, 200, 255, 0.8)';
        ctx.fill();
        
        // Light rays (occasionally)
        if (Math.sin(pulsarTime * 1.5) > 0.7) {
          const numRays = 4;
          const rayLength = pulsarRadius * 4 * pulseScale;
          
          ctx.strokeStyle = 'rgba(180, 230, 255, ' + (pulseAlpha * 0.4) + ')';
          ctx.lineWidth = 1;
          
          for (let i = 0; i < numRays; i++) {
            const angle = (i / numRays) * Math.PI * 2;
            ctx.beginPath();
            ctx.moveTo(pulsarX, pulsarY);
            ctx.lineTo(
              pulsarX + Math.cos(angle) * rayLength,
              pulsarY + Math.sin(angle) * rayLength
            );
            ctx.stroke();
          }
        }
        
        ctx.restore();
      }
      
      function drawBigComets(ctx) {
        for (let bc of bigComets) {
          ctx.save();
          ctx.globalAlpha = 1.0;
          
          // Create a simple pattern for the comet
          // We'll create it once and cache it with the comet
          if (!bc.simplePattern) {
            const patternSize = 100;
            const patternCanvas = document.createElement('canvas');
            patternCanvas.width = patternSize;
            patternCanvas.height = patternSize;
            const patternCtx = patternCanvas.getContext('2d');
            
            // Fill with base color
            patternCtx.fillStyle = "#704020";
            patternCtx.fillRect(0, 0, patternSize, patternSize);
            
            // Create a simple grid pattern
            patternCtx.strokeStyle = "#603010";
            patternCtx.lineWidth = 1;
            
            // Draw horizontal lines
            const lineSpacing = 10;
            for (let y = 0; y < patternSize; y += lineSpacing) {
              patternCtx.beginPath();
              patternCtx.moveTo(0, y);
              patternCtx.lineTo(patternSize, y);
              patternCtx.stroke();
            }
            
            // Draw vertical lines
            for (let x = 0; x < patternSize; x += lineSpacing) {
              patternCtx.beginPath();
              patternCtx.moveTo(x, 0);
              patternCtx.lineTo(x, patternSize);
              patternCtx.stroke();
            }
            
            // Add some random darker spots
            for (let i = 0; i < 30; i++) {
              const spotX = Math.random() * patternSize;
              const spotY = Math.random() * patternSize;
              const spotRadius = 2 + Math.random() * 5;
              
              patternCtx.fillStyle = 'rgba(40, 20, 10, 0.5)';
              patternCtx.beginPath();
              patternCtx.arc(spotX, spotY, spotRadius, 0, Math.PI * 2);
              patternCtx.fill();
            }
            
            // Add a few lighter spots
            for (let i = 0; i < 20; i++) {
              const spotX = Math.random() * patternSize;
              const spotY = Math.random() * patternSize;
              const spotRadius = 1 + Math.random() * 3;
              
              patternCtx.fillStyle = 'rgba(150, 100, 50, 0.5)';
              patternCtx.beginPath();
              patternCtx.arc(spotX, spotY, spotRadius, 0, Math.PI * 2);
              patternCtx.fill();
            }
            
            // Store the pattern with the comet
            bc.simplePattern = ctx.createPattern(patternCanvas, 'repeat');
          }
          
          // Apply shake effect if active
          const drawX = bc.x + (bc.shakeX || 0);
          const drawY = bc.y + (bc.shakeY || 0);
          
          // Draw comet outline with potential hit flash
          ctx.beginPath();
          if (bc.shape && bc.shape.length > 0) {
            let v0 = bc.shape[0];
            let factor0 = v0.factor;
            if (bc.morph) {
              // Apply rotation speed to big comets too
              const rotSpeed = bc.rotationSpeed || 1.5;
              factor0 += 0.1 * Math.sin(gameTime * v0.frequency * rotSpeed + v0.phase);
            }
            ctx.moveTo(
              drawX + bc.radius * factor0 * Math.cos(v0.angle),
              drawY + bc.radius * factor0 * Math.sin(v0.angle)
            );
            for (let i = 1; i < bc.shape.length; i++) {
              let v = bc.shape[i];
              let f = v.factor;
              if (bc.morph) {
                // Apply rotation speed to big comets too
                const rotSpeed = bc.rotationSpeed || 1.5;
                f += 0.1 * Math.sin(gameTime * v.frequency * rotSpeed + v.phase);
              }
              ctx.lineTo(
                drawX + bc.radius * f * Math.cos(v.angle),
                drawY + bc.radius * f * Math.sin(v.angle)
              );
            }
            ctx.closePath();
          } else {
            ctx.arc(drawX, drawY, bc.radius, 0, Math.PI * 2);
          }
          
          // Add hit flash effect
          if (bc.hitFlashTimer > 0) {
            // White flash overlay
            ctx.fillStyle = `rgba(255, 255, 255, ${bc.hitFlashTimer * 5})`;
            ctx.fill();
          }
          
          // Apply the pattern with rotation
          ctx.save();
          
          // Create a transform matrix for the pattern
          ctx.translate(drawX, drawY);
          // Very slow pattern rotation - faster when damaged
          const rotationSpeed = 0.01 * (1 + (bc.hitCount / BIG_COMET_HEALTH));
          ctx.rotate(gameTime * rotationSpeed); 
          ctx.translate(-drawX, -drawY);
          
          // Fill with pattern
          ctx.fillStyle = bc.simplePattern;
          ctx.fill();
          
          ctx.restore();
          
          // Add a subtle 3D effect with gradient overlay
          ctx.globalCompositeOperation = 'overlay';
          const gradient = ctx.createRadialGradient(
            drawX - bc.radius * 0.3, drawY - bc.radius * 0.3, 0,
            drawX, drawY, bc.radius
          );
          
          // Change gradient colors based on damage - more gradual with higher health
          const damageRatio = bc.hitCount / BIG_COMET_HEALTH;
          
          // Create a more dynamic gradient for the higher health
          if (damageRatio > 0.9) {
            // Critically damaged - bright red glow
            gradient.addColorStop(0, 'rgba(255, 100, 50, 0.4)');
            gradient.addColorStop(0.7, 'rgba(220, 30, 30, 0.25)');
            gradient.addColorStop(1, 'rgba(120, 0, 0, 0.3)');
          } else if (damageRatio > 0.7) {
            // Severely damaged - red
            gradient.addColorStop(0, 'rgba(255, 150, 100, 0.3)');
            gradient.addColorStop(0.7, 'rgba(200, 50, 50, 0.2)');
            gradient.addColorStop(1, 'rgba(100, 0, 0, 0.3)');
          } else if (damageRatio > 0.4) {
            // Moderately damaged - orange tint
            gradient.addColorStop(0, 'rgba(255, 200, 100, 0.25)');
            gradient.addColorStop(0.7, 'rgba(150, 100, 50, 0.15)');
            gradient.addColorStop(1, 'rgba(100, 50, 0, 0.3)');
          } else if (damageRatio > 0.1) {
            // Slightly damaged - yellowish
            gradient.addColorStop(0, 'rgba(255, 240, 150, 0.2)');
            gradient.addColorStop(0.7, 'rgba(150, 140, 80, 0.15)');
            gradient.addColorStop(1, 'rgba(80, 70, 20, 0.3)');
          } else {
            // Normal
            gradient.addColorStop(0, 'rgba(255, 255, 255, 0.2)');
            gradient.addColorStop(0.7, 'rgba(100, 100, 100, 0.1)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
          }
          
          // Use the same path that's already defined (no new circle)
          ctx.fillStyle = gradient;
          ctx.fill();
          
          // Display health indicator when damaged
          if (bc.hitCount > 0) {
            const healthBarWidth = bc.radius * 1.5;
            const healthBarHeight = bc.radius * 0.15;
            const healthPercent = bc.hitPoints / BIG_COMET_HEALTH; // Show percentage of total health
            
            ctx.globalCompositeOperation = 'source-over';
            
            // Draw health bar background
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(
              drawX - healthBarWidth/2,
              drawY - bc.radius - 20,
              healthBarWidth,
              healthBarHeight
            );
            
            // Draw health bar
            ctx.fillStyle = 'rgba(255, 50, 50, 0.8)';
            ctx.fillRect(
              drawX - healthBarWidth/2,
              drawY - bc.radius - 20,
              healthBarWidth * healthPercent,
              healthBarHeight
            );
          }
          
          // Reset composite operation
          ctx.globalCompositeOperation = 'source-over';
          
          ctx.restore();
        }
      }


      // Main Draw
      // Initialize pulsar position
      function initPulsar() {
        // Position near the top-left or bottom-left corner
        pulsarX = Math.random() * canvas.width * 0.2 + 60;
        pulsarY = Math.random() < 0.5 ? 
                 Math.random() * canvas.height * 0.2 + 60 : 
                 canvas.height - (Math.random() * canvas.height * 0.2 + 60);
        
        // Random variations in appearance
        pulsarRadius = Math.random() * 10 + 20;
        pulsarColor = Math.random() < 0.3 ? 
                     'rgba(220, 150, 70, ' :  // Orange pulsar
                     'rgba(100, 200, 255, ';  // Blue pulsar
      }
      
      // Call initialization on startup
      initPulsar();
      
      // Draw the Main Menu
      function drawMainMenu() {
        // Game Title
        ctx.fillStyle = "white";
        ctx.font = "48px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Splitting Comets", canvas.width / 2, canvas.height / 4);
        
        // Menu options
        const menuY = canvas.height / 2 - 40;
        const menuSpacing = 50;
        const buttonWidth = 200;
        const buttonHeight = 40;
        
        const menuOptions = [
          { text: "Play Game" },
          { text: "Settings" },
          { text: "How to Play" },
          { text: "Scoreboard" }
        ];
        
        for (let i = 0; i < menuOptions.length; i++) {
          const option = menuOptions[i];
          const y = menuY + i * menuSpacing;
          
          // Button background - semi-transparent with rounded corners
          const cornerRadius = 8;
          
          // Create button path with rounded corners
          ctx.beginPath();
          ctx.moveTo(canvas.width/2 - buttonWidth/2 + cornerRadius, y);
          ctx.lineTo(canvas.width/2 + buttonWidth/2 - cornerRadius, y);
          ctx.quadraticCurveTo(canvas.width/2 + buttonWidth/2, y, canvas.width/2 + buttonWidth/2, y + cornerRadius);
          ctx.lineTo(canvas.width/2 + buttonWidth/2, y + buttonHeight - cornerRadius);
          ctx.quadraticCurveTo(canvas.width/2 + buttonWidth/2, y + buttonHeight, canvas.width/2 + buttonWidth/2 - cornerRadius, y + buttonHeight);
          ctx.lineTo(canvas.width/2 - buttonWidth/2 + cornerRadius, y + buttonHeight);
          ctx.quadraticCurveTo(canvas.width/2 - buttonWidth/2, y + buttonHeight, canvas.width/2 - buttonWidth/2, y + buttonHeight - cornerRadius);
          ctx.lineTo(canvas.width/2 - buttonWidth/2, y + cornerRadius);
          ctx.quadraticCurveTo(canvas.width/2 - buttonWidth/2, y, canvas.width/2 - buttonWidth/2 + cornerRadius, y);
          ctx.closePath();
          
          // Fill with different colors based on selection
          if (i === selectedMainMenuItem) {
            // Selected button - light blue with glow
            // No global shadow blur that affects the entire canvas
            ctx.fillStyle = "rgba(52, 152, 219, 0.7)";
            
            // Draw a focused glow just for this button instead of using shadowBlur
            const glowSize = 5;
            ctx.save();
            
            // Draw multiple expanding shapes with decreasing opacity for glow effect
            for (let g = 0; g < 3; g++) {
              const expandSize = g * 2;
              const opacity = 0.2 - (g * 0.06);
              
              ctx.fillStyle = `rgba(52, 152, 219, ${opacity})`;
              ctx.beginPath();
              ctx.moveTo(canvas.width/2 - buttonWidth/2 - expandSize + cornerRadius, y - expandSize);
              ctx.lineTo(canvas.width/2 + buttonWidth/2 + expandSize - cornerRadius, y - expandSize);
              ctx.quadraticCurveTo(canvas.width/2 + buttonWidth/2 + expandSize, y - expandSize, canvas.width/2 + buttonWidth/2 + expandSize, y - expandSize + cornerRadius);
              ctx.lineTo(canvas.width/2 + buttonWidth/2 + expandSize, y + buttonHeight + expandSize - cornerRadius);
              ctx.quadraticCurveTo(canvas.width/2 + buttonWidth/2 + expandSize, y + buttonHeight + expandSize, canvas.width/2 + buttonWidth/2 + expandSize - cornerRadius, y + buttonHeight + expandSize);
              ctx.lineTo(canvas.width/2 - buttonWidth/2 - expandSize + cornerRadius, y + buttonHeight + expandSize);
              ctx.quadraticCurveTo(canvas.width/2 - buttonWidth/2 - expandSize, y + buttonHeight + expandSize, canvas.width/2 - buttonWidth/2 - expandSize, y + buttonHeight + expandSize - cornerRadius);
              ctx.lineTo(canvas.width/2 - buttonWidth/2 - expandSize, y - expandSize + cornerRadius);
              ctx.quadraticCurveTo(canvas.width/2 - buttonWidth/2 - expandSize, y - expandSize, canvas.width/2 - buttonWidth/2 - expandSize + cornerRadius, y - expandSize);
              ctx.closePath();
              ctx.fill();
            }
            
            ctx.restore();
            
            // Main button fill
            ctx.fillStyle = "rgba(52, 152, 219, 0.7)";
          } else {
            // Unselected button - dark gray, semi-transparent
            ctx.fillStyle = "rgba(40, 40, 40, 0.8)";
          }
          
          ctx.fill();
          
          // Button border
          ctx.strokeStyle = "rgba(150, 150, 150, 0.5)";
          ctx.lineWidth = 1;
          ctx.stroke();
          
          // Button text
          ctx.fillStyle = "white";
          ctx.font = "24px sans-serif";
          ctx.fillText(option.text, canvas.width/2, y + 28);
        }
        
        // Show previous score if any
        if (score > 0) {
          ctx.fillStyle = "#FFD700"; // Gold color
          ctx.font = "20px sans-serif";
          ctx.fillText(`Previous Score: ${score}`, canvas.width / 2, canvas.height - 60);
        }
        
        // Instructions with subtle backdrop at bottom
        const instructY = canvas.height - 70;
        const instructHeight = 60;
        
        // Draw semi-transparent backdrop for instructions
        ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
        ctx.fillRect(0, instructY, canvas.width, instructHeight);
        
        // Navigation instructions
        ctx.fillStyle = "rgba(200, 200, 220, 0.9)";
        ctx.font = "16px sans-serif";
        ctx.fillText("â†‘/â†“: Navigate menu   ENTER: Select", canvas.width / 2, instructY + 20);
        
        // Show sound status
        const musicStatus = musicEnabled ? "ON" : "OFF";
        const soundFxStatus = soundEnabled ? "ON" : "OFF";
        ctx.fillText(`Music: ${musicStatus}   Sound FX: ${soundFxStatus}`, canvas.width / 2, instructY + 45);
        
        // Draw music icon
        drawMusicIcon();
      }
      
      // Draw the Difficulty Selection screen
      function drawDifficultySelect() {
        ctx.fillStyle = "white";
        ctx.font = "36px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Select Difficulty", canvas.width / 2, canvas.height / 4);
        
        const diffY = canvas.height / 2 - 80;
        const diffSpacing = 70;
        const buttonWidth = 250;
        const buttonHeight = 50;
        
        const difficulties = [
          { 
            name: "Easy", 
            desc: "For beginners - the calm before the storm", 
            value: DIFFICULTY.EASY 
          },
          { 
            name: "Medium", 
            desc: "The classic challenge - cosmic chaos awaits", 
            value: DIFFICULTY.MEDIUM 
          },
          { 
            name: "Hard", 
            desc: "For veterans - an asteroid hell", 
            value: DIFFICULTY.HARD 
          },
          { 
            name: "Infinity", 
            desc: "Endless void - how long can you survive?", 
            value: DIFFICULTY.INFINITY 
          }
        ];
        
        for (let i = 0; i < difficulties.length; i++) {
          const diff = difficulties[i];
          const y = diffY + i * diffSpacing;
          
          // Button background - semi-transparent with rounded corners
          const cornerRadius = 8;
          
          // Create button path with rounded corners
          ctx.beginPath();
          ctx.moveTo(canvas.width/2 - buttonWidth/2 + cornerRadius, y);
          ctx.lineTo(canvas.width/2 + buttonWidth/2 - cornerRadius, y);
          ctx.quadraticCurveTo(canvas.width/2 + buttonWidth/2, y, canvas.width/2 + buttonWidth/2, y + cornerRadius);
          ctx.lineTo(canvas.width/2 + buttonWidth/2, y + buttonHeight - cornerRadius);
          ctx.quadraticCurveTo(canvas.width/2 + buttonWidth/2, y + buttonHeight, canvas.width/2 + buttonWidth/2 - cornerRadius, y + buttonHeight);
          ctx.lineTo(canvas.width/2 - buttonWidth/2 + cornerRadius, y + buttonHeight);
          ctx.quadraticCurveTo(canvas.width/2 - buttonWidth/2, y + buttonHeight, canvas.width/2 - buttonWidth/2, y + buttonHeight - cornerRadius);
          ctx.lineTo(canvas.width/2 - buttonWidth/2, y + cornerRadius);
          ctx.quadraticCurveTo(canvas.width/2 - buttonWidth/2, y, canvas.width/2 - buttonWidth/2 + cornerRadius, y);
          ctx.closePath();
          
          // Fill with different colors based on selection
          if (i === selectedDifficultyItem) {
            // Selected button - light blue with glow
            ctx.shadowBlur = 10;
            ctx.shadowColor = "rgba(52, 152, 219, 0.7)";
            ctx.fillStyle = "rgba(52, 152, 219, 0.7)";
          } else {
            // Unselected button - dark gray, semi-transparent
            ctx.shadowBlur = 0;
            ctx.fillStyle = "rgba(40, 40, 40, 0.8)";
          }
          
          ctx.fill();
          
          // Button border
          ctx.strokeStyle = "rgba(150, 150, 150, 0.5)";
          ctx.lineWidth = 1;
          ctx.stroke();
          
          // Button text
          ctx.fillStyle = "white";
          ctx.font = "24px sans-serif";
          ctx.fillText(diff.name, canvas.width/2, y + 30);
          
          // Description text - slightly smaller and more ethereal
          ctx.fillStyle = "rgba(200, 200, 220, 0.8)";
          ctx.font = "italic 14px sans-serif";
          ctx.fillText(diff.desc, canvas.width/2, y + diffSpacing - 15);
        }
        
        // Instructions with subtle backdrop
        const instructY = diffY + difficulties.length * diffSpacing + 30;
        const instructHeight = 60;
        
        // Draw semi-transparent backdrop for instructions
        ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
        ctx.fillRect(canvas.width/2 - 200, instructY - 15, 400, instructHeight);
        
        // Instruction text
        ctx.fillStyle = "rgba(200, 200, 220, 0.9)";
        ctx.font = "18px sans-serif";
        ctx.fillText("â†‘/â†“: Select difficulty   ENTER: Start game", canvas.width / 2, instructY + 10);
        ctx.fillText("ESC: Return to main menu", canvas.width / 2, instructY + 40);
      }
      
      // Draw the Pause Menu
      function drawPauseMenu() {
        // Add semi-transparent overlay on the game
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw game elements with reduced opacity to show game is paused
        ctx.globalAlpha = 0.3;
        
        // Draw the ship in its current position
        drawSpaceship();
        
        // Reset opacity
        ctx.globalAlpha = 1.0;
        
        // Draw pause menu title
        ctx.fillStyle = "white";
        ctx.font = "42px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("GAME PAUSED", canvas.width / 2, canvas.height / 4);
        
        // Display current game status
        let difficultyName = "";
        switch(currentDifficulty) {
          case DIFFICULTY.EASY: difficultyName = "Easy"; break;
          case DIFFICULTY.MEDIUM: difficultyName = "Medium"; break;
          case DIFFICULTY.HARD: difficultyName = "Hard"; break;
          case DIFFICULTY.INFINITY: difficultyName = "Infinity"; break;
        }
        
        ctx.font = "18px sans-serif";
        ctx.fillStyle = "rgba(200, 200, 220, 0.9)";
        ctx.fillText(`Difficulty: ${difficultyName}   Score: ${score}`, canvas.width / 2, canvas.height / 4 + 40);
        
        // Show health status
        ctx.fillText(`Ship Health: ${spaceship.hitPoints}/5`, canvas.width / 2, canvas.height / 4 + 70);
        
        // Draw menu options
        const menuY = canvas.height / 2 - 20;
        const menuSpacing = 60;
        const buttonWidth = 220;
        const buttonHeight = 45;
        
        const menuOptions = [
          { text: "Resume Game", desc: "Return to the battle" },
          { text: "Settings", desc: "Adjust music and sound effects" },
          { text: "How to Play", desc: "Review game controls and objectives" },
          { text: "Exit to Main Menu", desc: "Your progress will be lost" }
        ];
        
        for (let i = 0; i < menuOptions.length; i++) {
          const option = menuOptions[i];
          const y = menuY + i * menuSpacing;
          
          // Button background - semi-transparent with rounded corners
          const cornerRadius = 8;
          
          // Create button path with rounded corners
          ctx.beginPath();
          ctx.moveTo(canvas.width/2 - buttonWidth/2 + cornerRadius, y);
          ctx.lineTo(canvas.width/2 + buttonWidth/2 - cornerRadius, y);
          ctx.quadraticCurveTo(canvas.width/2 + buttonWidth/2, y, canvas.width/2 + buttonWidth/2, y + cornerRadius);
          ctx.lineTo(canvas.width/2 + buttonWidth/2, y + buttonHeight - cornerRadius);
          ctx.quadraticCurveTo(canvas.width/2 + buttonWidth/2, y + buttonHeight, canvas.width/2 + buttonWidth/2 - cornerRadius, y + buttonHeight);
          ctx.lineTo(canvas.width/2 - buttonWidth/2 + cornerRadius, y + buttonHeight);
          ctx.quadraticCurveTo(canvas.width/2 - buttonWidth/2, y + buttonHeight, canvas.width/2 - buttonWidth/2, y + buttonHeight - cornerRadius);
          ctx.lineTo(canvas.width/2 - buttonWidth/2, y + cornerRadius);
          ctx.quadraticCurveTo(canvas.width/2 - buttonWidth/2, y, canvas.width/2 - buttonWidth/2 + cornerRadius, y);
          ctx.closePath();
          
          // Different styles for the "Exit" option to make it stand out as potentially dangerous
          if (i === 3) { // Exit option
            if (i === selectedPauseMenuItem) {
              // Selected exit button - more transparent red with glow
              ctx.shadowBlur = 10;
              ctx.shadowColor = "rgba(231, 76, 60, 0.4)";
              ctx.fillStyle = "rgba(231, 76, 60, 0.3)";
            } else {
              // Unselected exit button - darker red
              ctx.shadowBlur = 0;
              ctx.fillStyle = "rgba(160, 40, 30, 0.8)";
            }
          } else {
            // Normal menu options
            if (i === selectedPauseMenuItem) {
              // Selected button - more transparent blue with subtle glow
              ctx.shadowBlur = 10;
              ctx.shadowColor = "rgba(52, 152, 219, 0.4)";
              ctx.fillStyle = "rgba(52, 152, 219, 0.3)"; // More transparent
            } else {
              // Unselected button - dark gray, semi-transparent
              ctx.shadowBlur = 0;
              ctx.fillStyle = "rgba(40, 40, 40, 0.8)";
            }
          }
          
          ctx.fill();
          
          // Button border
          ctx.strokeStyle = "rgba(150, 150, 150, 0.5)";
          ctx.lineWidth = 1;
          ctx.stroke();
          
          // Button text
          ctx.fillStyle = "white";
          ctx.font = "22px sans-serif";
          ctx.fillText(option.text, canvas.width/2, y + 28);
          
          // Description text
          ctx.fillStyle = "rgba(200, 200, 220, 0.8)";
          ctx.font = "italic 14px sans-serif";
          ctx.fillText(option.desc, canvas.width/2, y + menuSpacing - 15);
        }
        
        // Instructions with subtle backdrop
        const instructY = canvas.height - 70;
        const instructHeight = 50;
        
        // Draw semi-transparent backdrop for instructions
        ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
        ctx.fillRect(0, instructY, canvas.width, instructHeight);
        
        // Instruction text
        ctx.fillStyle = "rgba(200, 200, 220, 0.9)";
        ctx.font = "18px sans-serif";
        ctx.fillText("â†‘/â†“: Navigate menu   ENTER: Select   ESC: Resume game", canvas.width / 2, instructY + 30);
      }
      
      // Draw the Settings screen
      function drawSettings() {
        ctx.fillStyle = "white";
        ctx.font = "36px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Settings", canvas.width / 2, canvas.height / 4);
        
        const settingsY = canvas.height / 2 - 40;
        const settingsSpacing = 60;
        const buttonWidth = 250;
        const buttonHeight = 40;
        
        const settings = [
          { 
            text: "Music", 
            status: musicEnabled ? "ON" : "OFF" 
          },
          { 
            text: "Sound Effects", 
            status: soundEnabled ? "ON" : "OFF" 
          }
        ];
        
        for (let i = 0; i < settings.length; i++) {
          const setting = settings[i];
          const y = settingsY + i * settingsSpacing;
          
          // Button background - semi-transparent with rounded corners
          const cornerRadius = 8;
          
          // Create button path with rounded corners
          ctx.beginPath();
          ctx.moveTo(canvas.width/2 - buttonWidth/2 + cornerRadius, y);
          ctx.lineTo(canvas.width/2 + buttonWidth/2 - cornerRadius, y);
          ctx.quadraticCurveTo(canvas.width/2 + buttonWidth/2, y, canvas.width/2 + buttonWidth/2, y + cornerRadius);
          ctx.lineTo(canvas.width/2 + buttonWidth/2, y + buttonHeight - cornerRadius);
          ctx.quadraticCurveTo(canvas.width/2 + buttonWidth/2, y + buttonHeight, canvas.width/2 + buttonWidth/2 - cornerRadius, y + buttonHeight);
          ctx.lineTo(canvas.width/2 - buttonWidth/2 + cornerRadius, y + buttonHeight);
          ctx.quadraticCurveTo(canvas.width/2 - buttonWidth/2, y + buttonHeight, canvas.width/2 - buttonWidth/2, y + buttonHeight - cornerRadius);
          ctx.lineTo(canvas.width/2 - buttonWidth/2, y + cornerRadius);
          ctx.quadraticCurveTo(canvas.width/2 - buttonWidth/2, y, canvas.width/2 - buttonWidth/2 + cornerRadius, y);
          ctx.closePath();
          
          // Fill with different colors based on selection
          if (i === selectedSettingsItem) {
            // Selected button - light blue with glow (matching main menu)
            // No global shadow blur that affects the entire canvas
            
            // Draw a focused glow just for this button instead of using shadowBlur
            const glowSize = 5;
            ctx.save();
            
            // Draw multiple expanding shapes with decreasing opacity for glow effect
            for (let g = 0; g < 3; g++) {
              const expandSize = g * 2;
              const opacity = 0.2 - (g * 0.06);
              
              ctx.fillStyle = `rgba(52, 152, 219, ${opacity})`;
              ctx.beginPath();
              ctx.moveTo(canvas.width/2 - buttonWidth/2 - expandSize + cornerRadius, y - expandSize);
              ctx.lineTo(canvas.width/2 + buttonWidth/2 + expandSize - cornerRadius, y - expandSize);
              ctx.quadraticCurveTo(canvas.width/2 + buttonWidth/2 + expandSize, y - expandSize, canvas.width/2 + buttonWidth/2 + expandSize, y - expandSize + cornerRadius);
              ctx.lineTo(canvas.width/2 + buttonWidth/2 + expandSize, y + buttonHeight + expandSize - cornerRadius);
              ctx.quadraticCurveTo(canvas.width/2 + buttonWidth/2 + expandSize, y + buttonHeight + expandSize, canvas.width/2 + buttonWidth/2 + expandSize - cornerRadius, y + buttonHeight + expandSize);
              ctx.lineTo(canvas.width/2 - buttonWidth/2 - expandSize + cornerRadius, y + buttonHeight + expandSize);
              ctx.quadraticCurveTo(canvas.width/2 - buttonWidth/2 - expandSize, y + buttonHeight + expandSize, canvas.width/2 - buttonWidth/2 - expandSize, y + buttonHeight + expandSize - cornerRadius);
              ctx.lineTo(canvas.width/2 - buttonWidth/2 - expandSize, y - expandSize + cornerRadius);
              ctx.quadraticCurveTo(canvas.width/2 - buttonWidth/2 - expandSize, y - expandSize, canvas.width/2 - buttonWidth/2 - expandSize + cornerRadius, y - expandSize);
              ctx.closePath();
              ctx.fill();
            }
            
            ctx.restore();
            
            // Main button fill
            ctx.fillStyle = "rgba(52, 152, 219, 0.7)";
          } else {
            // Unselected button - dark gray, semi-transparent
            ctx.fillStyle = "rgba(40, 40, 40, 0.8)";
          }
          
          ctx.fill();
          
          // Button border
          ctx.strokeStyle = "rgba(150, 150, 150, 0.5)";
          ctx.lineWidth = 1;
          ctx.stroke();
          
          // Button text
          ctx.fillStyle = "white";
          ctx.font = "20px sans-serif";
          ctx.fillText(setting.text, canvas.width/2 - 50, y + 25);
          
          // Status indicator (ON/OFF) - with pill-shaped background
          const statusWidth = 60;
          const statusHeight = 26;
          const statusX = canvas.width/2 + 60;
          const statusY = y + 25 - statusHeight/2;
          
          // Draw pill background
          ctx.beginPath();
          ctx.moveTo(statusX + statusHeight/2, statusY);
          ctx.lineTo(statusX + statusWidth - statusHeight/2, statusY);
          ctx.arc(statusX + statusWidth - statusHeight/2, statusY + statusHeight/2, statusHeight/2, -Math.PI/2, Math.PI/2);
          ctx.lineTo(statusX + statusHeight/2, statusY + statusHeight);
          ctx.arc(statusX + statusHeight/2, statusY + statusHeight/2, statusHeight/2, Math.PI/2, -Math.PI/2);
          ctx.closePath();
          
          // Different color for ON/OFF - using the same blue as the main theme
          ctx.fillStyle = setting.status === "ON" ? 
                         "rgba(52, 152, 219, 0.7)" : // Blue for ON (matching other buttons)
                         "rgba(149, 165, 166, 0.5)"; // Gray for OFF
          ctx.fill();
          
          // Status text
          ctx.fillStyle = "white";
          ctx.font = "bold 16px sans-serif";
          ctx.textAlign = "center";
          ctx.fillText(setting.status, statusX + statusWidth/2, y + 25);
          ctx.textAlign = "center"; // Reset text alignment
        }
        
        // Instructions with subtle backdrop
        const instructY = settingsY + settings.length * settingsSpacing + 30;
        const instructHeight = 60;
        
        // Draw semi-transparent backdrop for instructions
        ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
        ctx.fillRect(canvas.width/2 - 200, instructY - 15, 400, instructHeight);
        
        // Instruction text
        ctx.fillStyle = "rgba(200, 200, 220, 0.9)";
        ctx.font = "18px sans-serif";
        ctx.fillText("â†‘/â†“: Select option   ENTER: Toggle setting", canvas.width / 2, instructY + 10);
        ctx.fillText("ESC: Return to main menu", canvas.width / 2, instructY + 40);
      }
      
      // Draw the How to Play screen
      function drawHowToPlay() {
        ctx.fillStyle = "white";
        ctx.font = "36px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("How to Play", canvas.width / 2, canvas.height / 6);
        
        const instructionsY = canvas.height / 4;
        const lineHeight = 30;
        
        // Game instructions
        ctx.font = "18px sans-serif";
        ctx.textAlign = "left";
        const instructions = [
          "Controls:",
          "â€¢ Arrow Keys: Move your spaceship",
          "â€¢ Space: Quick brake",
          "",
          "Objectives:",
          "â€¢ Destroy comets by shooting them",
          "â€¢ Avoid collisions with comets",
          "â€¢ Collect power-ups to enhance your ship",
          "",
          "Power-ups:",
          "â€¢ Red (HP): Restores health",
          "â€¢ Blue (3X): Triple shot - fires 3x bullets",
          "  (Triple shot power-ups appear before big comets)",
          "",
          "Enemy Types:",
          "â€¢ Regular Comets: Break into smaller pieces",
          "â€¢ Big Comets: Require multiple hits to destroy"
        ];
        
        ctx.fillStyle = "#CCC";
        for (let i = 0; i < instructions.length; i++) {
          const line = instructions[i];
          const x = canvas.width / 2 - 200;
          const y = instructionsY + i * lineHeight;
          
          if (line === "") continue; // Skip empty lines
          
          if (line.endsWith(":")) {
            // Section headers
            ctx.fillStyle = "#FFD700"; // Gold
            ctx.font = "bold 20px sans-serif";
          } else {
            // Regular instructions
            ctx.fillStyle = "#CCC";
            ctx.font = "18px sans-serif";
          }
          
          ctx.fillText(line, x, y);
        }
        
        // Instructions with subtle backdrop at bottom
        const instructY = canvas.height - 70;
        const instructHeight = 50;
        
        // Draw semi-transparent backdrop for instructions
        ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
        ctx.fillRect(0, instructY, canvas.width, instructHeight);
        
        // Return instruction
        ctx.fillStyle = "rgba(200, 200, 220, 0.9)";
        ctx.textAlign = "center";
        ctx.font = "18px sans-serif";
        ctx.fillText("ESC: Return to main menu", canvas.width / 2, instructY + 30);
      }
      
      // Draw the Scoreboard screen (placeholder)
      function drawHighScores() {
        ctx.fillStyle = "white";
        ctx.font = "36px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Scoreboard", canvas.width / 2, canvas.height / 4);
        
        // Placeholder for high scores
        ctx.fillStyle = "#CCC";
        ctx.font = "20px sans-serif";
        ctx.fillText("Your recent score: " + score, canvas.width / 2, canvas.height / 2);
        
        // Instructions with subtle backdrop at bottom
        const instructY = canvas.height - 70;
        const instructHeight = 50;
        
        // Draw semi-transparent backdrop for instructions
        ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
        ctx.fillRect(0, instructY, canvas.width, instructHeight);
        
        // Return instruction
        ctx.fillStyle = "rgba(200, 200, 220, 0.9)";
        ctx.font = "18px sans-serif";
        ctx.fillText("ESC: Return to main menu", canvas.width / 2, instructY + 30);
      }
      
      // Main draw function
      function draw() {
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // For menu screens, use the dedicated menu background
        const isMenuScreen = 
          gameState === GAME_STATE.MAIN_MENU || 
          gameState === GAME_STATE.DIFFICULTY_SELECT ||
          gameState === GAME_STATE.SETTINGS ||
          gameState === GAME_STATE.HOW_TO_PLAY ||
          gameState === GAME_STATE.HIGH_SCORES;
          
        if (isMenuScreen) {
          // Use the menu background instead of the game background
          renderMenuBackground();
        } else {
          // For gameplay and other screens, use the regular background
          drawStarfield(ctx);
          drawPulsar(ctx);
          drawCronos(ctx);
        }
        
        // Draw the appropriate screen based on game state
        switch(gameState) {
          case GAME_STATE.MAIN_MENU:
            drawMainMenu();
            return;
          case GAME_STATE.DIFFICULTY_SELECT:
            drawDifficultySelect();
            return;
          case GAME_STATE.SETTINGS:
            drawSettings();
            return;
          case GAME_STATE.HOW_TO_PLAY:
            drawHowToPlay();
            return;
          case GAME_STATE.HIGH_SCORES:
            drawHighScores();
            return;
          case GAME_STATE.PAUSE_MENU:
            drawPauseMenu();
            return;
        }
        if (gameState === GAME_STATE.WIN) {
          // draw any leftover explosion particles
          for (let p of smallExplosionParticles) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fillStyle = p.color;
            ctx.fill();
          }
          ctx.fillStyle = "lime";
          ctx.font = "48px sans-serif";
          ctx.textAlign = "center";
          ctx.fillText("VICTORY!", canvas.width / 2, canvas.height / 2 - 50);
          
          // Show difficulty
          let difficultyName = "";
          switch(currentDifficulty) {
            case DIFFICULTY.EASY: difficultyName = "Easy"; break;
            case DIFFICULTY.MEDIUM: difficultyName = "Medium"; break;
            case DIFFICULTY.HARD: difficultyName = "Hard"; break;
          }
          
          ctx.font = "24px sans-serif";
          ctx.fillText(`Mode: ${difficultyName}`, canvas.width / 2, canvas.height / 2);
          ctx.fillText("Press ENTER to return to menu", canvas.width / 2, canvas.height / 2 + 40);
          ctx.fillText(`Score: ${score}`, canvas.width / 2, 40);
          return;
        }
        if (gameState === GAME_STATE.GAME_OVER) {
          for (let p of smallExplosionParticles) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fillStyle = p.color;
            ctx.fill();
          }
          ctx.fillStyle = "red";
          ctx.font = "48px sans-serif";
          ctx.textAlign = "center";
          ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2 - 50);
          
          // Show difficulty and time survived
          let difficultyName = "";
          switch(currentDifficulty) {
            case DIFFICULTY.EASY: difficultyName = "Easy"; break;
            case DIFFICULTY.MEDIUM: difficultyName = "Medium"; break;
            case DIFFICULTY.HARD: difficultyName = "Hard"; break;
            case DIFFICULTY.INFINITY: difficultyName = "Infinity"; break;
          }
          
          ctx.font = "24px sans-serif";
          ctx.fillText(`Mode: ${difficultyName}`, canvas.width / 2, canvas.height / 2);
          
          // For Infinity mode, show how long the player survived
          if (currentDifficulty === DIFFICULTY.INFINITY) {
            const minutes = Math.floor(gameTime / 60);
            const seconds = Math.floor(gameTime % 60);
            ctx.fillText(`Survived: ${minutes}m ${seconds}s`, canvas.width / 2, canvas.height / 2 + 30);
          }
          
          ctx.fillText("Press ENTER to restart", canvas.width / 2, canvas.height / 2 + 70);
          ctx.fillText(`Score: ${score}`, canvas.width / 2, 40);
          return;
        }

        ctx.fillStyle = "white";
        ctx.font = "24px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("Score: " + score, canvas.width / 2, 40);
        
        // Show difficulty and game time
        let difficultyName = "";
        switch(currentDifficulty) {
          case DIFFICULTY.EASY: difficultyName = "Easy"; break;
          case DIFFICULTY.MEDIUM: difficultyName = "Medium"; break;
          case DIFFICULTY.HARD: difficultyName = "Hard"; break;
          case DIFFICULTY.INFINITY: difficultyName = "Infinity"; break;
        }
        
        ctx.font = "16px sans-serif";
        ctx.fillText(difficultyName, canvas.width / 2, 65);
        
        // Show time remaining for timed modes or time survived for infinity
        if (currentDifficulty === DIFFICULTY.INFINITY) {
          const minutes = Math.floor(gameTime / 60);
          const seconds = Math.floor(gameTime % 60);
          ctx.fillText(`Survived: ${minutes}m ${seconds.toString().padStart(2, '0')}s`, canvas.width / 2, 85);
          
          // Show spawn rate increase indicator in infinity mode - only during actual gameplay
          if (infinityModeSpawnMultiplier > 1.0 && gameState === GAME_STATE.PLAYING) {
            ctx.fillStyle = "yellow";
            ctx.fillText(`Spawn Rate: ${(infinityModeSpawnMultiplier * 100).toFixed(0)}%`, canvas.width / 2, 105);
          }
        } else {
          // Show time remaining for timed modes
          const timeRemaining = Math.max(0, GAME_DURATION[currentDifficulty] - gameTime);
          const minutes = Math.floor(timeRemaining / 60);
          const seconds = Math.floor(timeRemaining % 60);
          ctx.fillText(`Time: ${minutes}:${seconds.toString().padStart(2, '0')}`, canvas.width / 2, 85);
        }
        
        drawHealthBar();
        drawMusicIcon();

        // Power-ups
        for (let pu of powerUps) {
          ctx.save();
          ctx.translate(pu.x, pu.y);
          
          // Different colors for different power-up types
          let coreColor, glowColor, particleColor, iconText;
          
          if (pu.type === "tripleShot") {
            coreColor = "#3080ff"; // Bright blue core
            glowColor = "#80c0ff"; // Light blue glow
            particleColor = "#00ccff"; // Cyan particles
            iconText = pu.enhanced ? "6X" : "3X";
          } else {
            // Default health power-up
            coreColor = "#ff3030"; // Bright red core
            glowColor = "#ff8080"; // Light red glow
            particleColor = "#ff0000"; // Red particles
            iconText = "HP";
          }
          
          // Calculate animation values
          // Pulse effect for the glow
          const pulseAmount = 0.3 + 0.3 * Math.sin(gameTime * POWERUP_PULSE_SPEED);
          // Rotation angle for orbiting particles
          const rotationAngle = gameTime * POWERUP_ROTATION_SPEED;
          
          // Warning effect for power-ups with short lifetime
          let warningEffect = 1;
          if (pu.lifetime < 5) {
            warningEffect = 0.5 + 0.5 * Math.sin(gameTime * 10); // Faster blinking when about to expire
          }
          
          // 1. Draw the outer glow
          const outerGlowRadius = POWERUP_SIZE * (1.5 + pulseAmount);
          const glowGradient = ctx.createRadialGradient(
            0, 0, POWERUP_SIZE * 0.5,
            0, 0, outerGlowRadius
          );
          
          glowGradient.addColorStop(0, `${glowColor}80`); // 50% opacity
          glowGradient.addColorStop(1, `${glowColor}00`); // 0% opacity
          
          ctx.beginPath();
          ctx.arc(0, 0, outerGlowRadius, 0, Math.PI * 2);
          ctx.fillStyle = glowGradient;
          ctx.fill();
          
          // 2. Draw orbiting particles
          const numParticles = 6;
          const orbitRadius = POWERUP_SIZE * (1.2 + pulseAmount * 0.5);
          ctx.fillStyle = `rgba(${hexToRgb(particleColor)}, ${0.8 * warningEffect})`;
          
          for (let i = 0; i < numParticles; i++) {
            const angle = rotationAngle + (i / numParticles) * Math.PI * 2;
            const pX = Math.cos(angle) * orbitRadius;
            const pY = Math.sin(angle) * orbitRadius;
            const pSize = POWERUP_SIZE * 0.15 * (1 + 0.5 * Math.sin(gameTime * 3 + i));
            
            ctx.beginPath();
            ctx.arc(pX, pY, pSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Add small trails to particles
            const trailLength = pSize * 2;
            const trailWidth = pSize * 0.7;
            
            // Create a trail gradient
            const trailGradient = ctx.createLinearGradient(
              pX, pY,
              pX - Math.cos(angle) * trailLength,
              pY - Math.sin(angle) * trailLength
            );
            
            trailGradient.addColorStop(0, `rgba(${hexToRgb(particleColor)}, ${0.6 * warningEffect})`);
            trailGradient.addColorStop(1, `rgba(${hexToRgb(particleColor)}, 0)`);
            
            ctx.beginPath();
            ctx.moveTo(pX, pY);
            ctx.lineTo(
              pX - Math.cos(angle) * trailLength,
              pY - Math.sin(angle) * trailLength - trailWidth/2
            );
            ctx.lineTo(
              pX - Math.cos(angle) * trailLength,
              pY - Math.sin(angle) * trailLength + trailWidth/2
            );
            ctx.closePath();
            ctx.fillStyle = trailGradient;
            ctx.fill();
          }
          
          // 3. Draw the core with a soft glow
          const coreSize = POWERUP_SIZE * (0.8 + pulseAmount * 0.2);
          const coreGradient = ctx.createRadialGradient(
            0, 0, 0,
            0, 0, coreSize
          );
          
          coreGradient.addColorStop(0, `rgba(255, 255, 255, ${0.9 * warningEffect})`); // White center
          coreGradient.addColorStop(0.6, `rgba(${hexToRgb(coreColor)}, ${0.8 * warningEffect})`);
          coreGradient.addColorStop(1, `rgba(${hexToRgb(coreColor)}, ${0.6 * warningEffect})`);
          
          ctx.beginPath();
          ctx.arc(0, 0, coreSize, 0, Math.PI * 2);
          ctx.fillStyle = coreGradient;
          ctx.shadowBlur = 10;
          ctx.shadowColor = glowColor;
          ctx.fill();
          
          // 4. Draw the icon text
          // Add blinking effect based on power-up type
          let textOpacity = warningEffect;
          if (pu.type === "tripleShot") {
            textOpacity *= 0.6 + 0.4 * Math.sin(gameTime * POWERUP_BLINK_SPEED);
          }
          
          ctx.font = `bold ${POWERUP_SIZE * 0.5}px Arial`;
          ctx.fillStyle = `rgba(255, 255, 255, ${textOpacity})`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.shadowBlur = 5;
          ctx.shadowColor = "rgba(0, 0, 0, 0.5)";
          ctx.fillText(iconText, 0, 0);
          
          ctx.restore();
        }
        
        // Helper function to convert hex to rgb
        function hexToRgb(hex) {
          // Remove the hash if it exists
          hex = hex.replace(/^#/, '');
          
          // Parse the hex values
          const bigint = parseInt(hex, 16);
          const r = (bigint >> 16) & 255;
          const g = (bigint >> 8) & 255;
          const b = bigint & 255;
          
          return `${r}, ${g}, ${b}`;
        }
        
        // Display triple shot timer if active
        if (spaceship.tripleShot) {
          const timerWidth = 80;
          const timerHeight = 6;
          const timeLeft = spaceship.tripleShotTimer / TRIPLE_SHOT_DURATION;
          
          ctx.save();
          // Position below health bar
          const x = canvas.width - 120;
          const y = 45;
          
          // Timer background
          ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
          ctx.fillRect(x, y, timerWidth, timerHeight);
          
          // Timer fill
          ctx.fillStyle = TRIPLE_SHOT_POWERUP_COLOR;
          ctx.fillRect(x, y, timerWidth * timeLeft, timerHeight);
          
          // Timer text - show 6X for enhanced shots in infinity mode
          const shotText = (currentDifficulty === DIFFICULTY.INFINITY && 
                           infinityModeSpawnMultiplier >= 1.5) ? "6X Shot" : "3X Shot";
          ctx.font = "12px Arial";
          ctx.fillStyle = "white";
          ctx.textAlign = "center";
          ctx.fillText(shotText, x + timerWidth/2, y - 5);
          
          ctx.restore();
        }

        // Spaceship
        drawSpaceship();

        // Sparks
        const noseX = spaceship.x + Math.cos(spaceship.angle) * spaceship.size;
        const noseY = spaceship.y + Math.sin(spaceship.angle) * spaceship.size;
        ctx.save();
        ctx.strokeStyle = "yellow";
        ctx.lineWidth = 1;
        for (let spark of sparks) {
          ctx.beginPath();
          ctx.moveTo(noseX, noseY);
          ctx.lineTo(
            noseX + Math.cos(spark.angle) * spark.length,
            noseY + Math.sin(spark.angle) * spark.length
          );
          ctx.stroke();
        }
        ctx.restore();

        // Bullets
        ctx.fillStyle = "white";
        for (let b of bullets) {
          ctx.beginPath();
          ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
          ctx.fill();
        }

        // Normal Comets
        drawNormalComets();

        // Big Comets
        drawBigComets(ctx);

        // Explosion Particles
        for (let p of smallExplosionParticles) {
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fillStyle = p.color;
          ctx.fill();
        }
      }

      // Game Loop
      let lastLoopTime = performance.now();
      function gameLoop(now) {
        const dt = (now - lastLoopTime) / 1000;
        lastLoopTime = now;
        
        // Update menu background if in menu screens
        const isMenuScreen = 
          gameState === GAME_STATE.MAIN_MENU || 
          gameState === GAME_STATE.DIFFICULTY_SELECT ||
          gameState === GAME_STATE.SETTINGS ||
          gameState === GAME_STATE.HOW_TO_PLAY ||
          gameState === GAME_STATE.HIGH_SCORES;
        
        if (isMenuScreen) {
          updateMenuBackground(dt);
        }
        
        updateExplosionParticles(dt);
        update(dt);
        draw();
        requestAnimationFrame(gameLoop);
      }
      requestAnimationFrame(gameLoop);

      // The main update function
      function update(dt) {
        // always update starfield
        updateStarfield(dt);
        

        // Update ship hit flash timer
        if (spaceship.hitFlashTimer > 0) {
          spaceship.hitFlashTimer -= dt;
          if (spaceship.hitFlashTimer < 0) spaceship.hitFlashTimer = 0;
        }
        
        // Update triple shot timer
        if (spaceship.tripleShot) {
          spaceship.tripleShotTimer -= dt;
          if (spaceship.tripleShotTimer <= 0) {
            spaceship.tripleShot = false;
          }
        }


        // if not in playing state, do minimal
        if (gameState !== GAME_STATE.PLAYING) {
          return;
        }

        // Increase global time so comet morph can happen
        gameTime += dt;

        // Triple shot timer is now updated earlier in the update cycle
        
        // Check if we should spawn a triple shot power-up before big comets
        if (!tripleShootPowerUpSpawned && bigComets.length === 0) {
          tripleShootPowerUpTimer += dt;
          // Spawn triple shot power-up TRIPLE_SHOT_SPAWN_TIME seconds before next big comet
          if (BIG_COMET_SPAWN_INTERVAL - bigCometSpawnTimer <= TRIPLE_SHOT_SPAWN_TIME && tripleShootPowerUpTimer >= 2) {
            powerUps.push(spawnTripleShotPowerUp());
            tripleShootPowerUpSpawned = true;
            tripleShootPowerUpTimer = 0;
          }
        } else if (bigComets.length > 0) {
          // Reset flag when big comets are present
          tripleShootPowerUpSpawned = false;
        }

        // Regular power-ups
        powerUpSpawnTimer += dt;
        if (powerUpSpawnTimer >= POWERUP_SPAWN_INTERVAL) {
          powerUps.push(spawnPowerUp());
          powerUpSpawnTimer = 0;
        }
        for (let i = powerUps.length - 1; i >= 0; i--) {
          let pu = powerUps[i];
          pu.lifetime -= dt;
          pu.x += pu.vx * dt;
          pu.y += pu.vy * dt;
          bounce(pu, POWERUP_RADIUS);
          if (pu.lifetime <= 0) {
            powerUps.splice(i, 1);
            continue;
          }
          // Check if spaceship picks it up
          const dx = spaceship.x - pu.x;
          const dy = spaceship.y - pu.y;
          if (Math.hypot(dx, dy) < (spaceship.size / 2 + pu.radius)) {
            // Apply power-up effect based on type
            if (pu.type === "health") {
              // Refill HP
              spaceship.hitPoints = Math.min(5, spaceship.hitPoints + 3);
            } else if (pu.type === "tripleShot") {
              // Activate triple shot or enhanced shot in infinity mode
              spaceship.tripleShot = true;
              spaceship.tripleShotTimer = TRIPLE_SHOT_DURATION;
            }
            
            // Play power-up sound
            powerUpSound.volume = 0.3;
            powerUpSound.play().catch(err => console.error("Error playing powerup sound:", err));
            powerUps.splice(i, 1); // Remove the power-up after collection
            continue;



          }
        }

        // Win condition based on current difficulty
        const gameDuration = GAME_DURATION[currentDifficulty];
        let spawnAllowed = gameTime < gameDuration;
        
        // In infinity mode, always allow spawning
        if (currentDifficulty === DIFFICULTY.INFINITY) {
          spawnAllowed = true;
          
          // Only update infinity mode while actually playing the game
          if (gameState === GAME_STATE.PLAYING) {
            // Update infinity mode timer
            infinityModeTime += dt;
            
            // Every 2 minutes (120 seconds), increase spawn rate by 5%
            const twoMinutesPassed = Math.floor(infinityModeTime / 120);
            const newMultiplier = 1.0 + (twoMinutesPassed * 0.05);
            
            // Only update if it's changed to avoid constant reassignment
            if (newMultiplier !== infinityModeSpawnMultiplier) {
              infinityModeSpawnMultiplier = newMultiplier;
              console.log(`Infinity mode: Spawn rate now ${(infinityModeSpawnMultiplier * 100).toFixed(0)}% of base`);
            }
          }
        }
        
        // Victory condition for timed modes
        if (currentDifficulty !== DIFFICULTY.INFINITY && 
            gameTime >= gameDuration && !winTriggered) {
          // Make all comets explode
          for (let i = comets.length - 1; i >= 0; i--) {
            createSmallExplosion(comets[i].x, comets[i].y);
            score += 10; // Award score for each comet
          }
          comets = []; // Clear all comets
          
          // Make all big comets explode too
          for (let i = bigComets.length - 1; i >= 0; i--) {
            createHugeExplosion(bigComets[i].x, bigComets[i].y);
            score += 100; // Award score for each big comet
          }
          bigComets = []; // Clear all big comets
          
          // Create a celebratory explosion at the player's ship
          createHugeExplosion(spaceship.x, spaceship.y);
          
          winTriggered = true;
          gameState = GAME_STATE.WIN;
          bgMusic.pause(); // Stop the gameplay music
          victorySound.play().catch(err => console.error("Error playing victory sound:", err));
        }

        // Movement/Collisions
        // Spaceship vs comets
        for (let i = 0; i < comets.length; i++) {
          const c = comets[i];
          const dx = spaceship.x - c.x;
          const dy = spaceship.y - c.y;
          const dist = Math.hypot(dx, dy);
          if (dist < spaceship.size + c.radius) {
            let nx = dx / dist;
            let ny = dy / dist;
            let overlap = (spaceship.size + c.radius) - dist;
            // separate them
            spaceship.x += nx * (overlap / 2);
            spaceship.y += ny * (overlap / 2);
            c.x -= nx * (overlap / 2);
            c.y -= ny * (overlap / 2);
            // bounce velocities
            spaceship.vx = -spaceship.vx * 0.5;
            spaceship.vy = -spaceship.vy * 0.5;
            c.vx = -c.vx * 0.3;
            c.vy = -c.vy * 0.3;
            // damage spaceship
            spaceship.hitPoints--;
            spaceship.hitFlashTimer = 0.3;
            if (spaceship.hitPoints <= 0) {
              comets = [];
              bigComets = [];
              bullets = [];
              sparks = [];
              createHugeExplosion(spaceship.x, spaceship.y);
              gameState = GAME_STATE.GAME_OVER;
              bgMusic.pause(); // Stop the gameplay music
              defeatSound.play().catch(err => console.error("Error playing defeat sound:", err));
              return;
            }
          }
        }

        // Spaceship vs bigComets
        for (let i = 0; i < bigComets.length; i++) {
          const bc = bigComets[i];
          const dx = spaceship.x - bc.x;
          const dy = spaceship.y - bc.y;
          const dist = Math.hypot(dx, dy);
          if (dist < spaceship.size * 1.2 + bc.radius) {
            let nx = dx / dist;
            let ny = dy / dist;
            let overlap = (spaceship.size + bc.radius) - dist;
            spaceship.x += nx * (overlap / 2);
            spaceship.y += ny * (overlap / 2);
            spaceship.vx = -spaceship.vx * 0.5;
            spaceship.vy = -spaceship.vy * 0.5;
            spaceship.hitPoints--;
            spaceship.hitFlashTimer = 0.3;
            if (spaceship.hitPoints <= 0) {
              comets = [];
              bigComets = [];
              bullets = [];
              sparks = [];
              createHugeExplosion(spaceship.x, spaceship.y);
              gameState = GAME_STATE.GAME_OVER;
              bgMusic.pause(); // Stop the gameplay music
              defeatSound.play().catch(err => console.error("Error playing defeat sound:", err));
              return;
            }
          }
        }

        // Movement controls
        if (keys["ArrowUp"]) {
          spaceship.vx += Math.cos(spaceship.angle) * SHIP_ACCEL * dt;
          spaceship.vy += Math.sin(spaceship.angle) * SHIP_ACCEL * dt;
        }
        if (keys["ArrowDown"]) {
          spaceship.vx -= Math.cos(spaceship.angle) * SHIP_REVERSE * dt;
          spaceship.vy -= Math.sin(spaceship.angle) * SHIP_REVERSE * dt;
        }
        if (keys["Space"]) {
          // Quick brake
          let speed = Math.sqrt(spaceship.vx ** 2 + spaceship.vy ** 2);
          if (speed > 0) {
            let deceleration = SHIP_REVERSE * dt;
            let newSpeed = Math.max(0, speed - deceleration);
            spaceship.vx = (spaceship.vx / speed) * newSpeed;
            spaceship.vy = (spaceship.vy / speed) * newSpeed;
          }
        }
        if (keys["ArrowLeft"]) {
          spaceship.angle -= SHIP_ROT_SPEED * dt;
        }
        if (keys["ArrowRight"]) {
          spaceship.angle += SHIP_ROT_SPEED * dt;
        }

        // Spaceship movement
        spaceship.x += spaceship.vx * dt;
        spaceship.y += spaceship.vy * dt;
        spaceship.vx *= FRICTION;
        spaceship.vy *= FRICTION;
        bounce(spaceship, spaceship.size, 0.3);

        // Shooting
        lastBulletTime += dt * 1000;
        if (lastBulletTime > BULLET_INTERVAL) {
          // Fire bullets from different gun positions
          const noseX = spaceship.x + Math.cos(spaceship.angle) * spaceship.size;
          const noseY = spaceship.y + Math.sin(spaceship.angle) * spaceship.size;
          const perpX = Math.cos(spaceship.angle + Math.PI / 2);
          const perpY = Math.sin(spaceship.angle + Math.PI / 2);
          
          // Positions for each gun
          const topGunX = spaceship.x + Math.cos(spaceship.angle) * (spaceship.size * 0.8) + perpX * (spaceship.size * 0.4);
          const topGunY = spaceship.y + Math.sin(spaceship.angle) * (spaceship.size * 0.8) + perpY * (spaceship.size * 0.4);
          
          const bottomGunX = spaceship.x + Math.cos(spaceship.angle) * (spaceship.size * 0.8) - perpX * (spaceship.size * 0.4);
          const bottomGunY = spaceship.y + Math.sin(spaceship.angle) * (spaceship.size * 0.8) - perpY * (spaceship.size * 0.4);

          // Bullet spawn positions from each gun
          const spawnPositions = [
            { x: topGunX, y: topGunY },        // Top gun
            { x: noseX, y: noseY },            // Center gun 
            { x: bottomGunX, y: bottomGunY }   // Bottom gun
          ];
          
          // Determine how many bullets to fire based on power-up
          let bulletsPerGun = 1;
          
          if (spaceship.tripleShot) {
            // In infinity mode with high spawn rate, use enhanced shot
            if (currentDifficulty === DIFFICULTY.INFINITY && 
                infinityModeSpawnMultiplier >= 1.5) {
              bulletsPerGun = ENHANCED_SHOT_MULTIPLIER;
            } else {
              bulletsPerGun = 3; // Normal triple shot
            }
          }
          
          // Fire from each gun position
          for (let gunIndex = 0; gunIndex < spawnPositions.length; gunIndex++) {
            const pos = spawnPositions[gunIndex];
            
            // Fire multiple bullets from each gun if triple shot is active
            for (let bulletIndex = 0; bulletIndex < bulletsPerGun; bulletIndex++) {
              // Compute angle with variation
              let angleVariation;
              
              if (bulletsPerGun === 1) {
                // Normal mode - slight random variation
                angleVariation = (gunIndex === 1) ? 
                  randomRange(-0.03, 0.03) : // Center gun - less variation
                  randomRange(-0.05, 0.05);  // Side guns - more variation
              } else {
                // Triple shot mode - spread pattern
                // Calculate spread based on bullet index (-0.12, 0, 0.12 radians)
                const spreadFactor = 0.12; // About 7 degrees
                angleVariation = (bulletIndex - 1) * spreadFactor;
                // Add a tiny random variation for natural feel
                angleVariation += randomRange(-0.01, 0.01);
              }
              
              // Final bullet angle
              const angle = spaceship.angle + angleVariation;
              
              // Create and add the bullet
              const bullet = {
                x: pos.x,
                y: pos.y,
                vx: Math.cos(angle) * BULLET_SPEED + spaceship.vx,
                vy: Math.sin(angle) * BULLET_SPEED + spaceship.vy,
                radius: BULLET_RADIUS
              };
              bullets.push(bullet);
            }
          }
          bulletSoundPool[nextBulletSoundIndex].currentTime = 0;
          bulletSoundPool[nextBulletSoundIndex].play();
          nextBulletSoundIndex = (nextBulletSoundIndex + 1) % BULLET_SOUND_POOL_SIZE;
          lastBulletTime = 0;
          // Sparks
          const numSparks = Math.floor(randomRange(1, 3));
          for (let i = 0; i < numSparks; i++) {
            const baseSparkOffset = Math.PI / 8;
            const sparkAngle = spaceship.angle + (Math.random() < 0.5 ? baseSparkOffset : -baseSparkOffset) + randomRange(-0.05, 0.05);
            sparks.push({
              angle: sparkAngle,
              length: randomRange(2, 5),
              lifetime: 0.2
            });
          }
        }

        // Update sparks
        for (let i = sparks.length - 1; i >= 0; i--) {
          sparks[i].lifetime -= dt;
          if (sparks[i].lifetime <= 0) {
            sparks.splice(i, 1);
          }
        }

        // Update bullets
        for (let i = bullets.length - 1; i >= 0; i--) {
          let b = bullets[i];
          b.x += b.vx * dt;
          b.y += b.vy * dt;
          // off screen => remove
          if (b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) {
            bullets.splice(i, 1);
          }
        }

        // Update comets
        for (let c of comets) {
          if (c.slowEffectTimer > 0) {
            c.slowEffectTimer -= dt;
            if (c.slowEffectTimer < 0) c.slowEffectTimer = 0;
          }
          if (c.indestructableTimer > 0) {
            c.indestructableTimer -= dt;
            if (c.indestructableTimer < 0) c.indestructableTimer = 0;
          }
          if (c.hitEffectTimer > 0) {
            c.hitEffectTimer -= dt;
            if (c.hitEffectTimer < 0) c.hitEffectTimer = 0;
          }
          c.x += c.vx * dt;
          c.y += c.vy * dt;
          c.vx *= COMET_FRICTION;
          c.vy *= COMET_FRICTION;
          // never drop below COMET_MIN_SPEED
          let speed = Math.hypot(c.vx, c.vy);
          if (speed < COMET_MIN_SPEED && speed > 0) {
            let factor = COMET_MIN_SPEED / speed;
            c.vx *= factor;
            c.vy *= factor;
          }
          bounce(c, c.radius);

          c.trailTimer += dt;
          if (c.trailTimer >= 0.05) { // TRAIL_INTERVAL
            c.trailTimer -= 0.05;
            c.trail.push({ x: c.x, y: c.y });
            if (c.trail.length > 5) {
              c.trail.shift();
            }
          }
        }

        // update big comets
        updateBigComets(dt);
        updateTimers(dt);

        // Bullets vs Comets
        for (let i = bullets.length - 1; i >= 0; i--) {
          let b = bullets[i];
          let bulletHit = false;
          for (let j = comets.length - 1; j >= 0; j--) {
            let c = comets[j];
            if (c.indestructableTimer > 0) continue;
            let dx = b.x - c.x;
            let dy = b.y - c.y;
            if (Math.hypot(dx, dy) < c.radius) {
              bulletHit = true;
              // Throttled bullet hit sound
              if (soundEnabled) {
                const now = performance.now();
                // Only play sound if enough time has passed since last hit sound
                // and last bullet in HP (more satisfying on final hit)
                if ((now - lastHitSoundTime > HIT_SOUND_THROTTLE) || (c.hitPoints === 1)) {
                  hitSoundPool[nextHitSoundIndex].currentTime = 0;
                  hitSoundPool[nextHitSoundIndex].play();
                  nextHitSoundIndex = (nextHitSoundIndex + 1) % HIT_SOUND_POOL_SIZE;
                  lastHitSoundTime = now;
                }
              }
              c.hitPoints--;
              
              // Create bullet impact effect for visual feedback
              createBulletImpact(b.x, b.y);
              
              // slow effect if tier 3
              if (c.tier === 3 && c.slowEffectTimer === 0) {
                c.vx *= 0.66;
                c.vy *= 0.66;
                c.slowEffectTimer = 0.5;
              }
              c.hitEffectTimer = 0.5;
              // destroyed
              if (c.hitPoints <= 0) {
                createSmallExplosion(c.x, c.y);
                // if bigger than tier1 => split
                if (c.tier > 1) {
                  const newTier = c.tier - 1;
                  const baseSpeed = Math.hypot(c.vx, c.vy);
                  let splits = Math.floor(randomRange(2, 6));
                  const offset = 50;
                  for (let k = 0; k < splits; k++) {
                    let newAngle = Math.random() * 2 * Math.PI;
                    let factor = randomRange(0.7, 0.8);
                    let extraFactor = randomRange(1.2, 1.5);
                    let newSpeed = baseSpeed * factor * extraFactor;
                    spawnComet(
                      newTier,
                      c.x + Math.cos(newAngle) * offset,
                      c.y + Math.sin(newAngle) * offset,
                      Math.cos(newAngle) * newSpeed,
                      Math.sin(newAngle) * newSpeed
                    );
                    // short indestructable so they don't instantly collide
                    comets[comets.length - 1].indestructableTimer = 0.01;
                  }
                }
                score += 10;
                comets.splice(j, 1);
              }
              break;
            }
          }
          // if not hit normal comet, check big comet
          if (!bulletHit) {
            for (let j = bigComets.length - 1; j >= 0; j--) {
              let bc = bigComets[j];
              let dx = b.x - bc.x;
              let dy = b.y - bc.y;
              if (Math.hypot(dx, dy) < bc.radius) {
                bulletHit = true;
                
                // Reduce hit points
                bc.hitPoints--;
                bc.hitCount++;
                
                // Set flash timer for visual feedback
                bc.hitFlashTimer = 0.1;
                
                // Create bullet impact visual effect at the bullet's position
                createBulletImpact(b.x, b.y);
                
                // Increase shake frequency but reduce distance based on damage
                // Smaller shake amplitude but higher frequency as damage increases
                bc.shakeAmount = 3 + (bc.hitCount / BIG_COMET_HEALTH) * 8;
                bc.shakeTimer = 0.2 + (bc.hitCount / BIG_COMET_HEALTH) * 0.4; // Longer shake duration with damage
                
                // Play hit sound
                if (soundEnabled) {
                  const now = performance.now();
                  // Only play sound occasionally or on milestone hits
                  if ((now - lastHitSoundTime > HIT_SOUND_THROTTLE * 2) || 
                      (bc.hitPoints % 500 === 0) || // Every 500 hits
                      (bc.hitPoints <= 200)) {      // Last 200 hits
                    hitSoundPool[nextHitSoundIndex].currentTime = 0;
                    hitSoundPool[nextHitSoundIndex].play();
                    nextHitSoundIndex = (nextHitSoundIndex + 1) % HIT_SOUND_POOL_SIZE;
                    lastHitSoundTime = now;
                  }
                }
                
                break;
              }
            }
          }
          if (bulletHit) {
            bullets.splice(i, 1);
          }
        }

        // check collisions among comets
        checkCometCollisions();

        checkBigCometCollisions();

        // spawn new comets over time based on difficulty
        if (spawnAllowed) {
          cometSpawnTimer += dt;
          
          // Get base spawn interval
          let spawnInterval = randomRange(COMET_SPAWN_MIN, COMET_SPAWN_MAX);
          
          // Apply difficulty multiplier (higher multiplier = lower rate)
          let difficultyMultiplier;
          if (currentDifficulty === DIFFICULTY.INFINITY) {
            // For infinity mode, use the dynamic multiplier
            difficultyMultiplier = 1 / infinityModeSpawnMultiplier;
          } else {
            // For other modes, use the fixed multiplier
            difficultyMultiplier = 1 / SPAWN_RATE_MULTIPLIER[currentDifficulty];
          }
          
          // Apply the multiplier to spawn interval
          spawnInterval *= difficultyMultiplier;
          
          if (cometSpawnTimer > spawnInterval) {
            // Scale spawn count based on area
            let area = canvas.width * canvas.height;
            let scaleFactor = area / 480000;
            scaleFactor = Math.max(0.5, Math.min(2, scaleFactor));
            
            // Determine base spawn count
            let baseSpawnCount = COMET_SPAWN_BATCH_MIN + 
              Math.floor(Math.random() * (COMET_SPAWN_BATCH_MAX - COMET_SPAWN_BATCH_MIN + 1));
            
            // Apply difficulty modifier to spawn count
            let spawnCount = Math.floor(baseSpawnCount * scaleFactor);
            
            // Spawn the comets
            for (let i = 0; i < spawnCount; i++) {
              spawnComet();
            }
            
            cometSpawnTimer = 0;
          }
        }
      }

    })();
  </script>
</body>

</html>