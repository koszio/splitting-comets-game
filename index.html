<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Splitting Comets Game – With Comet Trails and Transparent Comets</title>
    <style>
      html, body {
        margin: 0; 
        padding: 0;
        background: black;
        overflow: hidden;
      }
      canvas {
        display: block;
        background: black;
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas" tabindex="1"></canvas>
    <script>
      (function() {
        /*
          ---- SOUND EFFECTS ----
          bulletSound: 0.2s wood tap
          hitSound: 0.2s flick (each hit plays fully at lower volume)
          explosionSound: using local file "small-explosion-94980.mp3"
        */
        const bulletSoundSrc = "https://actions.google.com/sounds/v1/wood/wood_plank_flicks.ogg";
        const hitSoundSrc = "https://actions.google.com/sounds/v1/cartoon/wood_plank_flicks.ogg";
        // Use your local file for explosion sounds.
        const explosionSoundURL = "retro-explode.mp3";
  
         // Create a pool for bullet sounds (pool size 3)
         const BULLET_SOUND_POOL_SIZE = 3;
        const bulletSoundPool = [];
        for (let i = 0; i < BULLET_SOUND_POOL_SIZE; i++) {
          let a = new Audio(bulletSoundSrc);
          a.volume = 0.5;
          bulletSoundPool.push(a);
        }
        let nextBulletSoundIndex = 0;
  
        // Create a pool for hit sounds (pool size 5) at lower volume
        const HIT_SOUND_POOL_SIZE = 5;
        const hitSoundPool = [];
        for (let i = 0; i < HIT_SOUND_POOL_SIZE; i++) {
          let a = new Audio(hitSoundSrc);
          a.volume = 0.2;
          hitSoundPool.push(a);
        }
        let nextHitSoundIndex = 0;
  
        // ----- Setup Canvas -----
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        function resizeCanvas() {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener("resize", () => {
          resizeCanvas();
          initStarfield();
        });
        canvas.focus();
  
        // ----- Global Constants -----
        const SHIP_ROT_SPEED   = 6;       // rotation speed (radians/sec)
        const SHIP_REVERSE     = 400;     // braking deceleration (pixels/sec²)
        const BULLET_SPEED     = 600;     // bullet speed (pixels/sec)
        const BULLET_RADIUS    = 4;
        const BULLET_INTERVAL  = 30;      // ms between shots
        const FRICTION         = 0.99;
      
        const SHIP_SIZE        = 30;      // spaceship size (pixels)
        const SHIP_ACCEL       = 800;     // forward acceleration (pixels/sec²)
  
        // Comets
        const COMET_SPEED_MIN  = 300;
        const COMET_SPEED_MAX  = 500;
        const COMET_FRICTION   = 0.999;
        const MAX_COMET_TIER   = 3;
        const BASE_COMET_RADIUS= 30;
        const COMET_SPAWN_MIN  = 3;       // seconds
        const COMET_SPAWN_MAX  = 5;       // seconds
        const COMET_SPAWN_BATCH_MIN = 3;
        const COMET_SPAWN_BATCH_MAX = 5;
        const COMET_MIN_SPEED  = 50;      // comets never slow below this speed
  
        // ----- Game State & Timer -----
        let gameState = "menu";  // "menu", "settings", "playing", "gameover", "win"
        let score = 0;
        let gameTime = 0;
        let winTriggered = false;
  
        // Spaceship (initial HP = 5). (Invulnerability removed.)
        let spaceship = {
          x: canvas.width / 2,
          y: canvas.height / 2,
          vx: 0,
          vy: 0,
          angle: 0,
          size: SHIP_SIZE,
          hitPoints: 5,
          hitFlashTimer: 0  // When > 0, the ship will flash red on hit
        };
  
        let bullets = [];
        let sparks = [];
        let smallExplosionParticles = [];
        let comets = [];
  
        // ----- Starfield (Enhanced Glowing Stars) -----
        const NUM_STARS = 200;
        let stars = [];
        function initStarfield() {
          stars = [];
          for (let i = 0; i < NUM_STARS; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const baseSize = Math.random() * 2 + 0.5;
            const flicker = Math.random() < 0.7;
            const sizeVariation = flicker ? (Math.random() * 1 + 0.2) : 0;
            const sizeSpeed = flicker ? (Math.random() * 0.5 + 0.2) : 0;
            const sizeTime = flicker ? Math.random() * Math.PI * 2 : 0;
            stars.push({ x, y, baseSize, sizeVariation, sizeSpeed, sizeTime, flicker });
          }
        }
        initStarfield();
  
        function updateStarfield(dt) {
          for (let star of stars) {
            if (star.flicker) {
              star.sizeTime += dt * star.sizeSpeed;
            }
          }
        }
  
        function drawStarfield(ctx) {
          ctx.save();
          for (let star of stars) {
            let currentSize = star.baseSize;
            if (star.flicker) {
              currentSize += star.sizeVariation * Math.sin(star.sizeTime);
              if (currentSize < 0) currentSize = 0;
            }
            let gradient = ctx.createRadialGradient(
              star.x, star.y, currentSize * 0.2,
              star.x, star.y, currentSize
            );
            gradient.addColorStop(0, "rgba(255,255,255,1)");
            gradient.addColorStop(1, "rgba(255,255,255,0)");
            ctx.fillStyle = gradient;
            ctx.shadowBlur = 5;
            ctx.shadowColor = "white";
            ctx.beginPath();
            ctx.arc(star.x, star.y, currentSize, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();
        }
  
        // ----- Health Bar Drawing Function (Top Right) -----
        function drawHealthBar() {
          const barWidth = 100;
          const barHeight = 15;
          const margin = 20;
          const x = canvas.width - margin - barWidth;
          const y = margin;
          ctx.strokeStyle = "white";
          ctx.lineWidth = 2;
          ctx.strokeRect(x, y, barWidth, barHeight);
          let hpFraction = spaceship.hitPoints / 5; // max HP is 5
          ctx.fillStyle = "red";
          ctx.fillRect(x, y, barWidth * hpFraction, barHeight);
        }
  
        let lastBulletTime = 0;
        let cometSpawnTimer = 0;
        let nextCometSpawn = randomRange(COMET_SPAWN_MIN, COMET_SPAWN_MAX);
  
        // ----- Input Handling -----
        const keys = {};
        window.addEventListener("keydown", (e) => {
          if (gameState === "menu" && e.code === "Enter") {
            gameState = "playing";
            score = 0;
            gameTime = 0;
            winTriggered = false;
            return;
          }
          if (gameState === "menu" && e.code === "KeyS") {
            gameState = "settings";
            return;
          }
          if (gameState === "settings" && e.code === "Escape") {
            gameState = "menu";
            return;
          }
          if ((gameState === "gameover" || gameState === "win") && e.code === "Enter") {
            restartGame();
            gameState = "playing";
            return;
          }
          keys[e.code] = true;
          e.preventDefault();
        });
        window.addEventListener("keyup", (e) => {
          keys[e.code] = false;
          e.preventDefault();
        });
  
        // ----- Touch Support -----
        let touchStartX = null, touchStartY = null;
        canvas.addEventListener("touchstart", function(e) {
          e.preventDefault();
          let touch = e.touches[0];
          touchStartX = touch.clientX;
          touchStartY = touch.clientY;
        }, false);
        canvas.addEventListener("touchmove", function(e) {
          e.preventDefault();
          let touch = e.touches[0];
          let deltaX = touch.clientX - touchStartX;
          let deltaY = touch.clientY - touchStartY;
          if (deltaX > 20) {
            keys["ArrowRight"] = true;
            keys["ArrowLeft"] = false;
          } else if (deltaX < -20) {
            keys["ArrowLeft"] = true;
            keys["ArrowRight"] = false;
          } else {
            keys["ArrowLeft"] = false;
            keys["ArrowRight"] = false;
          }
          if (deltaY < -20) {
            keys["ArrowUp"] = true;
            keys["ArrowDown"] = false;
          } else if (deltaY > 20) {
            keys["ArrowDown"] = true;
            keys["ArrowUp"] = false;
          } else {
            keys["ArrowUp"] = false;
            keys["ArrowDown"] = false;
          }
        }, false);
        canvas.addEventListener("touchend", function(e) {
          e.preventDefault();
          keys["ArrowUp"] = false;
          keys["ArrowDown"] = false;
          keys["ArrowLeft"] = false;
          keys["ArrowRight"] = false;
          touchStartX = null;
          touchStartY = null;
        }, false);
  
        // ----- Utility Functions -----
        function randomRange(min, max) {
          return Math.random() * (max - min) + min;
        }
        // Returns a darker color (70% saturation, 30% lightness)
        function randomColor() {
          const hue = Math.floor(Math.random() * 360);
          return "hsl(" + hue + ", 70%, 30%)";
        }
        function bounce(obj, radius, damping = 1) {
          if (obj.x - radius < 0) {
            obj.x = radius;
            obj.vx = -obj.vx * damping;
          }
          if (obj.x + radius > canvas.width) {
            obj.x = canvas.width - radius;
            obj.vx = -obj.vx * damping;
          }
          if (obj.y - radius < 0) {
            obj.y = radius;
            obj.vy = -obj.vy * damping;
          }
          if (obj.y + radius > canvas.height) {
            obj.y = canvas.height - radius;
            obj.vy = -obj.vy * damping;
          }
        }
  
        // ----- New: Generate an irregular comet shape (polygon) -----
        function generateCometShape(segments) {
          let shape = [];
          for (let i = 0; i < segments; i++) {
            let angle = i * 2 * Math.PI / segments;
            let factor = 1 + (Math.random() * 0.6 - 0.3);
            shape.push({ angle: angle, factor: factor });
          }
          return shape;
        }
  
        // ----- New: Generate a stone-like texture pattern (fully opaque) -----
        function generateStonePattern() {
          let patternCanvas = document.createElement("canvas");
          patternCanvas.width = 50;
          patternCanvas.height = 50;
          let pctx = patternCanvas.getContext("2d");
          pctx.globalAlpha = 1.0;
          pctx.fillStyle = "#444";
          pctx.fillRect(0, 0, patternCanvas.width, patternCanvas.height);
          for (let i = 0; i < 20; i++) {
            let x = Math.random() * patternCanvas.width;
            let y = Math.random() * patternCanvas.height;
            let radius = Math.random() * 3;
            let gray = Math.floor(100 + Math.random() * 50);
            pctx.fillStyle = `rgb(${gray}, ${gray}, ${gray})`;
            pctx.beginPath();
            pctx.arc(x, y, radius, 0, 2 * Math.PI);
            pctx.fill();
          }
          return ctx.createPattern(patternCanvas, "repeat");
        }
  
        // ----- New: Helper functions for safe spawning -----
        function getQuadrant(x, y) {
          const midX = canvas.width / 2;
          const midY = canvas.height / 2;
          if (x < midX && y < midY) return "top-left";
          if (x >= midX && y < midY) return "top-right";
          if (x < midX && y >= midY) return "bottom-left";
          return "bottom-right";
        }
        function isInSameQuadrant(x1, y1, x2, y2) {
          return getQuadrant(x1, y1) === getQuadrant(x2, y2);
        }
        function getSpawnLocation() {
          let loc, attempt = 0;
          do {
            if (Math.random() < 0.5) {
              loc = { x: randomRange(0, canvas.width), y: 0 };
            } else {
              loc = { x: randomRange(0, canvas.width), y: canvas.height };
            }
            attempt++;
            if (attempt > 10) break;
          } while(isInSameQuadrant(loc.x, loc.y, spaceship.x, spaceship.y));
          return loc;
        }
  
        // ----- Comet Trails & Spawning -----
        const TRAIL_INTERVAL = 0.05;
        function spawnComet(tier = MAX_COMET_TIER, x, y, vx, vy) {
          if (x === undefined || y === undefined) {
            let loc = getSpawnLocation();
            x = loc.x;
            y = loc.y;
          }
          if (vx === undefined || vy === undefined) {
            const angle = Math.random() * Math.PI * 2;
            const speed = randomRange(COMET_SPEED_MIN, COMET_SPEED_MAX);
            vx = Math.cos(angle) * speed;
            vy = Math.sin(angle) * speed;
          }
          const radius = BASE_COMET_RADIUS * Math.pow(0.6, MAX_COMET_TIER - tier);
          let hp;
          if (tier === 3) { hp = 5; }
          else if (tier === 2) { hp = 4; }
          else { hp = 3; }
          const comet = {
            x, y, vx, vy,
            radius,
            tier,
            color: randomColor(),
            hitPoints: hp,
            hitEffectTimer: 0,
            slowEffectTimer: 0,  // slows when hit; remains slowed afterward
            indestructableTimer: 0,
            oldVX: vx,
            oldVY: vy,
            trail: [],
            trailTimer: 0,
            shape: generateCometShape(12),
            pattern: generateStonePattern()
          };
          comets.push(comet);
        }
  
        // ----- Explosion Effects -----
        function createSmallExplosion(x, y) {
          let exp = new Audio(explosionSoundURL);
          exp.volume = 1.0;
          exp.play().catch(err => console.error("Explosion play error:", err));
          const count = 10;
          for (let i = 0; i < count; i++) {
            let angle = Math.random() * Math.PI * 2;
            let speed = randomRange(50, 150);
            smallExplosionParticles.push({
              x: x,
              y: y,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed,
              lifetime: randomRange(0.3, 0.7),
              size: randomRange(2, 4),
              color: "orange"
            });
          }
        }
        function createHugeExplosion(x, y) {
          let exp = new Audio(explosionSoundURL);
          exp.volume = 1.0;
          exp.play().catch(err => console.error("Huge explosion play error:", err));
          const count = 50;
          for (let i = 0; i < count; i++) {
            let angle = Math.random() * Math.PI * 2;
            let speed = randomRange(100, 300);
            smallExplosionParticles.push({
              x: x,
              y: y,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed,
              lifetime: randomRange(0.8, 1.5),
              size: randomRange(5, 10),
              color: "orange"
            });
          }
        }
  
        function updateExplosionParticles(dt) {
          for (let i = smallExplosionParticles.length - 1; i >= 0; i--) {
            const p = smallExplosionParticles[i];
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.lifetime -= dt;
            p.size *= 0.98;
            if (p.lifetime <= 0) {
              smallExplosionParticles.splice(i, 1);
            }
          }
        }
  
        function checkCometCollisions() {
          let indicesToRemove = new Set();
          for (let i = 0; i < comets.length; i++) {
            for (let j = i + 1; j < comets.length; j++) {
              let c1 = comets[i];
              let c2 = comets[j];
              let dx = c2.x - c1.x;
              let dy = c2.y - c1.y;
              let dist = Math.hypot(dx, dy);
              let minDist = c1.radius + c2.radius;
              if (dist < minDist && dist > 0) {
                if (c1.tier < MAX_COMET_TIER) {
                  indicesToRemove.add(i);
                  createSmallExplosion(c1.x, c1.y);
                  score += 5;
                }
                if (c2.tier < MAX_COMET_TIER) {
                  indicesToRemove.add(j);
                  createSmallExplosion(c2.x, c2.y);
                  score += 5;
                }
                if (c1.tier === MAX_COMET_TIER && c2.tier === MAX_COMET_TIER) {
                  let nx = dx / dist;
                  let ny = dy / dist;
                  let dvx = c1.vx - c2.vx;
                  let dvy = c1.vy - c2.vy;
                  let dot = dvx * nx + dvy * ny;
                  if (dot <= 0) {
                    let bounceFactor = 1;
                    let impulse = bounceFactor * dot;
                    c1.vx -= impulse * nx;
                    c1.vy -= impulse * ny;
                    c2.vx += impulse * nx;
                    c2.vy += impulse * ny;
                    let overlap = minDist - dist;
                    c1.x -= nx * overlap / 2;
                    c1.y -= ny * overlap / 2;
                    c2.x += nx * overlap / 2;
                    c2.y += ny * overlap / 2;
                  }
                }
              }
            }
          }
          comets = comets.filter((_, index) => !indicesToRemove.has(index));
        }
  
        function restartGame() {
          gameState = "menu";
          spaceship.x = canvas.width / 2;
          spaceship.y = canvas.height / 2;
          spaceship.vx = 0;
          spaceship.vy = 0;
          spaceship.angle = 0;
          spaceship.hitPoints = 5;
          spaceship.hitFlashTimer = 0;
          bullets = [];
          comets = [];
          sparks = [];
          smallExplosionParticles = [];
          lastBulletTime = 0;
          cometSpawnTimer = 0;
          nextCometSpawn = randomRange(COMET_SPAWN_MIN, COMET_SPAWN_MAX);
          gameTime = 0;
          winTriggered = false;
          spawnComet();
          initStarfield();
          score = 0;
        }
  
        // ----- Game Loop -----
        let lastLoopTime = performance.now();
        function gameLoop(now) {
          const dt = (now - lastLoopTime) / 1000;
          lastLoopTime = now;
          updateExplosionParticles(dt);
          update(dt);
          draw();
          requestAnimationFrame(gameLoop);
        }
        requestAnimationFrame(gameLoop);
  
        function update(dt) {
          // Update ship hit flash timer
          if (spaceship.hitFlashTimer > 0) {
            spaceship.hitFlashTimer -= dt;
            if (spaceship.hitFlashTimer < 0) spaceship.hitFlashTimer = 0;
          }
  
          if (gameState === "menu" || gameState === "settings" ||
              gameState === "gameover" || gameState === "win") {
            updateStarfield(dt);
            return;
          }
          updateStarfield(dt);
          gameTime += dt;
          let spawnAllowed = gameTime < 120;
          if (gameTime >= 120 && comets.length === 0 && !winTriggered) {
            createHugeExplosion(spaceship.x, spaceship.y);
            winTriggered = true;
            gameState = "win";
          }
  
          // --- Spaceship vs. Comet Collision (separation & bounce) ---
          for (let i = 0; i < comets.length; i++) {
            const c = comets[i];
            const dx = spaceship.x - c.x;
            const dy = spaceship.y - c.y;
            const distance = Math.hypot(dx, dy);
            if (distance < spaceship.size + c.radius) {
              let nx = dx / distance;
              let ny = dy / distance;
              let overlap = (spaceship.size + c.radius) - distance;
              // Separate both objects equally
              spaceship.x += nx * (overlap / 2);
              spaceship.y += ny * (overlap / 2);
              c.x -= nx * (overlap / 2);
              c.y -= ny * (overlap / 2);
              // Bounce velocities with a bounce factor of 0.5
              spaceship.vx = -spaceship.vx * 0.5;
              spaceship.vy = -spaceship.vy * 0.5;
              c.vx = -c.vx * 0.5;
              c.vy = -c.vy * 0.5;
              // Always reduce HP (no invulnerability)
              spaceship.hitPoints--;
              spaceship.hitFlashTimer = 0.3;
              if (spaceship.hitPoints <= 0) {
                comets = [];
                bullets = [];
                sparks = [];
                createHugeExplosion(spaceship.x, spaceship.y);
                gameState = "gameover";
                return;
              }
            }
          }
  
          // --- Update Spaceship Based on Input ---
          if (keys["ArrowUp"]) {
            spaceship.vx += Math.cos(spaceship.angle) * SHIP_ACCEL * dt;
            spaceship.vy += Math.sin(spaceship.angle) * SHIP_ACCEL * dt;
          }
          if (keys["ArrowDown"]) {
            spaceship.vx -= Math.cos(spaceship.angle) * SHIP_REVERSE * dt;
            spaceship.vy -= Math.sin(spaceship.angle) * SHIP_REVERSE * dt;
          }
          if (keys["Space"]) {
            let speed = Math.sqrt(spaceship.vx**2 + spaceship.vy**2);
            if (speed > 0) {
              let deceleration = SHIP_REVERSE * dt;
              let newSpeed = Math.max(0, speed - deceleration);
              spaceship.vx = (spaceship.vx / speed) * newSpeed;
              spaceship.vy = (spaceship.vy / speed) * newSpeed;
            }
          }
          if (keys["ArrowLeft"]) {
            spaceship.angle -= SHIP_ROT_SPEED * dt;
          }
          if (keys["ArrowRight"]) {
            spaceship.angle += SHIP_ROT_SPEED * dt;
          }
          spaceship.x += spaceship.vx * dt;
          spaceship.y += spaceship.vy * dt;
          spaceship.vx *= FRICTION;
          spaceship.vy *= FRICTION;
          bounce(spaceship, spaceship.size);
  
          lastBulletTime += dt * 1000;
          if (lastBulletTime > BULLET_INTERVAL) {
            const noseX = spaceship.x + Math.cos(spaceship.angle) * spaceship.size;
            const noseY = spaceship.y + Math.sin(spaceship.angle) * spaceship.size;
            const perpX = Math.cos(spaceship.angle + Math.PI / 2);
            const perpY = Math.sin(spaceship.angle + Math.PI / 2);
            const holeOffset = spaceship.size / 4;
  
            const leftAngle = spaceship.angle + randomRange(0.1, 0.15);
            const centerAngle = spaceship.angle + randomRange(-0.03, 0.03);
            const rightAngle = spaceship.angle - randomRange(0.1, 0.15);
  
            const spawnPositions = [
              { x: noseX + perpX * holeOffset, y: noseY + perpY * holeOffset },
              { x: noseX, y: noseY },
              { x: noseX - perpX * holeOffset, y: noseY - perpY * holeOffset },
            ];
            const bulletAngles = [leftAngle, centerAngle, rightAngle];
            for (let i = 0; i < 3; i++) {
              const pos = spawnPositions[i];
              const angle = bulletAngles[i];
              const bullet = {
                x: pos.x,
                y: pos.y,
                vx: Math.cos(angle) * BULLET_SPEED + spaceship.vx,
                vy: Math.sin(angle) * BULLET_SPEED + spaceship.vy,
                radius: BULLET_RADIUS,
              };
              bullets.push(bullet);
            }
            bulletSoundPool[nextBulletSoundIndex].currentTime = 0;
            bulletSoundPool[nextBulletSoundIndex].play();
            nextBulletSoundIndex = (nextBulletSoundIndex + 1) % BULLET_SOUND_POOL_SIZE;
            lastBulletTime = 0;
            const numSparks = Math.floor(randomRange(1, 3));
            for (let i = 0; i < numSparks; i++) {
              const baseSparkOffset = Math.PI / 8;
              const sparkAngle = spaceship.angle + (Math.random() < 0.5 ? baseSparkOffset : -baseSparkOffset) + randomRange(-0.05, 0.05);
              sparks.push({
                angle: sparkAngle,
                length: randomRange(2, 5),
                lifetime: 0.2,
              });
            }
          }
  
          for (let i = sparks.length - 1; i >= 0; i--) {
            sparks[i].lifetime -= dt;
            if (sparks[i].lifetime <= 0) {
              sparks.splice(i, 1);
            }
          }
  
          for (let i = bullets.length - 1; i >= 0; i--) {
            const b = bullets[i];
            b.x += b.vx * dt;
            b.y += b.vy * dt;
            if (b.x < 0 || b.x > canvas.width || b.y < 0 || b.y > canvas.height) {
              bullets.splice(i, 1);
            }
          }
  
          // Update comets
          for (let comet of comets) {
            if (comet.slowEffectTimer > 0) {
              comet.slowEffectTimer -= dt;
              if (comet.slowEffectTimer < 0) {
                comet.slowEffectTimer = 0;
              }
            }
            if (comet.indestructableTimer > 0) {
              comet.indestructableTimer -= dt;
              if (comet.indestructableTimer < 0) {
                comet.indestructableTimer = 0;
              }
            }
            if (comet.hitEffectTimer > 0) {
              comet.hitEffectTimer -= dt;
              if (comet.hitEffectTimer < 0) {
                comet.hitEffectTimer = 0;
              }
            }
            comet.x += comet.vx * dt;
            comet.y += comet.vy * dt;
            comet.vx *= COMET_FRICTION;
            comet.vy *= COMET_FRICTION;
  
            let currentSpeed = Math.hypot(comet.vx, comet.vy);
            if (currentSpeed < COMET_MIN_SPEED && currentSpeed > 0) {
              let factor = COMET_MIN_SPEED / currentSpeed;
              comet.vx *= factor;
              comet.vy *= factor;
            }
  
            bounce(comet, comet.radius);
  
            comet.trailTimer += dt;
            if (comet.trailTimer >= TRAIL_INTERVAL) {
              comet.trailTimer -= TRAIL_INTERVAL;
              comet.trail.push({ x: comet.x, y: comet.y });
              if (comet.trail.length > 10) {
                comet.trail.shift();
              }
            }
          }
  
          // Check collisions: Bullets vs. Comets
          for (let i = bullets.length - 1; i >= 0; i--) {
            const b = bullets[i];
            let bulletHit = false;
            for (let j = comets.length - 1; j >= 0; j--) {
              const c = comets[j];
              if (c.indestructableTimer > 0) continue;
              const dx = b.x - c.x;
              const dy = b.y - c.y;
              if (Math.hypot(dx, dy) < c.radius) {
                bulletHit = true;
                hitSoundPool[nextHitSoundIndex].currentTime = 0;
                hitSoundPool[nextHitSoundIndex].play();
                nextHitSoundIndex = (nextHitSoundIndex + 1) % HIT_SOUND_POOL_SIZE;
                c.hitPoints--;
                if (c.tier === 3) {
                  if (c.slowEffectTimer === 0) {
                    c.vx *= 0.66;
                    c.vy *= 0.66;
                    c.slowEffectTimer = 0.5;
                  }
                }
                c.hitEffectTimer = 0.5;
                if (c.hitPoints <= 0) {
                  createSmallExplosion(c.x, c.y);
                  if (c.tier > 1) {
                    const newTier = c.tier - 1;
                    const baseSpeed = Math.hypot(c.vx, c.vy);
                    let splits = Math.floor(randomRange(2, 6));
                    const offset = 50;
                    for (let k = 0; k < splits; k++) {
                      let newAngle = Math.random() * 2 * Math.PI;
                      let factor = randomRange(0.7, 0.8);
                      let extraFactor = randomRange(1.2, 1.5);
                      let newSpeed = baseSpeed * factor * extraFactor;
                      spawnComet(
                        newTier,
                        c.x + Math.cos(newAngle) * offset,
                        c.y + Math.sin(newAngle) * offset,
                        Math.cos(newAngle) * newSpeed,
                        Math.sin(newAngle) * newSpeed
                      );
                      comets[comets.length - 1].indestructableTimer = 0.01;
                    }
                  }
                  score += 10;
                  comets.splice(j, 1);
                }
                break;
              }
            }
            if (bulletHit) {
              bullets.splice(i, 1);
            }
          }
  
          checkCometCollisions();
  
          if (spawnAllowed) {
            cometSpawnTimer += dt;
            if (cometSpawnTimer > nextCometSpawn) {
              let area = canvas.width * canvas.height;
              let scaleFactor = area / 480000;
              scaleFactor = Math.max(0.5, Math.min(2, scaleFactor));
              let spawnCount = Math.floor(
                (COMET_SPAWN_BATCH_MIN + Math.floor(Math.random() * (COMET_SPAWN_BATCH_MAX - COMET_SPAWN_BATCH_MIN + 1))) *
                scaleFactor
              );
              for (let i = 0; i < spawnCount; i++) {
                spawnComet();
              }
              cometSpawnTimer = 0;
              nextCometSpawn = randomRange(COMET_SPAWN_MIN, COMET_SPAWN_MAX);
            }
          }
        }
  
        function draw() {
          ctx.fillStyle = "black";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          drawStarfield(ctx);
  
          if (gameState === "menu") {
            ctx.fillStyle = "white";
            ctx.font = "48px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText("Splitting Comets", canvas.width / 2, canvas.height / 2 - 50);
            ctx.font = "24px sans-serif";
            ctx.fillText("Press ENTER to start", canvas.width / 2, canvas.height / 2);
            ctx.fillText("Press S for settings", canvas.width / 2, canvas.height / 2 + 40);
            ctx.fillText("Score: " + score, canvas.width / 2, 40);
            return;
          }
          if (gameState === "settings") {
            ctx.fillStyle = "white";
            ctx.font = "48px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText("Settings (dummy)", canvas.width / 2, canvas.height / 2 - 50);
            ctx.font = "24px sans-serif";
            ctx.fillText("Press ESC to return", canvas.width / 2, canvas.height / 2);
            return;
          }
          if (gameState === "win") {
            for (let p of smallExplosionParticles) {
              ctx.beginPath();
              ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
              ctx.fillStyle = p.color;
              ctx.fill();
            }
            ctx.fillStyle = "lime";
            ctx.font = "48px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText("WIN!", canvas.width / 2, canvas.height / 2);
            ctx.font = "24px sans-serif";
            ctx.fillText("Score: " + score, canvas.width / 2, 40);
            return;
          }
          if (gameState === "gameover") {
            for (let p of smallExplosionParticles) {
              ctx.beginPath();
              ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
              ctx.fillStyle = p.color;
              ctx.fill();
            }
            ctx.fillStyle = "red";
            ctx.font = "48px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2);
            ctx.font = "24px sans-serif";
            ctx.fillText("Press ENTER to restart", canvas.width / 2, canvas.height / 2 + 40);
            ctx.fillText("Score: " + score, canvas.width / 2, 40);
            return;
          }
  
          ctx.fillStyle = "white";
          ctx.font = "24px sans-serif";
          ctx.textAlign = "center";
          ctx.fillText("Score: " + score, canvas.width / 2, 40);
          drawHealthBar();
  
          // Draw spaceship with hit flash & low-HP blinking effect
          ctx.save();
          ctx.translate(spaceship.x, spaceship.y);
          ctx.rotate(spaceship.angle);
          ctx.shadowBlur = 20;
          ctx.shadowColor = "cyan";
          let shipFill = "gray";
          if (spaceship.hitFlashTimer > 0) {
            shipFill = "red";
          } else if (spaceship.hitPoints <= 2) {
            shipFill = (Math.floor(gameTime * 10) % 2 === 0) ? "red" : "gray";
          }
          ctx.beginPath();
          ctx.moveTo(spaceship.size, 0);
          ctx.quadraticCurveTo(spaceship.size / 2, -spaceship.size / 2, -spaceship.size / 2, -spaceship.size / 4);
          ctx.quadraticCurveTo(-spaceship.size / 2, spaceship.size / 4, spaceship.size / 2, spaceship.size / 2);
          ctx.quadraticCurveTo(spaceship.size, 0, spaceship.size, 0);
          ctx.closePath();
          ctx.fillStyle = shipFill;
          ctx.fill();
          ctx.strokeStyle = "white";
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(spaceship.size / 2, 0, spaceship.size / 8, 0, 2 * Math.PI);
          ctx.fillStyle = "lightblue";
          ctx.fill();
          ctx.stroke();
          ctx.restore();
  
          // Draw sparks
          const noseX = spaceship.x + Math.cos(spaceship.angle) * spaceship.size;
          const noseY = spaceship.y + Math.sin(spaceship.angle) * spaceship.size;
          ctx.save();
          ctx.strokeStyle = "yellow";
          ctx.lineWidth = 1;
          for (let spark of sparks) {
            ctx.beginPath();
            ctx.moveTo(noseX, noseY);
            ctx.lineTo(
              noseX + Math.cos(spark.angle) * spark.length,
              noseY + Math.sin(spark.angle) * spark.length
            );
            ctx.stroke();
          }
          ctx.restore();
  
          // Draw bullets
          ctx.fillStyle = "white";
          for (let b of bullets) {
            ctx.beginPath();
            ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
            ctx.fill();
          }
  
          // Draw comet trails
          for (let c of comets) {
            if (c.trail && c.trail.length > 0) {
              ctx.save();
              let maxAlpha = 0.05;
              for (let i = 0; i < c.trail.length; i++) {
                let pos = c.trail[i];
                let alpha = ((i + 1) / c.trail.length) * maxAlpha;
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, c.radius, 0, 2 * Math.PI);
                ctx.fillStyle = c.color;
                ctx.fill();
              }
              ctx.restore();
            }
          }
  
          // Draw comets with irregular shape and stone texture, fully opaque
          for (let c of comets) {
            let drawX = c.x;
            let drawY = c.y;
            ctx.save();
            ctx.globalAlpha = 1.0;
            ctx.beginPath();
            if (c.shape && c.shape.length > 0) {
              ctx.moveTo(drawX + c.radius * c.shape[0].factor * Math.cos(c.shape[0].angle),
                         drawY + c.radius * c.shape[0].factor * Math.sin(c.shape[0].angle));
              for (let i = 1; i < c.shape.length; i++) {
                let pointX = drawX + c.radius * c.shape[i].factor * Math.cos(c.shape[i].angle);
                let pointY = drawY + c.radius * c.shape[i].factor * Math.sin(c.shape[i].angle);
                ctx.lineTo(pointX, pointY);
              }
              ctx.closePath();
            } else {
              ctx.arc(drawX, drawY, c.radius, 0, Math.PI * 2);
            }
            ctx.fillStyle = c.pattern;
            ctx.fill();
            ctx.strokeStyle = "white";
            ctx.lineWidth = 1;
            ctx.stroke();
            ctx.restore();
          }
  
          // Draw explosion particles
          for (let p of smallExplosionParticles) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fillStyle = p.color;
            ctx.fill();
          }
        }
  
        // Spawn an initial comet
        spawnComet();
  
      })();
    </script>
  </body>
</html>